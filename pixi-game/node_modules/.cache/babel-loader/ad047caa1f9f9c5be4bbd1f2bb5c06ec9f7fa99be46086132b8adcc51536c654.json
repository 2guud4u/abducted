{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _ = require('../');\nvar _utils = require('../utils');\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.loader.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.loader.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\nvar Spritesheet = function () {\n  _createClass(Spritesheet, null, [{\n    key: 'BATCH_SIZE',\n    /**\n     * The maximum number of Textures to build per process.\n     *\n     * @type {number}\n     * @default 1000\n     */\n    get: function get() {\n      return 1000;\n    }\n\n    /**\n     * @param {PIXI.BaseTexture} baseTexture Reference to the source BaseTexture object.\n     * @param {Object} data - Spritesheet image data.\n     * @param {string} [resolutionFilename] - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n  }]);\n\n  function Spritesheet(baseTexture, data) {\n    var resolutionFilename = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, Spritesheet);\n\n    /**\n     * Reference to ths source texture\n     * @type {PIXI.BaseTexture}\n     */\n    this.baseTexture = baseTexture;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link PIXI.Sprite|Sprite}:\n     * ```js\n     * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n     * ```\n     * @member {Object}\n     */\n    this.textures = {};\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link PIXI.extras.AnimatedSprite|AnimatedSprite}:\n     * ```js\n     * new PIXI.extras.AnimatedSprite(sheet.animations[\"anim_name\"])\n     * ```\n     * @member {Object}\n     */\n    this.animations = {};\n\n    /**\n     * Reference to the original JSON data.\n     * @type {Object}\n     */\n    this.data = data;\n\n    /**\n     * The resolution of the spritesheet.\n     * @type {number}\n     */\n    this.resolution = this._updateResolution(resolutionFilename || this.baseTexture.imageUrl);\n\n    /**\n     * Map of spritesheet frames.\n     * @type {Object}\n     * @private\n     */\n    this._frames = this.data.frames;\n\n    /**\n     * Collection of frame names.\n     * @type {string[]}\n     * @private\n     */\n    this._frameKeys = Object.keys(this._frames);\n\n    /**\n     * Current batch index being processed.\n     * @type {number}\n     * @private\n     */\n    this._batchIndex = 0;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     * @private\n     */\n    this._callback = null;\n  }\n\n  /**\n   * Generate the resolution from the filename or fallback\n   * to the meta.scale field of the JSON data.\n   *\n   * @private\n   * @param {string} resolutionFilename - The filename to use for resolving\n   *        the default resolution.\n   * @return {number} Resolution to use for spritesheet.\n   */\n\n  Spritesheet.prototype._updateResolution = function _updateResolution(resolutionFilename) {\n    var scale = this.data.meta.scale;\n\n    // Use a defaultValue of `null` to check if a url-based resolution is set\n    var resolution = (0, _utils.getResolutionOfUrl)(resolutionFilename, null);\n\n    // No resolution found via URL\n    if (resolution === null) {\n      // Use the scale value or default to 1\n      resolution = scale !== undefined ? parseFloat(scale) : 1;\n    }\n\n    // For non-1 resolutions, update baseTexture\n    if (resolution !== 1) {\n      this.baseTexture.resolution = resolution;\n      this.baseTexture.update();\n    }\n    return resolution;\n  };\n\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   *\n   * @param {Function} callback - Callback when complete returns\n   *        a map of the Textures for this spritesheet.\n   */\n\n  Spritesheet.prototype.parse = function parse(callback) {\n    this._batchIndex = 0;\n    this._callback = callback;\n    if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {\n      this._processFrames(0);\n      this._processAnimations();\n      this._parseComplete();\n    } else {\n      this._nextBatch();\n    }\n  };\n\n  /**\n   * Process a batch of frames\n   *\n   * @private\n   * @param {number} initialFrameIndex - The index of frame to start.\n   */\n\n  Spritesheet.prototype._processFrames = function _processFrames(initialFrameIndex) {\n    var frameIndex = initialFrameIndex;\n    var maxFrames = Spritesheet.BATCH_SIZE;\n    var sourceScale = this.baseTexture.sourceScale;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      var i = this._frameKeys[frameIndex];\n      var data = this._frames[i];\n      var rect = data.frame;\n      if (rect) {\n        var frame = null;\n        var trim = null;\n        var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        var orig = new _.Rectangle(0, 0, Math.floor(sourceSize.w * sourceScale) / this.resolution, Math.floor(sourceSize.h * sourceScale) / this.resolution);\n        if (data.rotated) {\n          frame = new _.Rectangle(Math.floor(rect.x * sourceScale) / this.resolution, Math.floor(rect.y * sourceScale) / this.resolution, Math.floor(rect.h * sourceScale) / this.resolution, Math.floor(rect.w * sourceScale) / this.resolution);\n        } else {\n          frame = new _.Rectangle(Math.floor(rect.x * sourceScale) / this.resolution, Math.floor(rect.y * sourceScale) / this.resolution, Math.floor(rect.w * sourceScale) / this.resolution, Math.floor(rect.h * sourceScale) / this.resolution);\n        }\n\n        //  Check to see if the sprite is trimmed\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new _.Rectangle(Math.floor(data.spriteSourceSize.x * sourceScale) / this.resolution, Math.floor(data.spriteSourceSize.y * sourceScale) / this.resolution, Math.floor(rect.w * sourceScale) / this.resolution, Math.floor(rect.h * sourceScale) / this.resolution);\n        }\n        this.textures[i] = new _.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);\n\n        // lets also add the frame to pixi's global cache for fromFrame and fromImage functions\n        _.Texture.addToCache(this.textures[i], i);\n      }\n      frameIndex++;\n    }\n  };\n\n  /**\n   * Parse animations config\n   *\n   * @private\n   */\n\n  Spritesheet.prototype._processAnimations = function _processAnimations() {\n    var animations = this.data.animations || {};\n    for (var animName in animations) {\n      this.animations[animName] = [];\n      for (var _iterator = animations[animName], _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n        var frameName = _ref;\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  };\n\n  /**\n   * The parse has completed.\n   *\n   * @private\n   */\n\n  Spritesheet.prototype._parseComplete = function _parseComplete() {\n    var callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  };\n\n  /**\n   * Begin the next batch of textures.\n   *\n   * @private\n   */\n\n  Spritesheet.prototype._nextBatch = function _nextBatch() {\n    var _this = this;\n    this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(function () {\n      if (_this._batchIndex * Spritesheet.BATCH_SIZE < _this._frameKeys.length) {\n        _this._nextBatch();\n      } else {\n        _this._processAnimations();\n        _this._parseComplete();\n      }\n    }, 0);\n  };\n\n  /**\n   * Destroy Spritesheet and don't use after this.\n   *\n   * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n   */\n\n  Spritesheet.prototype.destroy = function destroy() {\n    var destroyBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    for (var i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this.baseTexture.destroy();\n    }\n    this.baseTexture = null;\n  };\n  return Spritesheet;\n}();\nexports.default = Spritesheet;","map":{"version":3,"names":["_","require","_utils","Spritesheet","baseTexture","data","resolutionFilename","arguments","length","undefined","_classCallCheck","textures","animations","resolution","_updateResolution","imageUrl","_frames","frames","_frameKeys","Object","keys","_batchIndex","_callback","scale","meta","getResolutionOfUrl","parseFloat","update","parse","callback","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","sourceScale","i","rect","frame","trim","sourceSize","trimmed","orig","Rectangle","Math","floor","w","h","rotated","x","y","spriteSourceSize","Texture","anchor","addToCache","animName","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","value","frameName","push","call","_this","setTimeout","destroy","destroyBase"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/textures/Spritesheet.js"],"sourcesContent":["import { Rectangle, Texture } from '../';\nimport { getResolutionOfUrl } from '../utils';\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.loader.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.loader.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\nexport default class Spritesheet\n{\n    /**\n     * The maximum number of Textures to build per process.\n     *\n     * @type {number}\n     * @default 1000\n     */\n    static get BATCH_SIZE()\n    {\n        return 1000;\n    }\n\n    /**\n     * @param {PIXI.BaseTexture} baseTexture Reference to the source BaseTexture object.\n     * @param {Object} data - Spritesheet image data.\n     * @param {string} [resolutionFilename] - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n    constructor(baseTexture, data, resolutionFilename = null)\n    {\n        /**\n         * Reference to ths source texture\n         * @type {PIXI.BaseTexture}\n         */\n        this.baseTexture = baseTexture;\n\n        /**\n         * A map containing all textures of the sprite sheet.\n         * Can be used to create a {@link PIXI.Sprite|Sprite}:\n         * ```js\n         * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n         * ```\n         * @member {Object}\n         */\n        this.textures = {};\n\n        /**\n         * A map containing the textures for each animation.\n         * Can be used to create an {@link PIXI.extras.AnimatedSprite|AnimatedSprite}:\n         * ```js\n         * new PIXI.extras.AnimatedSprite(sheet.animations[\"anim_name\"])\n         * ```\n         * @member {Object}\n         */\n        this.animations = {};\n\n        /**\n         * Reference to the original JSON data.\n         * @type {Object}\n         */\n        this.data = data;\n\n        /**\n         * The resolution of the spritesheet.\n         * @type {number}\n         */\n        this.resolution = this._updateResolution(\n            resolutionFilename || this.baseTexture.imageUrl\n        );\n\n        /**\n         * Map of spritesheet frames.\n         * @type {Object}\n         * @private\n         */\n        this._frames = this.data.frames;\n\n        /**\n         * Collection of frame names.\n         * @type {string[]}\n         * @private\n         */\n        this._frameKeys = Object.keys(this._frames);\n\n        /**\n         * Current batch index being processed.\n         * @type {number}\n         * @private\n         */\n        this._batchIndex = 0;\n\n        /**\n         * Callback when parse is completed.\n         * @type {Function}\n         * @private\n         */\n        this._callback = null;\n    }\n\n    /**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     *\n     * @private\n     * @param {string} resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @return {number} Resolution to use for spritesheet.\n     */\n    _updateResolution(resolutionFilename)\n    {\n        const scale = this.data.meta.scale;\n\n        // Use a defaultValue of `null` to check if a url-based resolution is set\n        let resolution = getResolutionOfUrl(resolutionFilename, null);\n\n        // No resolution found via URL\n        if (resolution === null)\n        {\n            // Use the scale value or default to 1\n            resolution = scale !== undefined ? parseFloat(scale) : 1;\n        }\n\n        // For non-1 resolutions, update baseTexture\n        if (resolution !== 1)\n        {\n            this.baseTexture.resolution = resolution;\n            this.baseTexture.update();\n        }\n\n        return resolution;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     *\n     * @param {Function} callback - Callback when complete returns\n     *        a map of the Textures for this spritesheet.\n     */\n    parse(callback)\n    {\n        this._batchIndex = 0;\n        this._callback = callback;\n\n        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n        {\n            this._processFrames(0);\n            this._processAnimations();\n            this._parseComplete();\n        }\n        else\n        {\n            this._nextBatch();\n        }\n    }\n\n    /**\n     * Process a batch of frames\n     *\n     * @private\n     * @param {number} initialFrameIndex - The index of frame to start.\n     */\n    _processFrames(initialFrameIndex)\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n        const sourceScale = this.baseTexture.sourceScale;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w * sourceScale) / this.resolution,\n                    Math.floor(sourceSize.h * sourceScale) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x * sourceScale) / this.resolution,\n                        Math.floor(rect.y * sourceScale) / this.resolution,\n                        Math.floor(rect.h * sourceScale) / this.resolution,\n                        Math.floor(rect.w * sourceScale) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x * sourceScale) / this.resolution,\n                        Math.floor(rect.y * sourceScale) / this.resolution,\n                        Math.floor(rect.w * sourceScale) / this.resolution,\n                        Math.floor(rect.h * sourceScale) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x * sourceScale) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y * sourceScale) / this.resolution,\n                        Math.floor(rect.w * sourceScale) / this.resolution,\n                        Math.floor(rect.h * sourceScale) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture(\n                    this.baseTexture,\n                    frame,\n                    orig,\n                    trim,\n                    data.rotated ? 2 : 0,\n                    data.anchor\n                );\n\n                // lets also add the frame to pixi's global cache for fromFrame and fromImage functions\n                Texture.addToCache(this.textures[i], i);\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /**\n     * Parse animations config\n     *\n     * @private\n     */\n    _processAnimations()\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName] = [];\n            for (const frameName of animations[animName])\n            {\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /**\n     * The parse has completed.\n     *\n     * @private\n     */\n    _parseComplete()\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /**\n     * Begin the next batch of textures.\n     *\n     * @private\n     */\n    _nextBatch()\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     *\n     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n     */\n    destroy(destroyBase = false)\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this.baseTexture.destroy();\n        }\n        this.baseTexture = null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}