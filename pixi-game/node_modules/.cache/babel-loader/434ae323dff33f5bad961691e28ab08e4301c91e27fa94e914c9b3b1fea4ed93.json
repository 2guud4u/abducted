{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.encodeBinary = encodeBinary;\nvar _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n/**\n * Encodes binary into base64.\n *\n * @param {string} input The input data to encode.\n * @returns {string} The encoded base64 string\n */\nfunction encodeBinary(input) {\n  var output = '';\n  var inx = 0;\n  while (inx < input.length) {\n    // Fill byte buffer array\n    var bytebuffer = [0, 0, 0];\n    var encodedCharIndexes = [0, 0, 0, 0];\n    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {\n      if (inx < input.length) {\n        // throw away high-order byte, as documented at:\n        // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n        bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n      } else {\n        bytebuffer[jnx] = 0;\n      }\n    }\n\n    // Get each encoded character, 6 bits at a time\n    // index 1: first 6 bits\n    encodedCharIndexes[0] = bytebuffer[0] >> 2;\n\n    // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n    encodedCharIndexes[1] = (bytebuffer[0] & 0x3) << 4 | bytebuffer[1] >> 4;\n\n    // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n    encodedCharIndexes[2] = (bytebuffer[1] & 0x0f) << 2 | bytebuffer[2] >> 6;\n\n    // index 3: forth 6 bits (6 least significant bits from input byte 3)\n    encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n\n    // Determine whether padding happened, and adjust accordingly\n    var paddingBytes = inx - (input.length - 1);\n    switch (paddingBytes) {\n      case 2:\n        // Set last 2 characters to padding char\n        encodedCharIndexes[3] = 64;\n        encodedCharIndexes[2] = 64;\n        break;\n      case 1:\n        // Set last character to padding char\n        encodedCharIndexes[3] = 64;\n        break;\n      default:\n        break;\n      // No padding - proceed\n    }\n\n    // Now we will grab each appropriate character out of our keystring\n    // based on our index array and append it to the output string\n    for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {\n      output += _keyStr.charAt(encodedCharIndexes[_jnx]);\n    }\n  }\n  return output;\n}\n\n// Backwards compat\nif (typeof module !== 'undefined') {\n  module.exports.default = encodeBinary; // eslint-disable-line no-undef\n}","map":{"version":3,"names":["encodeBinary","_keyStr","input","output","inx","length","bytebuffer","encodedCharIndexes","jnx","charCodeAt","paddingBytes","_jnx","charAt","module","exports","default"],"sources":["/Users/jiahuajiang/node_modules/resource-loader/src/b64.js"],"sourcesContent":["const _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n/**\n * Encodes binary into base64.\n *\n * @param {string} input The input data to encode.\n * @returns {string} The encoded base64 string\n */\nexport function encodeBinary(input) {\n    let output = '';\n    let inx = 0;\n\n    while (inx < input.length) {\n        // Fill byte buffer array\n        const bytebuffer = [0, 0, 0];\n        const encodedCharIndexes = [0, 0, 0, 0];\n\n        for (let jnx = 0; jnx < bytebuffer.length; ++jnx) {\n            if (inx < input.length) {\n                // throw away high-order byte, as documented at:\n                // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n                bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n            }\n            else {\n                bytebuffer[jnx] = 0;\n            }\n        }\n\n        // Get each encoded character, 6 bits at a time\n        // index 1: first 6 bits\n        encodedCharIndexes[0] = bytebuffer[0] >> 2;\n\n        // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n        encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);\n\n        // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n        encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);\n\n        // index 3: forth 6 bits (6 least significant bits from input byte 3)\n        encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n\n        // Determine whether padding happened, and adjust accordingly\n        const paddingBytes = inx - (input.length - 1);\n\n        switch (paddingBytes) {\n            case 2:\n                // Set last 2 characters to padding char\n                encodedCharIndexes[3] = 64;\n                encodedCharIndexes[2] = 64;\n                break;\n\n            case 1:\n                // Set last character to padding char\n                encodedCharIndexes[3] = 64;\n                break;\n\n            default:\n                break; // No padding - proceed\n        }\n\n        // Now we will grab each appropriate character out of our keystring\n        // based on our index array and append it to the output string\n        for (let jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {\n            output += _keyStr.charAt(encodedCharIndexes[jnx]);\n        }\n    }\n\n    return output;\n}\n\n// Backwards compat\nif (typeof module !== 'undefined') {\n    module.exports.default = encodeBinary; // eslint-disable-line no-undef\n}\n"],"mappings":";;;QAQgBA,Y,GAAAA,Y;AARhB,IAAMC,OAAA,GAAU,mEAAhB;;AAEA;;;;;;AAMO,SAASD,YAATA,CAAsBE,KAAtB,EAA6B;EAChC,IAAIC,MAAA,GAAS,EAAb;EACA,IAAIC,GAAA,GAAM,CAAV;EAEA,OAAOA,GAAA,GAAMF,KAAA,CAAMG,MAAnB,EAA2B;IACvB;IACA,IAAMC,UAAA,GAAa,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAnB;IACA,IAAMC,kBAAA,GAAqB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAA3B;IAEA,KAAK,IAAIC,GAAA,GAAM,CAAf,EAAkBA,GAAA,GAAMF,UAAA,CAAWD,MAAnC,EAA2C,EAAEG,GAA7C,EAAkD;MAC9C,IAAIJ,GAAA,GAAMF,KAAA,CAAMG,MAAhB,EAAwB;QACpB;QACA;QACAC,UAAA,CAAWE,GAAX,IAAkBN,KAAA,CAAMO,UAAN,CAAiBL,GAAA,EAAjB,IAA0B,IAA5C;MACH,CAJD,MAKK;QACDE,UAAA,CAAWE,GAAX,IAAkB,CAAlB;MACH;IACJ;;IAED;IACA;IACAD,kBAAA,CAAmB,CAAnB,IAAwBD,UAAA,CAAW,CAAX,KAAiB,CAAzC;;IAEA;IACAC,kBAAA,CAAmB,CAAnB,IAAyB,CAACD,UAAA,CAAW,CAAX,IAAgB,GAAjB,KAAyB,CAA1B,GAAgCA,UAAA,CAAW,CAAX,KAAiB,CAAzE;;IAEA;IACAC,kBAAA,CAAmB,CAAnB,IAAyB,CAACD,UAAA,CAAW,CAAX,IAAgB,IAAjB,KAA0B,CAA3B,GAAiCA,UAAA,CAAW,CAAX,KAAiB,CAA1E;;IAEA;IACAC,kBAAA,CAAmB,CAAnB,IAAwBD,UAAA,CAAW,CAAX,IAAgB,IAAxC;;IAEA;IACA,IAAMI,YAAA,GAAeN,GAAA,IAAOF,KAAA,CAAMG,MAAN,GAAe,CAAtB,CAArB;IAEA,QAAQK,YAAR;MACI,KAAK,CAAL;QACI;QACAH,kBAAA,CAAmB,CAAnB,IAAwB,EAAxB;QACAA,kBAAA,CAAmB,CAAnB,IAAwB,EAAxB;QACA;MAEJ,KAAK,CAAL;QACI;QACAA,kBAAA,CAAmB,CAAnB,IAAwB,EAAxB;QACA;MAEJ;QACI;MAAO;IAbf;;IAgBA;IACA;IACA,KAAK,IAAII,IAAA,GAAM,CAAf,EAAkBA,IAAA,GAAMJ,kBAAA,CAAmBF,MAA3C,EAAmD,EAAEM,IAArD,EAA0D;MACtDR,MAAA,IAAUF,OAAA,CAAQW,MAAR,CAAeL,kBAAA,CAAmBI,IAAnB,CAAf,CAAV;IACH;EACJ;EAED,OAAOR,MAAP;AACH;;AAED;AACA,IAAI,OAAOU,MAAP,KAAkB,WAAtB,EAAmC;EAC/BA,MAAA,CAAOC,OAAP,CAAeC,OAAf,GAAyBf,YAAzB,CAD+B,CACQ;AAC1C"},"metadata":{},"sourceType":"script","externalDependencies":[]}