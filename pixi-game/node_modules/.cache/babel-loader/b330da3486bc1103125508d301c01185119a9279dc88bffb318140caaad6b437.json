{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _eventemitter = require('eventemitter3');\nvar _eventemitter2 = _interopRequireDefault(_eventemitter);\nvar _const = require('../const');\nvar _settings = require('../settings');\nvar _settings2 = _interopRequireDefault(_settings);\nvar _TransformStatic = require('./TransformStatic');\nvar _TransformStatic2 = _interopRequireDefault(_TransformStatic);\nvar _Transform = require('./Transform');\nvar _Transform2 = _interopRequireDefault(_Transform);\nvar _Bounds = require('./Bounds');\nvar _Bounds2 = _interopRequireDefault(_Bounds);\nvar _math = require('../math');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n// _tempDisplayObjectParent = new DisplayObject();\n\n/**\n * The base class for all objects that are rendered on the screen.\n * This is an abstract class and should not be used on its own rather it should be extended.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\nvar DisplayObject = function (_EventEmitter) {\n  _inherits(DisplayObject, _EventEmitter);\n\n  /**\n   *\n   */\n  function DisplayObject() {\n    _classCallCheck(this, DisplayObject);\n    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));\n    var TransformClass = _settings2.default.TRANSFORM_MODE === _const.TRANSFORM_MODE.STATIC ? _TransformStatic2.default : _Transform2.default;\n    _this.tempDisplayObjectParent = null;\n\n    // TODO: need to create Transform from factory\n    /**\n     * World transform and local transform of this object.\n     * This will become read-only later, please do not assign anything there unless you know what are you doing\n     *\n     * @member {PIXI.TransformBase}\n     */\n    _this.transform = new TransformClass();\n\n    /**\n     * The opacity of the object.\n     *\n     * @member {number}\n     */\n    _this.alpha = 1;\n\n    /**\n     * The visibility of the object. If false the object will not be drawn, and\n     * the updateTransform function will not be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually\n     *\n     * @member {boolean}\n     */\n    _this.visible = true;\n\n    /**\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\n     * methods will still be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds manually\n     *\n     * @member {boolean}\n     */\n    _this.renderable = true;\n\n    /**\n     * The display object container that contains this display object.\n     *\n     * @member {PIXI.Container}\n     * @readonly\n     */\n    _this.parent = null;\n\n    /**\n     * The multiplied alpha of the displayObject\n     *\n     * @member {number}\n     * @readonly\n     */\n    _this.worldAlpha = 1;\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimisation\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle\n     *\n     * Also works as an interaction mask\n     *\n     * @member {PIXI.Rectangle}\n     */\n    _this.filterArea = null;\n    _this._filters = null;\n    _this._enabledFilters = null;\n\n    /**\n     * The bounds object, this is used to calculate and store the bounds of the displayObject\n     *\n     * @member {PIXI.Rectangle}\n     * @private\n     */\n    _this._bounds = new _Bounds2.default();\n    _this._boundsID = 0;\n    _this._lastBoundsID = -1;\n    _this._boundsRect = null;\n    _this._localBoundsRect = null;\n\n    /**\n     * The original, cached mask of the object\n     *\n     * @member {PIXI.Graphics|PIXI.Sprite}\n     * @private\n     */\n    _this._mask = null;\n\n    /**\n     * If the object has been destroyed via destroy(). If true, it should not be used.\n     *\n     * @member {boolean}\n     * @private\n     * @readonly\n     */\n    _this._destroyed = false;\n\n    /**\n     * Fired when this DisplayObject is added to a Container.\n     *\n     * @event PIXI.DisplayObject#added\n     * @param {PIXI.Container} container - The container added to.\n     */\n\n    /**\n     * Fired when this DisplayObject is removed from a Container.\n     *\n     * @event PIXI.DisplayObject#removed\n     * @param {PIXI.Container} container - The container removed from.\n     */\n    return _this;\n  }\n\n  /**\n   * @private\n   * @member {PIXI.DisplayObject}\n   */\n\n  /**\n   * Updates the object transform for rendering\n   *\n   * TODO - Optimization pass!\n   */\n  DisplayObject.prototype.updateTransform = function updateTransform() {\n    this.transform.updateTransform(this.parent.transform);\n    // multiply the alphas..\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._bounds.updateID++;\n  };\n\n  /**\n   * recursively updates transform of all objects from the root to this one\n   * internal function for toLocal()\n   */\n\n  DisplayObject.prototype._recursivePostUpdateTransform = function _recursivePostUpdateTransform() {\n    if (this.parent) {\n      this.parent._recursivePostUpdateTransform();\n      this.transform.updateTransform(this.parent.transform);\n    } else {\n      this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n    }\n  };\n\n  /**\n   * Retrieves the bounds of the displayObject as a rectangle object.\n   *\n   * @param {boolean} skipUpdate - setting to true will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost\n   * @param {PIXI.Rectangle} rect - Optional rectangle to store the result of the bounds calculation\n   * @return {PIXI.Rectangle} the rectangular bounding area\n   */\n\n  DisplayObject.prototype.getBounds = function getBounds(skipUpdate, rect) {\n    if (!skipUpdate) {\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.updateTransform();\n        this.parent = null;\n      } else {\n        this._recursivePostUpdateTransform();\n        this.updateTransform();\n      }\n    }\n    if (this._boundsID !== this._lastBoundsID) {\n      this.calculateBounds();\n    }\n    if (!rect) {\n      if (!this._boundsRect) {\n        this._boundsRect = new _math.Rectangle();\n      }\n      rect = this._boundsRect;\n    }\n    return this._bounds.getRectangle(rect);\n  };\n\n  /**\n   * Retrieves the local bounds of the displayObject as a rectangle object\n   *\n   * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation\n   * @return {PIXI.Rectangle} the rectangular bounding area\n   */\n\n  DisplayObject.prototype.getLocalBounds = function getLocalBounds(rect) {\n    var transformRef = this.transform;\n    var parentRef = this.parent;\n    this.parent = null;\n    this.transform = this._tempDisplayObjectParent.transform;\n    if (!rect) {\n      if (!this._localBoundsRect) {\n        this._localBoundsRect = new _math.Rectangle();\n      }\n      rect = this._localBoundsRect;\n    }\n    var bounds = this.getBounds(false, rect);\n    this.parent = parentRef;\n    this.transform = transformRef;\n    return bounds;\n  };\n\n  /**\n   * Calculates the global position of the display object\n   *\n   * @param {PIXI.Point} position - The world origin to calculate from\n   * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point)\n   * @param {boolean} [skipUpdate=false] - Should we skip the update transform.\n   * @return {PIXI.Point} A point object representing the position of this object\n   */\n\n  DisplayObject.prototype.toGlobal = function toGlobal(position, point) {\n    var skipUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n\n      // this parent check is for just in case the item is a root object.\n      // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n      // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n\n    // don't need to update the lot\n    return this.worldTransform.apply(position, point);\n  };\n\n  /**\n   * Calculates the local position of the display object relative to another point\n   *\n   * @param {PIXI.Point} position - The world origin to calculate from\n   * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from\n   * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point)\n   * @param {boolean} [skipUpdate=false] - Should we skip the update transform\n   * @return {PIXI.Point} A point object representing the position of this object\n   */\n\n  DisplayObject.prototype.toLocal = function toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n\n      // this parent check is for just in case the item is a root object.\n      // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n      // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n\n    // simply apply the matrix..\n    return this.worldTransform.applyInverse(position, point);\n  };\n\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n  DisplayObject.prototype.renderWebGL = function renderWebGL(renderer)\n  // eslint-disable-line no-unused-vars\n  {}\n  // OVERWRITE;\n\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */;\n\n  DisplayObject.prototype.renderCanvas = function renderCanvas(renderer)\n  // eslint-disable-line no-unused-vars\n  {}\n  // OVERWRITE;\n\n  /**\n   * Set the parent Container of this DisplayObject\n   *\n   * @param {PIXI.Container} container - The Container to add this DisplayObject to\n   * @return {PIXI.Container} The Container that this DisplayObject was added to\n   */;\n\n  DisplayObject.prototype.setParent = function setParent(container) {\n    if (!container || !container.addChild) {\n      throw new Error('setParent: Argument must be a Container');\n    }\n    container.addChild(this);\n    return container;\n  };\n\n  /**\n   * Convenience function to set the position, scale, skew and pivot at once.\n   *\n   * @param {number} [x=0] - The X position\n   * @param {number} [y=0] - The Y position\n   * @param {number} [scaleX=1] - The X scale value\n   * @param {number} [scaleY=1] - The Y scale value\n   * @param {number} [rotation=0] - The rotation\n   * @param {number} [skewX=0] - The X skew value\n   * @param {number} [skewY=0] - The Y skew value\n   * @param {number} [pivotX=0] - The X pivot value\n   * @param {number} [pivotY=0] - The Y pivot value\n   * @return {PIXI.DisplayObject} The DisplayObject instance\n   */\n\n  DisplayObject.prototype.setTransform = function setTransform() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var scaleX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var scaleY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var skewX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var skewY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var pivotX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    var pivotY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    this.position.x = x;\n    this.position.y = y;\n    this.scale.x = !scaleX ? 1 : scaleX;\n    this.scale.y = !scaleY ? 1 : scaleY;\n    this.rotation = rotation;\n    this.skew.x = skewX;\n    this.skew.y = skewY;\n    this.pivot.x = pivotX;\n    this.pivot.y = pivotY;\n    return this;\n  };\n\n  /**\n   * Base destroy method for generic display objects. This will automatically\n   * remove the display object from its parent Container as well as remove\n   * all current event listeners and internal references. Do not use a DisplayObject\n   * after calling `destroy`.\n   *\n   */\n\n  DisplayObject.prototype.destroy = function destroy() {\n    this.removeAllListeners();\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n    this.transform = null;\n    this.parent = null;\n    this._bounds = null;\n    this._currentBounds = null;\n    this._mask = null;\n    this.filterArea = null;\n    this.interactive = false;\n    this.interactiveChildren = false;\n    this._destroyed = true;\n  };\n\n  /**\n   * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   *\n   * @member {number}\n   */\n\n  _createClass(DisplayObject, [{\n    key: '_tempDisplayObjectParent',\n    get: function get() {\n      if (this.tempDisplayObjectParent === null) {\n        this.tempDisplayObjectParent = new DisplayObject();\n      }\n      return this.tempDisplayObjectParent;\n    }\n  }, {\n    key: 'x',\n    get: function get() {\n      return this.position.x;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.transform.position.x = value;\n    }\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     *\n     * @member {number}\n     */\n  }, {\n    key: 'y',\n    get: function get() {\n      return this.position.y;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.transform.position.y = value;\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n  }, {\n    key: 'worldTransform',\n    get: function get() {\n      return this.transform.worldTransform;\n    }\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n  }, {\n    key: 'localTransform',\n    get: function get() {\n      return this.transform.localTransform;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n  }, {\n    key: 'position',\n    get: function get() {\n      return this.transform.position;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.transform.position.copy(value);\n    }\n\n    /**\n     * The scale factor of the object.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n  }, {\n    key: 'scale',\n    get: function get() {\n      return this.transform.scale;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.transform.scale.copy(value);\n    }\n\n    /**\n     * The pivot point of the displayObject that it rotates around.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n  }, {\n    key: 'pivot',\n    get: function get() {\n      return this.transform.pivot;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.transform.pivot.copy(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n  }, {\n    key: 'skew',\n    get: function get() {\n      return this.transform.skew;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.transform.skew.copy(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * @member {number}\n     */\n  }, {\n    key: 'rotation',\n    get: function get() {\n      return this.transform.rotation;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.transform.rotation = value;\n    }\n\n    /**\n     * Indicates if the object is globally visible.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n  }, {\n    key: 'worldVisible',\n    get: function get() {\n      var item = this;\n      do {\n        if (!item.visible) {\n          return false;\n        }\n        item = item.parent;\n      } while (item);\n      return true;\n    }\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PIXI a regular mask must be a\n     * PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it\n     * utilises shape clipping. To remove a mask, set this property to null.\n     *\n     * @todo For the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n     *\n     * @member {PIXI.Graphics|PIXI.Sprite}\n     */\n  }, {\n    key: 'mask',\n    get: function get() {\n      return this._mask;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      if (this._mask) {\n        this._mask.renderable = true;\n        this._mask.isMask = false;\n      }\n      this._mask = value;\n      if (this._mask) {\n        this._mask.renderable = false;\n        this._mask.isMask = true;\n      }\n    }\n\n    /**\n     * Sets the filters for the displayObject.\n     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to 'null'\n     *\n     * @member {PIXI.Filter[]}\n     */\n  }, {\n    key: 'filters',\n    get: function get() {\n      return this._filters && this._filters.slice();\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this._filters = value && value.slice();\n    }\n  }]);\n  return DisplayObject;\n}(_eventemitter2.default);\n\n// performance increase to avoid using call.. (10x faster)\n\nexports.default = DisplayObject;\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;","map":{"version":3,"names":["_eventemitter","require","_const","_settings","_TransformStatic","_Transform","_Bounds","_math","DisplayObject","_classCallCheck","_this","_possibleConstructorReturn","_EventEmitter","call","TransformClass","_settings2","default","TRANSFORM_MODE","STATIC","_TransformStatic2","_Transform2","tempDisplayObjectParent","transform","alpha","visible","renderable","parent","worldAlpha","filterArea","_filters","_enabledFilters","_bounds","_Bounds2","_boundsID","_lastBoundsID","_boundsRect","_localBoundsRect","_mask","_destroyed","updateTransform","updateID","_recursivePostUpdateTransform","_tempDisplayObjectParent","getBounds","skipUpdate","rect","calculateBounds","Rectangle","getRectangle","getLocalBounds","transformRef","parentRef","bounds","toGlobal","position","point","arguments","length","undefined","displayObjectUpdateTransform","worldTransform","apply","toLocal","from","applyInverse","renderWebGL","renderer","renderCanvas","setParent","container","addChild","Error","setTransform","x","y","scaleX","scaleY","rotation","skewX","skewY","pivotX","pivotY","scale","skew","pivot","destroy","removeAllListeners","removeChild","_currentBounds","interactive","interactiveChildren","value","localTransform","copy","item","isMask","slice","prototype"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/display/DisplayObject.js"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { TRANSFORM_MODE } from '../const';\nimport settings from '../settings';\nimport TransformStatic from './TransformStatic';\nimport Transform from './Transform';\nimport Bounds from './Bounds';\nimport { Rectangle } from '../math';\n// _tempDisplayObjectParent = new DisplayObject();\n\n/**\n * The base class for all objects that are rendered on the screen.\n * This is an abstract class and should not be used on its own rather it should be extended.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\nexport default class DisplayObject extends EventEmitter\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        super();\n\n        const TransformClass = settings.TRANSFORM_MODE === TRANSFORM_MODE.STATIC ? TransformStatic : Transform;\n\n        this.tempDisplayObjectParent = null;\n\n        // TODO: need to create Transform from factory\n        /**\n         * World transform and local transform of this object.\n         * This will become read-only later, please do not assign anything there unless you know what are you doing\n         *\n         * @member {PIXI.TransformBase}\n         */\n        this.transform = new TransformClass();\n\n        /**\n         * The opacity of the object.\n         *\n         * @member {number}\n         */\n        this.alpha = 1;\n\n        /**\n         * The visibility of the object. If false the object will not be drawn, and\n         * the updateTransform function will not be called.\n         *\n         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually\n         *\n         * @member {boolean}\n         */\n        this.visible = true;\n\n        /**\n         * Can this object be rendered, if false the object will not be drawn but the updateTransform\n         * methods will still be called.\n         *\n         * Only affects recursive calls from parent. You can ask for bounds manually\n         *\n         * @member {boolean}\n         */\n        this.renderable = true;\n\n        /**\n         * The display object container that contains this display object.\n         *\n         * @member {PIXI.Container}\n         * @readonly\n         */\n        this.parent = null;\n\n        /**\n         * The multiplied alpha of the displayObject\n         *\n         * @member {number}\n         * @readonly\n         */\n        this.worldAlpha = 1;\n\n        /**\n         * The area the filter is applied to. This is used as more of an optimisation\n         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle\n         *\n         * Also works as an interaction mask\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.filterArea = null;\n\n        this._filters = null;\n        this._enabledFilters = null;\n\n        /**\n         * The bounds object, this is used to calculate and store the bounds of the displayObject\n         *\n         * @member {PIXI.Rectangle}\n         * @private\n         */\n        this._bounds = new Bounds();\n        this._boundsID = 0;\n        this._lastBoundsID = -1;\n        this._boundsRect = null;\n        this._localBoundsRect = null;\n\n        /**\n         * The original, cached mask of the object\n         *\n         * @member {PIXI.Graphics|PIXI.Sprite}\n         * @private\n         */\n        this._mask = null;\n\n        /**\n         * If the object has been destroyed via destroy(). If true, it should not be used.\n         *\n         * @member {boolean}\n         * @private\n         * @readonly\n         */\n        this._destroyed = false;\n\n        /**\n         * Fired when this DisplayObject is added to a Container.\n         *\n         * @event PIXI.DisplayObject#added\n         * @param {PIXI.Container} container - The container added to.\n         */\n\n        /**\n         * Fired when this DisplayObject is removed from a Container.\n         *\n         * @event PIXI.DisplayObject#removed\n         * @param {PIXI.Container} container - The container removed from.\n         */\n    }\n\n    /**\n     * @private\n     * @member {PIXI.DisplayObject}\n     */\n    get _tempDisplayObjectParent()\n    {\n        if (this.tempDisplayObjectParent === null)\n        {\n            this.tempDisplayObjectParent = new DisplayObject();\n        }\n\n        return this.tempDisplayObjectParent;\n    }\n\n    /**\n     * Updates the object transform for rendering\n     *\n     * TODO - Optimization pass!\n     */\n    updateTransform()\n    {\n        this.transform.updateTransform(this.parent.transform);\n        // multiply the alphas..\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        this._bounds.updateID++;\n    }\n\n    /**\n     * recursively updates transform of all objects from the root to this one\n     * internal function for toLocal()\n     */\n    _recursivePostUpdateTransform()\n    {\n        if (this.parent)\n        {\n            this.parent._recursivePostUpdateTransform();\n            this.transform.updateTransform(this.parent.transform);\n        }\n        else\n        {\n            this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n        }\n    }\n\n    /**\n     * Retrieves the bounds of the displayObject as a rectangle object.\n     *\n     * @param {boolean} skipUpdate - setting to true will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost\n     * @param {PIXI.Rectangle} rect - Optional rectangle to store the result of the bounds calculation\n     * @return {PIXI.Rectangle} the rectangular bounding area\n     */\n    getBounds(skipUpdate, rect)\n    {\n        if (!skipUpdate)\n        {\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.updateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this._recursivePostUpdateTransform();\n                this.updateTransform();\n            }\n        }\n\n        if (this._boundsID !== this._lastBoundsID)\n        {\n            this.calculateBounds();\n        }\n\n        if (!rect)\n        {\n            if (!this._boundsRect)\n            {\n                this._boundsRect = new Rectangle();\n            }\n\n            rect = this._boundsRect;\n        }\n\n        return this._bounds.getRectangle(rect);\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object\n     *\n     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation\n     * @return {PIXI.Rectangle} the rectangular bounding area\n     */\n    getLocalBounds(rect)\n    {\n        const transformRef = this.transform;\n        const parentRef = this.parent;\n\n        this.parent = null;\n        this.transform = this._tempDisplayObjectParent.transform;\n\n        if (!rect)\n        {\n            if (!this._localBoundsRect)\n            {\n                this._localBoundsRect = new Rectangle();\n            }\n\n            rect = this._localBoundsRect;\n        }\n\n        const bounds = this.getBounds(false, rect);\n\n        this.parent = parentRef;\n        this.transform = transformRef;\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the global position of the display object\n     *\n     * @param {PIXI.Point} position - The world origin to calculate from\n     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point)\n     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.\n     * @return {PIXI.Point} A point object representing the position of this object\n     */\n    toGlobal(position, point, skipUpdate = false)\n    {\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // don't need to update the lot\n        return this.worldTransform.apply(position, point);\n    }\n\n    /**\n     * Calculates the local position of the display object relative to another point\n     *\n     * @param {PIXI.Point} position - The world origin to calculate from\n     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from\n     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point)\n     * @param {boolean} [skipUpdate=false] - Should we skip the update transform\n     * @return {PIXI.Point} A point object representing the position of this object\n     */\n    toLocal(position, from, point, skipUpdate)\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse(position, point);\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderWebGL(renderer) // eslint-disable-line no-unused-vars\n    {\n        // OVERWRITE;\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    renderCanvas(renderer) // eslint-disable-line no-unused-vars\n    {\n        // OVERWRITE;\n    }\n\n    /**\n     * Set the parent Container of this DisplayObject\n     *\n     * @param {PIXI.Container} container - The Container to add this DisplayObject to\n     * @return {PIXI.Container} The Container that this DisplayObject was added to\n     */\n    setParent(container)\n    {\n        if (!container || !container.addChild)\n        {\n            throw new Error('setParent: Argument must be a Container');\n        }\n\n        container.addChild(this);\n\n        return container;\n    }\n\n    /**\n     * Convenience function to set the position, scale, skew and pivot at once.\n     *\n     * @param {number} [x=0] - The X position\n     * @param {number} [y=0] - The Y position\n     * @param {number} [scaleX=1] - The X scale value\n     * @param {number} [scaleY=1] - The Y scale value\n     * @param {number} [rotation=0] - The rotation\n     * @param {number} [skewX=0] - The X skew value\n     * @param {number} [skewY=0] - The Y skew value\n     * @param {number} [pivotX=0] - The X pivot value\n     * @param {number} [pivotY=0] - The Y pivot value\n     * @return {PIXI.DisplayObject} The DisplayObject instance\n     */\n    setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0)\n    {\n        this.position.x = x;\n        this.position.y = y;\n        this.scale.x = !scaleX ? 1 : scaleX;\n        this.scale.y = !scaleY ? 1 : scaleY;\n        this.rotation = rotation;\n        this.skew.x = skewX;\n        this.skew.y = skewY;\n        this.pivot.x = pivotX;\n        this.pivot.y = pivotY;\n\n        return this;\n    }\n\n    /**\n     * Base destroy method for generic display objects. This will automatically\n     * remove the display object from its parent Container as well as remove\n     * all current event listeners and internal references. Do not use a DisplayObject\n     * after calling `destroy`.\n     *\n     */\n    destroy()\n    {\n        this.removeAllListeners();\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n        this.transform = null;\n\n        this.parent = null;\n\n        this._bounds = null;\n        this._currentBounds = null;\n        this._mask = null;\n\n        this.filterArea = null;\n\n        this.interactive = false;\n        this.interactiveChildren = false;\n\n        this._destroyed = true;\n    }\n\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     *\n     * @member {number}\n     */\n    get x()\n    {\n        return this.position.x;\n    }\n\n    set x(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.position.x = value;\n    }\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     *\n     * @member {number}\n     */\n    get y()\n    {\n        return this.position.y;\n    }\n\n    set y(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.position.y = value;\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n    get worldTransform()\n    {\n        return this.transform.worldTransform;\n    }\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n    get localTransform()\n    {\n        return this.transform.localTransform;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n    get position()\n    {\n        return this.transform.position;\n    }\n\n    set position(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.position.copy(value);\n    }\n\n    /**\n     * The scale factor of the object.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n    get scale()\n    {\n        return this.transform.scale;\n    }\n\n    set scale(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.scale.copy(value);\n    }\n\n    /**\n     * The pivot point of the displayObject that it rotates around.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n    get pivot()\n    {\n        return this.transform.pivot;\n    }\n\n    set pivot(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.pivot.copy(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get skew()\n    {\n        return this.transform.skew;\n    }\n\n    set skew(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.skew.copy(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * @member {number}\n     */\n    get rotation()\n    {\n        return this.transform.rotation;\n    }\n\n    set rotation(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.rotation = value;\n    }\n\n    /**\n     * Indicates if the object is globally visible.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    get worldVisible()\n    {\n        let item = this;\n\n        do\n        {\n            if (!item.visible)\n            {\n                return false;\n            }\n\n            item = item.parent;\n        } while (item);\n\n        return true;\n    }\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PIXI a regular mask must be a\n     * PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it\n     * utilises shape clipping. To remove a mask, set this property to null.\n     *\n     * @todo For the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n     *\n     * @member {PIXI.Graphics|PIXI.Sprite}\n     */\n    get mask()\n    {\n        return this._mask;\n    }\n\n    set mask(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._mask)\n        {\n            this._mask.renderable = true;\n            this._mask.isMask = false;\n        }\n\n        this._mask = value;\n\n        if (this._mask)\n        {\n            this._mask.renderable = false;\n            this._mask.isMask = true;\n        }\n    }\n\n    /**\n     * Sets the filters for the displayObject.\n     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to 'null'\n     *\n     * @member {PIXI.Filter[]}\n     */\n    get filters()\n    {\n        return this._filters && this._filters.slice();\n    }\n\n    set filters(value) // eslint-disable-line require-jsdoc\n    {\n        this._filters = value && value.slice();\n    }\n}\n\n// performance increase to avoid using call.. (10x faster)\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}