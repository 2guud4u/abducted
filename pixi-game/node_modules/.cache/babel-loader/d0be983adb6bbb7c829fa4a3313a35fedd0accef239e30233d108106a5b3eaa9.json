{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _WebGLManager2 = require('./WebGLManager');\nvar _WebGLManager3 = _interopRequireDefault(_WebGLManager2);\nvar _RenderTarget = require('../utils/RenderTarget');\nvar _RenderTarget2 = _interopRequireDefault(_RenderTarget);\nvar _Quad = require('../utils/Quad');\nvar _Quad2 = _interopRequireDefault(_Quad);\nvar _math = require('../../../math');\nvar _Shader = require('../../../Shader');\nvar _Shader2 = _interopRequireDefault(_Shader);\nvar _filterTransforms = require('../filters/filterTransforms');\nvar filterTransforms = _interopRequireWildcard(_filterTransforms);\nvar _bitTwiddle = require('bit-twiddle');\nvar _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * @ignore\n * @class\n */\nvar FilterState = function () {\n  /**\n   *\n   */\n  function FilterState() {\n    _classCallCheck(this, FilterState);\n    this.renderTarget = null;\n    this.target = null;\n    this.resolution = 1;\n\n    // those three objects are used only for root\n    // re-assigned for everything else\n    this.sourceFrame = new _math.Rectangle();\n    this.destinationFrame = new _math.Rectangle();\n    this.filters = [];\n  }\n\n  /**\n   * clears the state\n   */\n\n  FilterState.prototype.clear = function clear() {\n    this.filters = null;\n    this.target = null;\n    this.renderTarget = null;\n  };\n  return FilterState;\n}();\nvar screenKey = 'screen';\n\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.WebGLManager\n */\n\nvar FilterManager = function (_WebGLManager) {\n  _inherits(FilterManager, _WebGLManager);\n\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.\n   */\n  function FilterManager(renderer) {\n    _classCallCheck(this, FilterManager);\n    var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));\n    _this.gl = _this.renderer.gl;\n    // know about sprites!\n    _this.quad = new _Quad2.default(_this.gl, renderer.state.attribState);\n    _this.shaderCache = {};\n    // todo add default!\n    _this.pool = {};\n    _this.filterData = null;\n    _this.managedFilters = [];\n    _this.renderer.on('prerender', _this.onPrerender, _this);\n    _this._screenWidth = renderer.view.width;\n    _this._screenHeight = renderer.view.height;\n    return _this;\n  }\n\n  /**\n   * Adds a new filter to the manager.\n   *\n   * @param {PIXI.DisplayObject} target - The target of the filter to render.\n   * @param {PIXI.Filter[]} filters - The filters to apply.\n   */\n\n  FilterManager.prototype.pushFilter = function pushFilter(target, filters) {\n    var renderer = this.renderer;\n    var filterData = this.filterData;\n    if (!filterData) {\n      filterData = this.renderer._activeRenderTarget.filterStack;\n\n      // add new stack\n      var filterState = new FilterState();\n      filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;\n      filterState.renderTarget = renderer._activeRenderTarget;\n      this.renderer._activeRenderTarget.filterData = filterData = {\n        index: 0,\n        stack: [filterState]\n      };\n      this.filterData = filterData;\n    }\n\n    // get the current filter state..\n    var currentState = filterData.stack[++filterData.index];\n    var renderTargetFrame = filterData.stack[0].destinationFrame;\n    if (!currentState) {\n      currentState = filterData.stack[filterData.index] = new FilterState();\n    }\n    var fullScreen = target.filterArea && target.filterArea.x === 0 && target.filterArea.y === 0 && target.filterArea.width === renderer.screen.width && target.filterArea.height === renderer.screen.height;\n\n    // for now we go off the filter of the first resolution..\n    var resolution = filters[0].resolution;\n    var padding = filters[0].padding | 0;\n    var targetBounds = fullScreen ? renderer.screen : target.filterArea || target.getBounds(true);\n    var sourceFrame = currentState.sourceFrame;\n    var destinationFrame = currentState.destinationFrame;\n    sourceFrame.x = (targetBounds.x * resolution | 0) / resolution;\n    sourceFrame.y = (targetBounds.y * resolution | 0) / resolution;\n    sourceFrame.width = (targetBounds.width * resolution | 0) / resolution;\n    sourceFrame.height = (targetBounds.height * resolution | 0) / resolution;\n    if (!fullScreen) {\n      if (filterData.stack[0].renderTarget.transform) {//\n\n        // TODO we should fit the rect around the transform..\n      } else if (filters[0].autoFit) {\n        sourceFrame.fit(renderTargetFrame);\n      }\n\n      // lets apply the padding After we fit the element to the screen.\n      // this should stop the strange side effects that can occur when cropping to the edges\n      sourceFrame.pad(padding);\n    }\n    destinationFrame.width = sourceFrame.width;\n    destinationFrame.height = sourceFrame.height;\n\n    // lets play the padding after we fit the element to the screen.\n    // this should stop the strange side effects that can occur when cropping to the edges\n\n    var renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);\n    currentState.target = target;\n    currentState.filters = filters;\n    currentState.resolution = resolution;\n    currentState.renderTarget = renderTarget;\n\n    // bind the render target to draw the shape in the top corner..\n\n    renderTarget.setFrame(destinationFrame, sourceFrame);\n\n    // bind the render target\n    renderer.bindRenderTarget(renderTarget);\n    renderTarget.clear();\n  };\n\n  /**\n   * Pops off the filter and applies it.\n   *\n   */\n\n  FilterManager.prototype.popFilter = function popFilter() {\n    var filterData = this.filterData;\n    var lastState = filterData.stack[filterData.index - 1];\n    var currentState = filterData.stack[filterData.index];\n    this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();\n    var filters = currentState.filters;\n    if (filters.length === 1) {\n      filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);\n      this.freePotRenderTarget(currentState.renderTarget);\n    } else {\n      var flip = currentState.renderTarget;\n      var flop = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, currentState.resolution);\n      flop.setFrame(currentState.destinationFrame, currentState.sourceFrame);\n\n      // finally lets clear the render target before drawing to it..\n      flop.clear();\n      var i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        filters[i].apply(this, flip, flop, true, currentState);\n        var t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, lastState.renderTarget, false, currentState);\n      this.freePotRenderTarget(flip);\n      this.freePotRenderTarget(flop);\n    }\n    currentState.clear();\n    filterData.index--;\n    if (filterData.index === 0) {\n      this.filterData = null;\n    }\n  };\n\n  /**\n   * Draws a filter.\n   *\n   * @param {PIXI.Filter} filter - The filter to draw.\n   * @param {PIXI.RenderTarget} input - The input render target.\n   * @param {PIXI.RenderTarget} output - The target to output to.\n   * @param {boolean} clear - Should the output be cleared before rendering to it\n   */\n\n  FilterManager.prototype.applyFilter = function applyFilter(filter, input, output, clear) {\n    var renderer = this.renderer;\n    var gl = renderer.gl;\n    var shader = filter.glShaders[renderer.CONTEXT_UID];\n\n    // caching..\n    if (!shader) {\n      if (filter.glShaderKey) {\n        shader = this.shaderCache[filter.glShaderKey];\n        if (!shader) {\n          shader = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);\n          filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader;\n          this.managedFilters.push(filter);\n        }\n      } else {\n        shader = filter.glShaders[renderer.CONTEXT_UID] = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);\n        this.managedFilters.push(filter);\n      }\n\n      // TODO - this only needs to be done once?\n      renderer.bindVao(null);\n      this.quad.initVao(shader);\n    }\n    renderer.bindVao(this.quad.vao);\n    renderer.bindRenderTarget(output);\n    if (clear) {\n      gl.disable(gl.SCISSOR_TEST);\n      renderer.clear(); // [1, 1, 1, 1]);\n      gl.enable(gl.SCISSOR_TEST);\n    }\n\n    // in case the render target is being masked using a scissor rect\n    if (output === renderer.maskManager.scissorRenderTarget) {\n      renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData);\n    }\n    renderer.bindShader(shader);\n\n    // free unit 0 for us, doesn't matter what was there\n    // don't try to restore it, because syncUniforms can upload it to another slot\n    // and it'll be a problem\n    var tex = this.renderer.emptyTextures[0];\n    this.renderer.boundTextures[0] = tex;\n    // this syncs the PixiJS filters  uniforms with glsl uniforms\n    this.syncUniforms(shader, filter);\n    renderer.state.setBlendMode(filter.blendMode);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);\n    this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n  };\n\n  /**\n   * Uploads the uniforms of the filter.\n   *\n   * @param {GLShader} shader - The underlying gl shader.\n   * @param {PIXI.Filter} filter - The filter we are synchronizing.\n   */\n\n  FilterManager.prototype.syncUniforms = function syncUniforms(shader, filter) {\n    var uniformData = filter.uniformData;\n    var uniforms = filter.uniforms;\n\n    // 0 is reserved for the PixiJS texture so we start at 1!\n    var textureCount = 1;\n    var currentState = void 0;\n\n    // filterArea and filterClamp that are handled by FilterManager directly\n    // they must not appear in uniformData\n\n    if (shader.uniforms.filterArea) {\n      currentState = this.filterData.stack[this.filterData.index];\n      var filterArea = shader.uniforms.filterArea;\n      filterArea[0] = currentState.renderTarget.size.width;\n      filterArea[1] = currentState.renderTarget.size.height;\n      filterArea[2] = currentState.sourceFrame.x;\n      filterArea[3] = currentState.sourceFrame.y;\n      shader.uniforms.filterArea = filterArea;\n    }\n\n    // use this to clamp displaced texture coords so they belong to filterArea\n    // see displacementFilter fragment shader for an example\n    if (shader.uniforms.filterClamp) {\n      currentState = currentState || this.filterData.stack[this.filterData.index];\n      var filterClamp = shader.uniforms.filterClamp;\n      filterClamp[0] = 0;\n      filterClamp[1] = 0;\n      filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;\n      filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;\n      shader.uniforms.filterClamp = filterClamp;\n    }\n\n    // TODO Caching layer..\n    for (var i in uniformData) {\n      if (!shader.uniforms.data[i]) {\n        continue;\n      }\n      var type = uniformData[i].type;\n      if (type === 'sampler2d' && uniforms[i] !== 0) {\n        if (uniforms[i].baseTexture) {\n          shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);\n        } else {\n          shader.uniforms[i] = textureCount;\n\n          // TODO\n          // this is helpful as renderTargets can also be set.\n          // Although thinking about it, we could probably\n          // make the filter texture cache return a RenderTexture\n          // rather than a renderTarget\n          var gl = this.renderer.gl;\n          this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];\n          gl.activeTexture(gl.TEXTURE0 + textureCount);\n          uniforms[i].texture.bind();\n        }\n        textureCount++;\n      } else if (type === 'mat3') {\n        // check if its PixiJS matrix..\n        if (uniforms[i].a !== undefined) {\n          shader.uniforms[i] = uniforms[i].toArray(true);\n        } else {\n          shader.uniforms[i] = uniforms[i];\n        }\n      } else if (type === 'vec2') {\n        // check if its a point..\n        if (uniforms[i].x !== undefined) {\n          var val = shader.uniforms[i] || new Float32Array(2);\n          val[0] = uniforms[i].x;\n          val[1] = uniforms[i].y;\n          shader.uniforms[i] = val;\n        } else {\n          shader.uniforms[i] = uniforms[i];\n        }\n      } else if (type === 'float') {\n        if (shader.uniforms.data[i].value !== uniformData[i]) {\n          shader.uniforms[i] = uniforms[i];\n        }\n      } else {\n        shader.uniforms[i] = uniforms[i];\n      }\n    }\n  };\n\n  /**\n   * Gets a render target from the pool, or creates a new one.\n   *\n   * @param {boolean} clear - Should we clear the render texture when we get it?\n   * @param {number} resolution - The resolution of the target.\n   * @return {PIXI.RenderTarget} The new render target\n   */\n\n  FilterManager.prototype.getRenderTarget = function getRenderTarget(clear, resolution) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    var renderTarget = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, resolution || currentState.resolution);\n    renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame);\n    return renderTarget;\n  };\n\n  /**\n   * Returns a render target to the pool.\n   *\n   * @param {PIXI.RenderTarget} renderTarget - The render target to return.\n   */\n\n  FilterManager.prototype.returnRenderTarget = function returnRenderTarget(renderTarget) {\n    this.freePotRenderTarget(renderTarget);\n  };\n\n  /**\n   * Calculates the mapped matrix.\n   *\n   * TODO playing around here.. this is temporary - (will end up in the shader)\n   * this returns a matrix that will normalise map filter cords in the filter to screen space\n   *\n   * @param {PIXI.Matrix} outputMatrix - the matrix to output to.\n   * @return {PIXI.Matrix} The mapped matrix.\n   */\n\n  FilterManager.prototype.calculateScreenSpaceMatrix = function calculateScreenSpaceMatrix(outputMatrix) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    return filterTransforms.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size);\n  };\n\n  /**\n   * Multiply vTextureCoord to this matrix to achieve (0,0,1,1) for filterArea\n   *\n   * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n   * @return {PIXI.Matrix} The mapped matrix.\n   */\n\n  FilterManager.prototype.calculateNormalizedScreenSpaceMatrix = function calculateNormalizedScreenSpaceMatrix(outputMatrix) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    return filterTransforms.calculateNormalizedScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, currentState.destinationFrame);\n  };\n\n  /**\n   * This will map the filter coord so that a texture can be used based on the transform of a sprite\n   *\n   * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n   * @param {PIXI.Sprite} sprite - The sprite to map to.\n   * @return {PIXI.Matrix} The mapped matrix.\n   */\n\n  FilterManager.prototype.calculateSpriteMatrix = function calculateSpriteMatrix(outputMatrix, sprite) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    return filterTransforms.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, sprite);\n  };\n\n  /**\n   * Destroys this Filter Manager.\n   *\n   * @param {boolean} [contextLost=false] context was lost, do not free shaders\n   *\n   */\n\n  FilterManager.prototype.destroy = function destroy() {\n    var contextLost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var renderer = this.renderer;\n    var filters = this.managedFilters;\n    renderer.off('prerender', this.onPrerender, this);\n    for (var i = 0; i < filters.length; i++) {\n      if (!contextLost) {\n        filters[i].glShaders[renderer.CONTEXT_UID].destroy();\n      }\n      delete filters[i].glShaders[renderer.CONTEXT_UID];\n    }\n    this.shaderCache = {};\n    if (!contextLost) {\n      this.emptyPool();\n    } else {\n      this.pool = {};\n    }\n  };\n\n  /**\n   * Gets a Power-of-Two render texture.\n   *\n   * TODO move to a separate class could be on renderer?\n   * also - could cause issue with multiple contexts?\n   *\n   * @private\n   * @param {WebGLRenderingContext} gl - The webgl rendering context\n   * @param {number} minWidth - The minimum width of the render target.\n   * @param {number} minHeight - The minimum height of the render target.\n   * @param {number} resolution - The resolution of the render target.\n   * @return {PIXI.RenderTarget} The new render target.\n   */\n\n  FilterManager.prototype.getPotRenderTarget = function getPotRenderTarget(gl, minWidth, minHeight, resolution) {\n    var key = screenKey;\n    minWidth *= resolution;\n    minHeight *= resolution;\n    if (minWidth !== this._screenWidth || minHeight !== this._screenHeight) {\n      // TODO you could return a bigger texture if there is not one in the pool?\n      minWidth = _bitTwiddle2.default.nextPow2(minWidth);\n      minHeight = _bitTwiddle2.default.nextPow2(minHeight);\n      key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;\n    }\n    if (!this.pool[key]) {\n      this.pool[key] = [];\n    }\n    var renderTarget = this.pool[key].pop();\n\n    // creating render target will cause texture to be bound!\n    if (!renderTarget) {\n      // temporary bypass cache..\n      var tex = this.renderer.boundTextures[0];\n      gl.activeTexture(gl.TEXTURE0);\n\n      // internally - this will cause a texture to be bound..\n      renderTarget = new _RenderTarget2.default(gl, minWidth, minHeight, null, 1);\n\n      // set the current one back\n      gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n    }\n\n    // manually tweak the resolution...\n    // this will not modify the size of the frame buffer, just its resolution.\n    renderTarget.resolution = resolution;\n    renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;\n    renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;\n    renderTarget.filterPoolKey = key;\n    return renderTarget;\n  };\n\n  /**\n   * Empties the texture pool.\n   *\n   */\n\n  FilterManager.prototype.emptyPool = function emptyPool() {\n    for (var i in this.pool) {\n      var textures = this.pool[i];\n      if (textures) {\n        for (var j = 0; j < textures.length; j++) {\n          textures[j].destroy(true);\n        }\n      }\n    }\n    this.pool = {};\n  };\n\n  /**\n   * Frees a render target back into the pool.\n   *\n   * @param {PIXI.RenderTarget} renderTarget - The renderTarget to free\n   */\n\n  FilterManager.prototype.freePotRenderTarget = function freePotRenderTarget(renderTarget) {\n    this.pool[renderTarget.filterPoolKey].push(renderTarget);\n  };\n\n  /**\n   * Called before the renderer starts rendering.\n   *\n   */\n\n  FilterManager.prototype.onPrerender = function onPrerender() {\n    if (this._screenWidth !== this.renderer.view.width || this._screenHeight !== this.renderer.view.height) {\n      this._screenWidth = this.renderer.view.width;\n      this._screenHeight = this.renderer.view.height;\n      var textures = this.pool[screenKey];\n      if (textures) {\n        for (var j = 0; j < textures.length; j++) {\n          textures[j].destroy(true);\n        }\n      }\n      this.pool[screenKey] = [];\n    }\n  };\n  return FilterManager;\n}(_WebGLManager3.default);\nexports.default = FilterManager;","map":{"version":3,"names":["_WebGLManager2","require","_RenderTarget","_Quad","_math","_Shader","_filterTransforms","filterTransforms","_bitTwiddle","FilterState","_classCallCheck","renderTarget","target","resolution","sourceFrame","Rectangle","destinationFrame","filters","clear","screenKey","FilterManager","renderer","_this","_possibleConstructorReturn","_WebGLManager","call","gl","quad","_Quad2","default","state","attribState","shaderCache","pool","filterData","managedFilters","on","onPrerender","_screenWidth","view","width","_screenHeight","height","pushFilter","_activeRenderTarget","filterStack","filterState","size","index","stack","currentState","renderTargetFrame","fullScreen","filterArea","x","y","screen","padding","targetBounds","getBounds","transform","autoFit","fit","pad","getPotRenderTarget","setFrame","bindRenderTarget","popFilter","lastState","map","upload","length","apply","freePotRenderTarget","flip","flop","i","t","applyFilter","filter","input","output","shader","glShaders","CONTEXT_UID","glShaderKey","_Shader2","vertexSrc","fragmentSrc","push","bindVao","initVao","vao","disable","SCISSOR_TEST","enable","maskManager","scissorRenderTarget","pushScissorMask","scissorData","bindShader","tex","emptyTextures","boundTextures","syncUniforms","setBlendMode","blendMode","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","texture","draw","TRIANGLES","_glTextures","uniformData","uniforms","textureCount","filterClamp","data","type","baseTexture","bind","a","undefined","toArray","val","Float32Array","value","getRenderTarget","returnRenderTarget","calculateScreenSpaceMatrix","outputMatrix","calculateNormalizedScreenSpaceMatrix","calculateSpriteMatrix","sprite","destroy","contextLost","arguments","off","emptyPool","minWidth","minHeight","key","_bitTwiddle2","nextPow2","pop","_RenderTarget2","defaultFrame","filterPoolKey","textures","j"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/renderers/webgl/managers/FilterManager.js"],"sourcesContent":["import WebGLManager from './WebGLManager';\nimport RenderTarget from '../utils/RenderTarget';\nimport Quad from '../utils/Quad';\nimport { Rectangle } from '../../../math';\nimport Shader from '../../../Shader';\nimport * as filterTransforms from '../filters/filterTransforms';\nimport bitTwiddle from 'bit-twiddle';\n\n/**\n * @ignore\n * @class\n */\nclass FilterState\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        this.renderTarget = null;\n        this.target = null;\n        this.resolution = 1;\n\n        // those three objects are used only for root\n        // re-assigned for everything else\n        this.sourceFrame = new Rectangle();\n        this.destinationFrame = new Rectangle();\n        this.filters = [];\n    }\n\n    /**\n     * clears the state\n     */\n    clear()\n    {\n        this.filters = null;\n        this.target = null;\n        this.renderTarget = null;\n    }\n}\n\nconst screenKey = 'screen';\n\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.WebGLManager\n */\nexport default class FilterManager extends WebGLManager\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.gl = this.renderer.gl;\n        // know about sprites!\n        this.quad = new Quad(this.gl, renderer.state.attribState);\n\n        this.shaderCache = {};\n        // todo add default!\n        this.pool = {};\n\n        this.filterData = null;\n\n        this.managedFilters = [];\n\n        this.renderer.on('prerender', this.onPrerender, this);\n\n        this._screenWidth = renderer.view.width;\n        this._screenHeight = renderer.view.height;\n    }\n\n    /**\n     * Adds a new filter to the manager.\n     *\n     * @param {PIXI.DisplayObject} target - The target of the filter to render.\n     * @param {PIXI.Filter[]} filters - The filters to apply.\n     */\n    pushFilter(target, filters)\n    {\n        const renderer = this.renderer;\n\n        let filterData = this.filterData;\n\n        if (!filterData)\n        {\n            filterData = this.renderer._activeRenderTarget.filterStack;\n\n            // add new stack\n            const filterState = new FilterState();\n\n            filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;\n            filterState.renderTarget = renderer._activeRenderTarget;\n\n            this.renderer._activeRenderTarget.filterData = filterData = {\n                index: 0,\n                stack: [filterState],\n            };\n\n            this.filterData = filterData;\n        }\n\n        // get the current filter state..\n        let currentState = filterData.stack[++filterData.index];\n        const renderTargetFrame = filterData.stack[0].destinationFrame;\n\n        if (!currentState)\n        {\n            currentState = filterData.stack[filterData.index] = new FilterState();\n        }\n\n        const fullScreen = target.filterArea\n            && target.filterArea.x === 0\n            && target.filterArea.y === 0\n            && target.filterArea.width === renderer.screen.width\n            && target.filterArea.height === renderer.screen.height;\n\n        // for now we go off the filter of the first resolution..\n        const resolution = filters[0].resolution;\n        const padding = filters[0].padding | 0;\n        const targetBounds = fullScreen ? renderer.screen : (target.filterArea || target.getBounds(true));\n        const sourceFrame = currentState.sourceFrame;\n        const destinationFrame = currentState.destinationFrame;\n\n        sourceFrame.x = ((targetBounds.x * resolution) | 0) / resolution;\n        sourceFrame.y = ((targetBounds.y * resolution) | 0) / resolution;\n        sourceFrame.width = ((targetBounds.width * resolution) | 0) / resolution;\n        sourceFrame.height = ((targetBounds.height * resolution) | 0) / resolution;\n\n        if (!fullScreen)\n        {\n            if (filterData.stack[0].renderTarget.transform)\n            { //\n\n                // TODO we should fit the rect around the transform..\n            }\n            else if (filters[0].autoFit)\n            {\n                sourceFrame.fit(renderTargetFrame);\n            }\n\n            // lets apply the padding After we fit the element to the screen.\n            // this should stop the strange side effects that can occur when cropping to the edges\n            sourceFrame.pad(padding);\n        }\n\n        destinationFrame.width = sourceFrame.width;\n        destinationFrame.height = sourceFrame.height;\n\n        // lets play the padding after we fit the element to the screen.\n        // this should stop the strange side effects that can occur when cropping to the edges\n\n        const renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);\n\n        currentState.target = target;\n        currentState.filters = filters;\n        currentState.resolution = resolution;\n        currentState.renderTarget = renderTarget;\n\n        // bind the render target to draw the shape in the top corner..\n\n        renderTarget.setFrame(destinationFrame, sourceFrame);\n\n        // bind the render target\n        renderer.bindRenderTarget(renderTarget);\n        renderTarget.clear();\n    }\n\n    /**\n     * Pops off the filter and applies it.\n     *\n     */\n    popFilter()\n    {\n        const filterData = this.filterData;\n\n        const lastState = filterData.stack[filterData.index - 1];\n        const currentState = filterData.stack[filterData.index];\n\n        this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();\n\n        const filters = currentState.filters;\n\n        if (filters.length === 1)\n        {\n            filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);\n            this.freePotRenderTarget(currentState.renderTarget);\n        }\n        else\n        {\n            let flip = currentState.renderTarget;\n            let flop = this.getPotRenderTarget(\n                this.renderer.gl,\n                currentState.sourceFrame.width,\n                currentState.sourceFrame.height,\n                currentState.resolution\n            );\n\n            flop.setFrame(currentState.destinationFrame, currentState.sourceFrame);\n\n            // finally lets clear the render target before drawing to it..\n            flop.clear();\n\n            let i = 0;\n\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                filters[i].apply(this, flip, flop, true, currentState);\n\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, lastState.renderTarget, false, currentState);\n\n            this.freePotRenderTarget(flip);\n            this.freePotRenderTarget(flop);\n        }\n\n        currentState.clear();\n        filterData.index--;\n\n        if (filterData.index === 0)\n        {\n            this.filterData = null;\n        }\n    }\n\n    /**\n     * Draws a filter.\n     *\n     * @param {PIXI.Filter} filter - The filter to draw.\n     * @param {PIXI.RenderTarget} input - The input render target.\n     * @param {PIXI.RenderTarget} output - The target to output to.\n     * @param {boolean} clear - Should the output be cleared before rendering to it\n     */\n    applyFilter(filter, input, output, clear)\n    {\n        const renderer = this.renderer;\n        const gl = renderer.gl;\n\n        let shader = filter.glShaders[renderer.CONTEXT_UID];\n\n        // caching..\n        if (!shader)\n        {\n            if (filter.glShaderKey)\n            {\n                shader = this.shaderCache[filter.glShaderKey];\n\n                if (!shader)\n                {\n                    shader = new Shader(this.gl, filter.vertexSrc, filter.fragmentSrc);\n\n                    filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader;\n                    this.managedFilters.push(filter);\n                }\n            }\n            else\n            {\n                shader = filter.glShaders[renderer.CONTEXT_UID] = new Shader(this.gl, filter.vertexSrc, filter.fragmentSrc);\n                this.managedFilters.push(filter);\n            }\n\n            // TODO - this only needs to be done once?\n            renderer.bindVao(null);\n\n            this.quad.initVao(shader);\n        }\n\n        renderer.bindVao(this.quad.vao);\n\n        renderer.bindRenderTarget(output);\n\n        if (clear)\n        {\n            gl.disable(gl.SCISSOR_TEST);\n            renderer.clear();// [1, 1, 1, 1]);\n            gl.enable(gl.SCISSOR_TEST);\n        }\n\n        // in case the render target is being masked using a scissor rect\n        if (output === renderer.maskManager.scissorRenderTarget)\n        {\n            renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData);\n        }\n\n        renderer.bindShader(shader);\n\n        // free unit 0 for us, doesn't matter what was there\n        // don't try to restore it, because syncUniforms can upload it to another slot\n        // and it'll be a problem\n        const tex = this.renderer.emptyTextures[0];\n\n        this.renderer.boundTextures[0] = tex;\n        // this syncs the PixiJS filters  uniforms with glsl uniforms\n        this.syncUniforms(shader, filter);\n\n        renderer.state.setBlendMode(filter.blendMode);\n\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);\n\n        this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n\n        gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n    }\n\n    /**\n     * Uploads the uniforms of the filter.\n     *\n     * @param {GLShader} shader - The underlying gl shader.\n     * @param {PIXI.Filter} filter - The filter we are synchronizing.\n     */\n    syncUniforms(shader, filter)\n    {\n        const uniformData = filter.uniformData;\n        const uniforms = filter.uniforms;\n\n        // 0 is reserved for the PixiJS texture so we start at 1!\n        let textureCount = 1;\n        let currentState;\n\n        // filterArea and filterClamp that are handled by FilterManager directly\n        // they must not appear in uniformData\n\n        if (shader.uniforms.filterArea)\n        {\n            currentState = this.filterData.stack[this.filterData.index];\n\n            const filterArea = shader.uniforms.filterArea;\n\n            filterArea[0] = currentState.renderTarget.size.width;\n            filterArea[1] = currentState.renderTarget.size.height;\n            filterArea[2] = currentState.sourceFrame.x;\n            filterArea[3] = currentState.sourceFrame.y;\n\n            shader.uniforms.filterArea = filterArea;\n        }\n\n        // use this to clamp displaced texture coords so they belong to filterArea\n        // see displacementFilter fragment shader for an example\n        if (shader.uniforms.filterClamp)\n        {\n            currentState = currentState || this.filterData.stack[this.filterData.index];\n\n            const filterClamp = shader.uniforms.filterClamp;\n\n            filterClamp[0] = 0;\n            filterClamp[1] = 0;\n            filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;\n            filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;\n\n            shader.uniforms.filterClamp = filterClamp;\n        }\n\n        // TODO Caching layer..\n        for (const i in uniformData)\n        {\n            if (!shader.uniforms.data[i])\n            {\n                continue;\n            }\n\n            const type = uniformData[i].type;\n\n            if (type === 'sampler2d' && uniforms[i] !== 0)\n            {\n                if (uniforms[i].baseTexture)\n                {\n                    shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);\n                }\n                else\n                {\n                    shader.uniforms[i] = textureCount;\n\n                    // TODO\n                    // this is helpful as renderTargets can also be set.\n                    // Although thinking about it, we could probably\n                    // make the filter texture cache return a RenderTexture\n                    // rather than a renderTarget\n                    const gl = this.renderer.gl;\n\n                    this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];\n                    gl.activeTexture(gl.TEXTURE0 + textureCount);\n\n                    uniforms[i].texture.bind();\n                }\n\n                textureCount++;\n            }\n            else if (type === 'mat3')\n            {\n                // check if its PixiJS matrix..\n                if (uniforms[i].a !== undefined)\n                {\n                    shader.uniforms[i] = uniforms[i].toArray(true);\n                }\n                else\n                {\n                    shader.uniforms[i] = uniforms[i];\n                }\n            }\n            else if (type === 'vec2')\n            {\n                // check if its a point..\n                if (uniforms[i].x !== undefined)\n               {\n                    const val = shader.uniforms[i] || new Float32Array(2);\n\n                    val[0] = uniforms[i].x;\n                    val[1] = uniforms[i].y;\n                    shader.uniforms[i] = val;\n                }\n                else\n               {\n                    shader.uniforms[i] = uniforms[i];\n                }\n            }\n            else if (type === 'float')\n            {\n                if (shader.uniforms.data[i].value !== uniformData[i])\n                {\n                    shader.uniforms[i] = uniforms[i];\n                }\n            }\n            else\n            {\n                shader.uniforms[i] = uniforms[i];\n            }\n        }\n    }\n\n    /**\n     * Gets a render target from the pool, or creates a new one.\n     *\n     * @param {boolean} clear - Should we clear the render texture when we get it?\n     * @param {number} resolution - The resolution of the target.\n     * @return {PIXI.RenderTarget} The new render target\n     */\n    getRenderTarget(clear, resolution)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n        const renderTarget = this.getPotRenderTarget(\n            this.renderer.gl,\n            currentState.sourceFrame.width,\n            currentState.sourceFrame.height,\n            resolution || currentState.resolution\n        );\n\n        renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame);\n\n        return renderTarget;\n    }\n\n    /**\n     * Returns a render target to the pool.\n     *\n     * @param {PIXI.RenderTarget} renderTarget - The render target to return.\n     */\n    returnRenderTarget(renderTarget)\n    {\n        this.freePotRenderTarget(renderTarget);\n    }\n\n    /**\n     * Calculates the mapped matrix.\n     *\n     * TODO playing around here.. this is temporary - (will end up in the shader)\n     * this returns a matrix that will normalise map filter cords in the filter to screen space\n     *\n     * @param {PIXI.Matrix} outputMatrix - the matrix to output to.\n     * @return {PIXI.Matrix} The mapped matrix.\n     */\n    calculateScreenSpaceMatrix(outputMatrix)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n\n        return filterTransforms.calculateScreenSpaceMatrix(\n            outputMatrix,\n            currentState.sourceFrame,\n            currentState.renderTarget.size\n        );\n    }\n\n    /**\n     * Multiply vTextureCoord to this matrix to achieve (0,0,1,1) for filterArea\n     *\n     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n     * @return {PIXI.Matrix} The mapped matrix.\n     */\n    calculateNormalizedScreenSpaceMatrix(outputMatrix)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n\n        return filterTransforms.calculateNormalizedScreenSpaceMatrix(\n            outputMatrix,\n            currentState.sourceFrame,\n            currentState.renderTarget.size,\n            currentState.destinationFrame\n        );\n    }\n\n    /**\n     * This will map the filter coord so that a texture can be used based on the transform of a sprite\n     *\n     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n     * @param {PIXI.Sprite} sprite - The sprite to map to.\n     * @return {PIXI.Matrix} The mapped matrix.\n     */\n    calculateSpriteMatrix(outputMatrix, sprite)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n\n        return filterTransforms.calculateSpriteMatrix(\n            outputMatrix,\n            currentState.sourceFrame,\n            currentState.renderTarget.size,\n            sprite\n        );\n    }\n\n    /**\n     * Destroys this Filter Manager.\n     *\n     * @param {boolean} [contextLost=false] context was lost, do not free shaders\n     *\n     */\n    destroy(contextLost = false)\n    {\n        const renderer = this.renderer;\n        const filters = this.managedFilters;\n\n        renderer.off('prerender', this.onPrerender, this);\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            if (!contextLost)\n            {\n                filters[i].glShaders[renderer.CONTEXT_UID].destroy();\n            }\n            delete filters[i].glShaders[renderer.CONTEXT_UID];\n        }\n\n        this.shaderCache = {};\n        if (!contextLost)\n        {\n            this.emptyPool();\n        }\n        else\n        {\n            this.pool = {};\n        }\n    }\n\n    /**\n     * Gets a Power-of-Two render texture.\n     *\n     * TODO move to a separate class could be on renderer?\n     * also - could cause issue with multiple contexts?\n     *\n     * @private\n     * @param {WebGLRenderingContext} gl - The webgl rendering context\n     * @param {number} minWidth - The minimum width of the render target.\n     * @param {number} minHeight - The minimum height of the render target.\n     * @param {number} resolution - The resolution of the render target.\n     * @return {PIXI.RenderTarget} The new render target.\n     */\n    getPotRenderTarget(gl, minWidth, minHeight, resolution)\n    {\n        let key = screenKey;\n\n        minWidth *= resolution;\n        minHeight *= resolution;\n\n        if (minWidth !== this._screenWidth\n            || minHeight !== this._screenHeight)\n        {\n            // TODO you could return a bigger texture if there is not one in the pool?\n            minWidth = bitTwiddle.nextPow2(minWidth);\n            minHeight = bitTwiddle.nextPow2(minHeight);\n            key = ((minWidth & 0xFFFF) << 16) | (minHeight & 0xFFFF);\n        }\n\n        if (!this.pool[key])\n        {\n            this.pool[key] = [];\n        }\n\n        let renderTarget = this.pool[key].pop();\n\n        // creating render target will cause texture to be bound!\n        if (!renderTarget)\n        {\n            // temporary bypass cache..\n            const tex = this.renderer.boundTextures[0];\n\n            gl.activeTexture(gl.TEXTURE0);\n\n            // internally - this will cause a texture to be bound..\n            renderTarget = new RenderTarget(gl, minWidth, minHeight, null, 1);\n\n            // set the current one back\n            gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n        }\n\n        // manually tweak the resolution...\n        // this will not modify the size of the frame buffer, just its resolution.\n        renderTarget.resolution = resolution;\n        renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;\n        renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;\n        renderTarget.filterPoolKey = key;\n\n        return renderTarget;\n    }\n\n    /**\n     * Empties the texture pool.\n     *\n     */\n    emptyPool()\n    {\n        for (const i in this.pool)\n        {\n            const textures = this.pool[i];\n\n            if (textures)\n            {\n                for (let j = 0; j < textures.length; j++)\n                {\n                    textures[j].destroy(true);\n                }\n            }\n        }\n\n        this.pool = {};\n    }\n\n    /**\n     * Frees a render target back into the pool.\n     *\n     * @param {PIXI.RenderTarget} renderTarget - The renderTarget to free\n     */\n    freePotRenderTarget(renderTarget)\n    {\n        this.pool[renderTarget.filterPoolKey].push(renderTarget);\n    }\n\n    /**\n     * Called before the renderer starts rendering.\n     *\n     */\n    onPrerender()\n    {\n        if (this._screenWidth !== this.renderer.view.width\n            || this._screenHeight !== this.renderer.view.height)\n        {\n            this._screenWidth = this.renderer.view.width;\n            this._screenHeight = this.renderer.view.height;\n\n            const textures = this.pool[screenKey];\n\n            if (textures)\n            {\n                for (let j = 0; j < textures.length; j++)\n                {\n                    textures[j].destroy(true);\n                }\n            }\n            this.pool[screenKey] = [];\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}