{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _Point = require('../Point');\nvar _Point2 = _interopRequireDefault(_Point);\nvar _const = require('../../const');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * @class\n * @memberof PIXI\n */\nvar Polygon = function () {\n  /**\n   * @param {PIXI.Point[]|number[]} points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  function Polygon() {\n    for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {\n      points[_key] = arguments[_key];\n    }\n    _classCallCheck(this, Polygon);\n    if (Array.isArray(points[0])) {\n      points = points[0];\n    }\n\n    // if this is an array of points, convert it to a flat array of numbers\n    if (points[0] instanceof _Point2.default) {\n      var p = [];\n      for (var i = 0, il = points.length; i < il; i++) {\n        p.push(points[i].x, points[i].y);\n      }\n      points = p;\n    }\n    this.closed = true;\n\n    /**\n     * An array of the points of this polygon\n     *\n     * @member {number[]}\n     */\n    this.points = points;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     *\n     * @member {number}\n     * @readOnly\n     * @default PIXI.SHAPES.POLY\n     * @see PIXI.SHAPES\n     */\n    this.type = _const.SHAPES.POLY;\n  }\n\n  /**\n   * Creates a clone of this polygon\n   *\n   * @return {PIXI.Polygon} a copy of the polygon\n   */\n\n  Polygon.prototype.clone = function clone() {\n    return new Polygon(this.points.slice());\n  };\n\n  /**\n   * Closes the polygon, adding points if necessary.\n   *\n   */\n\n  Polygon.prototype.close = function close() {\n    var points = this.points;\n\n    // close the poly if the value is true!\n    if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1]) {\n      points.push(points[0], points[1]);\n    }\n  };\n\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon\n   *\n   * @param {number} x - The X coordinate of the point to test\n   * @param {number} y - The Y coordinate of the point to test\n   * @return {boolean} Whether the x/y coordinates are within this polygon\n   */\n\n  Polygon.prototype.contains = function contains(x, y) {\n    var inside = false;\n\n    // use some raycasting to test hits\n    // https://github.com/substack/point-in-polygon/blob/master/index.js\n    var length = this.points.length / 2;\n    for (var i = 0, j = length - 1; i < length; j = i++) {\n      var xi = this.points[i * 2];\n      var yi = this.points[i * 2 + 1];\n      var xj = this.points[j * 2];\n      var yj = this.points[j * 2 + 1];\n      var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  };\n  return Polygon;\n}();\nexports.default = Polygon;","map":{"version":3,"names":["_Point","require","_const","Polygon","_len","arguments","length","points","Array","_key","_classCallCheck","isArray","_Point2","default","p","i","il","push","x","y","closed","type","SHAPES","POLY","clone","slice","close","contains","inside","j","xi","yi","xj","yj","intersect"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/math/shapes/Polygon.js"],"sourcesContent":["import Point from '../Point';\nimport { SHAPES } from '../../const';\n\n/**\n * @class\n * @memberof PIXI\n */\nexport default class Polygon\n{\n    /**\n     * @param {PIXI.Point[]|number[]} points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points)\n    {\n        if (Array.isArray(points[0]))\n        {\n            points = points[0];\n        }\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (points[0] instanceof Point)\n        {\n            const p = [];\n\n            for (let i = 0, il = points.length; i < il; i++)\n            {\n                p.push(points[i].x, points[i].y);\n            }\n\n            points = p;\n        }\n\n        this.closed = true;\n\n        /**\n         * An array of the points of this polygon\n         *\n         * @member {number[]}\n         */\n        this.points = points;\n\n        /**\n         * The type of the object, mainly used to avoid `instanceof` checks\n         *\n         * @member {number}\n         * @readOnly\n         * @default PIXI.SHAPES.POLY\n         * @see PIXI.SHAPES\n         */\n        this.type = SHAPES.POLY;\n    }\n\n    /**\n     * Creates a clone of this polygon\n     *\n     * @return {PIXI.Polygon} a copy of the polygon\n     */\n    clone()\n    {\n        return new Polygon(this.points.slice());\n    }\n\n    /**\n     * Closes the polygon, adding points if necessary.\n     *\n     */\n    close()\n    {\n        const points = this.points;\n\n        // close the poly if the value is true!\n        if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1])\n        {\n            points.push(points[0], points[1]);\n        }\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon\n     *\n     * @param {number} x - The X coordinate of the point to test\n     * @param {number} y - The Y coordinate of the point to test\n     * @return {boolean} Whether the x/y coordinates are within this polygon\n     */\n    contains(x, y)\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}