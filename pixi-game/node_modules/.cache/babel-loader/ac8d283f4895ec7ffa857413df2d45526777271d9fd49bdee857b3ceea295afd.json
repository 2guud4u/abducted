{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _utils = require('../utils');\nvar _DisplayObject2 = require('./DisplayObject');\nvar _DisplayObject3 = _interopRequireDefault(_DisplayObject2);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * A Container represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n *```js\n * let container = new PIXI.Container();\n * container.addChild(sprite);\n * ```\n *\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI\n */\nvar Container = function (_DisplayObject) {\n  _inherits(Container, _DisplayObject);\n\n  /**\n   *\n   */\n  function Container() {\n    _classCallCheck(this, Container);\n\n    /**\n     * The array of children of this container.\n     *\n     * @member {PIXI.DisplayObject[]}\n     * @readonly\n     */\n    var _this = _possibleConstructorReturn(this, _DisplayObject.call(this));\n    _this.children = [];\n    return _this;\n  }\n\n  /**\n   * Overridable method that can be used by Container subclasses whenever the children array is modified\n   *\n   * @private\n   */\n\n  Container.prototype.onChildrenChange = function onChildrenChange() {}\n  /* empty */\n\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   *\n   * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container\n   * @return {PIXI.DisplayObject} The first child that was added.\n   */;\n\n  Container.prototype.addChild = function addChild(child) {\n    var argumentsLength = arguments.length;\n\n    // if there is only one argument we can bypass looping through the them\n    if (argumentsLength > 1) {\n      // loop through the arguments property and add all children\n      // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n      for (var i = 0; i < argumentsLength; i++) {\n        this.addChild(arguments[i]);\n      }\n    } else {\n      // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n      if (child.parent) {\n        child.parent.removeChild(child);\n      }\n      child.parent = this;\n      // ensure child transform will be recalculated\n      child.transform._parentID = -1;\n      this.children.push(child);\n\n      // ensure bounds will be recalculated\n      this._boundsID++;\n\n      // TODO - lets either do all callbacks or all events.. not both!\n      this.onChildrenChange(this.children.length - 1);\n      child.emit('added', this);\n    }\n    return child;\n  };\n\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n   *\n   * @param {PIXI.DisplayObject} child - The child to add\n   * @param {number} index - The index to place the child in\n   * @return {PIXI.DisplayObject} The child that was added.\n   */\n\n  Container.prototype.addChildAt = function addChildAt(child, index) {\n    if (index < 0 || index > this.children.length) {\n      throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length);\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    child.parent = this;\n    // ensure child transform will be recalculated\n    child.transform._parentID = -1;\n    this.children.splice(index, 0, child);\n\n    // ensure bounds will be recalculated\n    this._boundsID++;\n\n    // TODO - lets either do all callbacks or all events.. not both!\n    this.onChildrenChange(index);\n    child.emit('added', this);\n    return child;\n  };\n\n  /**\n   * Swaps the position of 2 Display Objects within this container.\n   *\n   * @param {PIXI.DisplayObject} child - First display object to swap\n   * @param {PIXI.DisplayObject} child2 - Second display object to swap\n   */\n\n  Container.prototype.swapChildren = function swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    var index1 = this.getChildIndex(child);\n    var index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    this.onChildrenChange(index1 < index2 ? index1 : index2);\n  };\n\n  /**\n   * Returns the index position of a child DisplayObject instance\n   *\n   * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify\n   * @return {number} The index position of the child display object to identify\n   */\n\n  Container.prototype.getChildIndex = function getChildIndex(child) {\n    var index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error('The supplied DisplayObject must be a child of the caller');\n    }\n    return index;\n  };\n\n  /**\n   * Changes the position of an existing child in the display object container\n   *\n   * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number\n   * @param {number} index - The resulting index number for the child display object\n   */\n\n  Container.prototype.setChildIndex = function setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error('The index ' + index + ' supplied is out of bounds ' + this.children.length);\n    }\n    var currentIndex = this.getChildIndex(child);\n    (0, _utils.removeItems)(this.children, currentIndex, 1); // remove from old position\n    this.children.splice(index, 0, child); // add at new position\n\n    this.onChildrenChange(index);\n  };\n\n  /**\n   * Returns the child at the specified index\n   *\n   * @param {number} index - The index to get the child at\n   * @return {PIXI.DisplayObject} The child at the given index, if any.\n   */\n\n  Container.prototype.getChildAt = function getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error('getChildAt: Index (' + index + ') does not exist.');\n    }\n    return this.children[index];\n  };\n\n  /**\n   * Removes one or more children from the container.\n   *\n   * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove\n   * @return {PIXI.DisplayObject} The first child that was removed.\n   */\n\n  Container.prototype.removeChild = function removeChild(child) {\n    var argumentsLength = arguments.length;\n\n    // if there is only one argument we can bypass looping through the them\n    if (argumentsLength > 1) {\n      // loop through the arguments property and add all children\n      // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n      for (var i = 0; i < argumentsLength; i++) {\n        this.removeChild(arguments[i]);\n      }\n    } else {\n      var index = this.children.indexOf(child);\n      if (index === -1) return null;\n      child.parent = null;\n      // ensure child transform will be recalculated\n      child.transform._parentID = -1;\n      (0, _utils.removeItems)(this.children, index, 1);\n\n      // ensure bounds will be recalculated\n      this._boundsID++;\n\n      // TODO - lets either do all callbacks or all events.. not both!\n      this.onChildrenChange(index);\n      child.emit('removed', this);\n    }\n    return child;\n  };\n\n  /**\n   * Removes a child from the specified index position.\n   *\n   * @param {number} index - The index to get the child from\n   * @return {PIXI.DisplayObject} The child that was removed.\n   */\n\n  Container.prototype.removeChildAt = function removeChildAt(index) {\n    var child = this.getChildAt(index);\n\n    // ensure child transform will be recalculated..\n    child.parent = null;\n    child.transform._parentID = -1;\n    (0, _utils.removeItems)(this.children, index, 1);\n\n    // ensure bounds will be recalculated\n    this._boundsID++;\n\n    // TODO - lets either do all callbacks or all events.. not both!\n    this.onChildrenChange(index);\n    child.emit('removed', this);\n    return child;\n  };\n\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   *\n   * @param {number} [beginIndex=0] - The beginning position.\n   * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.\n   * @returns {DisplayObject[]} List of removed children\n   */\n\n  Container.prototype.removeChildren = function removeChildren() {\n    var beginIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var endIndex = arguments[1];\n    var begin = beginIndex;\n    var end = typeof endIndex === 'number' ? endIndex : this.children.length;\n    var range = end - begin;\n    var removed = void 0;\n    if (range > 0 && range <= end) {\n      removed = this.children.splice(begin, range);\n      for (var i = 0; i < removed.length; ++i) {\n        removed[i].parent = null;\n        if (removed[i].transform) {\n          removed[i].transform._parentID = -1;\n        }\n      }\n      this._boundsID++;\n      this.onChildrenChange(beginIndex);\n      for (var _i = 0; _i < removed.length; ++_i) {\n        removed[_i].emit('removed', this);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return [];\n    }\n    throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n  };\n\n  /**\n   * Updates the transform on all children of this container for rendering\n   */\n\n  Container.prototype.updateTransform = function updateTransform() {\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform);\n\n    // TODO: check render flags, how to process stuff here\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      var child = this.children[i];\n      if (child.visible) {\n        child.updateTransform();\n      }\n    }\n  };\n\n  /**\n   * Recalculates the bounds of the container.\n   *\n   */\n\n  Container.prototype.calculateBounds = function calculateBounds() {\n    this._bounds.clear();\n    this._calculateBounds();\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      if (!child.visible || !child.renderable) {\n        continue;\n      }\n      child.calculateBounds();\n\n      // TODO: filter+mask, need to mask both somehow\n      if (child._mask) {\n        child._mask.calculateBounds();\n        this._bounds.addBoundsMask(child._bounds, child._mask._bounds);\n      } else if (child.filterArea) {\n        this._bounds.addBoundsArea(child._bounds, child.filterArea);\n      } else {\n        this._bounds.addBounds(child._bounds);\n      }\n    }\n    this._lastBoundsID = this._boundsID;\n  };\n\n  /**\n   * Recalculates the bounds of the object. Override this to\n   * calculate the bounds of the specific object (not including children).\n   *\n   */\n\n  Container.prototype._calculateBounds = function _calculateBounds() {}\n  // FILL IN//\n\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */;\n\n  Container.prototype.renderWebGL = function renderWebGL(renderer) {\n    // if the object is not visible or the alpha is 0 then no need to render this element\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    }\n\n    // do a quick check to see if this element has a mask or a filter.\n    if (this._mask || this.filters && this.filters.length) {\n      this.renderAdvancedWebGL(renderer);\n    } else {\n      this._renderWebGL(renderer);\n\n      // simple render children!\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        this.children[i].renderWebGL(renderer);\n      }\n    }\n  };\n\n  /**\n   * Render the object using the WebGL renderer and advanced features.\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n  Container.prototype.renderAdvancedWebGL = function renderAdvancedWebGL(renderer) {\n    renderer.flush();\n    var filters = this._filters;\n    var mask = this._mask;\n\n    // push filter first as we need to ensure the stencil buffer is correct for any masking\n    if (filters) {\n      if (!this._enabledFilters) {\n        this._enabledFilters = [];\n      }\n      this._enabledFilters.length = 0;\n      for (var i = 0; i < filters.length; i++) {\n        if (filters[i].enabled) {\n          this._enabledFilters.push(filters[i]);\n        }\n      }\n      if (this._enabledFilters.length) {\n        renderer.filterManager.pushFilter(this, this._enabledFilters);\n      }\n    }\n    if (mask) {\n      renderer.maskManager.pushMask(this, this._mask);\n    }\n\n    // add this object to the batch, only rendered if it has a texture.\n    this._renderWebGL(renderer);\n\n    // now loop through the children and make sure they get rendered\n    for (var _i2 = 0, j = this.children.length; _i2 < j; _i2++) {\n      this.children[_i2].renderWebGL(renderer);\n    }\n    renderer.flush();\n    if (mask) {\n      renderer.maskManager.popMask(this, this._mask);\n    }\n    if (filters && this._enabledFilters && this._enabledFilters.length) {\n      renderer.filterManager.popFilter();\n    }\n  };\n\n  /**\n   * To be overridden by the subclasses.\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n  Container.prototype._renderWebGL = function _renderWebGL(renderer)\n  // eslint-disable-line no-unused-vars\n  {}\n  // this is where content itself gets rendered...\n\n  /**\n   * To be overridden by the subclass\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */;\n\n  Container.prototype._renderCanvas = function _renderCanvas(renderer)\n  // eslint-disable-line no-unused-vars\n  {}\n  // this is where content itself gets rendered...\n\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */;\n\n  Container.prototype.renderCanvas = function renderCanvas(renderer) {\n    // if not visible or the alpha is 0 then no need to render this\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    }\n    if (this._mask) {\n      renderer.maskManager.pushMask(this._mask);\n    }\n    this._renderCanvas(renderer);\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      this.children[i].renderCanvas(renderer);\n    }\n    if (this._mask) {\n      renderer.maskManager.popMask(renderer);\n    }\n  };\n\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n  Container.prototype.destroy = function destroy(options) {\n    _DisplayObject.prototype.destroy.call(this);\n    var destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n    var oldChildren = this.removeChildren(0, this.children.length);\n    if (destroyChildren) {\n      for (var i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  };\n\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   */\n\n  _createClass(Container, [{\n    key: 'width',\n    get: function get() {\n      return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      var width = this.getLocalBounds().width;\n      if (width !== 0) {\n        this.scale.x = value / width;\n      } else {\n        this.scale.x = 1;\n      }\n      this._width = value;\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n  }, {\n    key: 'height',\n    get: function get() {\n      return this.scale.y * this.getLocalBounds().height;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      var height = this.getLocalBounds().height;\n      if (height !== 0) {\n        this.scale.y = value / height;\n      } else {\n        this.scale.y = 1;\n      }\n      this._height = value;\n    }\n  }]);\n  return Container;\n}(_DisplayObject3.default);\n\n// performance increase to avoid using call.. (10x faster)\n\nexports.default = Container;\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;","map":{"version":3,"names":["_utils","require","_DisplayObject2","Container","_classCallCheck","_this","_possibleConstructorReturn","_DisplayObject","call","children","onChildrenChange","addChild","child","argumentsLength","arguments","length","i","parent","removeChild","transform","_parentID","push","_boundsID","emit","addChildAt","index","Error","splice","swapChildren","child2","index1","getChildIndex","index2","indexOf","setChildIndex","currentIndex","removeItems","getChildAt","removeChildAt","removeChildren","beginIndex","undefined","endIndex","begin","end","range","removed","_i","RangeError","updateTransform","worldAlpha","alpha","j","visible","calculateBounds","_bounds","clear","_calculateBounds","renderable","_mask","addBoundsMask","filterArea","addBoundsArea","addBounds","_lastBoundsID","renderWebGL","renderer","filters","renderAdvancedWebGL","_renderWebGL","flush","_filters","mask","_enabledFilters","enabled","filterManager","pushFilter","maskManager","pushMask","_i2","popMask","popFilter","_renderCanvas","renderCanvas","destroy","options","prototype","destroyChildren","oldChildren","scale","x","getLocalBounds","width","value","_width","y","height","_height","containerUpdateTransform"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/display/Container.js"],"sourcesContent":["import { removeItems } from '../utils';\nimport DisplayObject from './DisplayObject';\n\n/**\n * A Container represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n *```js\n * let container = new PIXI.Container();\n * container.addChild(sprite);\n * ```\n *\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI\n */\nexport default class Container extends DisplayObject\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        super();\n\n        /**\n         * The array of children of this container.\n         *\n         * @member {PIXI.DisplayObject[]}\n         * @readonly\n         */\n        this.children = [];\n    }\n\n    /**\n     * Overridable method that can be used by Container subclasses whenever the children array is modified\n     *\n     * @private\n     */\n    onChildrenChange()\n    {\n        /* empty */\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     *\n     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container\n     * @return {PIXI.DisplayObject} The first child that was added.\n     */\n    addChild(child)\n    {\n        const argumentsLength = arguments.length;\n\n        // if there is only one argument we can bypass looping through the them\n        if (argumentsLength > 1)\n        {\n            // loop through the arguments property and add all children\n            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n            for (let i = 0; i < argumentsLength; i++)\n            {\n                this.addChild(arguments[i]);\n            }\n        }\n        else\n        {\n            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n            if (child.parent)\n            {\n                child.parent.removeChild(child);\n            }\n\n            child.parent = this;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            this.children.push(child);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(this.children.length - 1);\n            child.emit('added', this);\n        }\n\n        return child;\n    }\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n     *\n     * @param {PIXI.DisplayObject} child - The child to add\n     * @param {number} index - The index to place the child in\n     * @return {PIXI.DisplayObject} The child that was added.\n     */\n    addChildAt(child, index)\n    {\n        if (index < 0 || index > this.children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        this.children.splice(index, 0, child);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n\n        return child;\n    }\n\n    /**\n     * Swaps the position of 2 Display Objects within this container.\n     *\n     * @param {PIXI.DisplayObject} child - First display object to swap\n     * @param {PIXI.DisplayObject} child2 - Second display object to swap\n     */\n    swapChildren(child, child2)\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n        this.onChildrenChange(index1 < index2 ? index1 : index2);\n    }\n\n    /**\n     * Returns the index position of a child DisplayObject instance\n     *\n     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify\n     * @return {number} The index position of the child display object to identify\n     */\n    getChildIndex(child)\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        return index;\n    }\n\n    /**\n     * Changes the position of an existing child in the display object container\n     *\n     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number\n     * @param {number} index - The resulting index number for the child display object\n     */\n    setChildIndex(child, index)\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        const currentIndex = this.getChildIndex(child);\n\n        removeItems(this.children, currentIndex, 1); // remove from old position\n        this.children.splice(index, 0, child); // add at new position\n\n        this.onChildrenChange(index);\n    }\n\n    /**\n     * Returns the child at the specified index\n     *\n     * @param {number} index - The index to get the child at\n     * @return {PIXI.DisplayObject} The child at the given index, if any.\n     */\n    getChildAt(index)\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index];\n    }\n\n    /**\n     * Removes one or more children from the container.\n     *\n     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove\n     * @return {PIXI.DisplayObject} The first child that was removed.\n     */\n    removeChild(child)\n    {\n        const argumentsLength = arguments.length;\n\n        // if there is only one argument we can bypass looping through the them\n        if (argumentsLength > 1)\n        {\n            // loop through the arguments property and add all children\n            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n            for (let i = 0; i < argumentsLength; i++)\n            {\n                this.removeChild(arguments[i]);\n            }\n        }\n        else\n        {\n            const index = this.children.indexOf(child);\n\n            if (index === -1) return null;\n\n            child.parent = null;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n            removeItems(this.children, index, 1);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes a child from the specified index position.\n     *\n     * @param {number} index - The index to get the child from\n     * @return {PIXI.DisplayObject} The child that was removed.\n     */\n    removeChildAt(index)\n    {\n        const child = this.getChildAt(index);\n\n        // ensure child transform will be recalculated..\n        child.parent = null;\n        child.transform._parentID = -1;\n        removeItems(this.children, index, 1);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n\n        return child;\n    }\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     *\n     * @param {number} [beginIndex=0] - The beginning position.\n     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.\n     * @returns {DisplayObject[]} List of removed children\n     */\n    removeChildren(beginIndex = 0, endIndex)\n    {\n        const begin = beginIndex;\n        const end = typeof endIndex === 'number' ? endIndex : this.children.length;\n        const range = end - begin;\n        let removed;\n\n        if (range > 0 && range <= end)\n        {\n            removed = this.children.splice(begin, range);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].parent = null;\n                if (removed[i].transform)\n                {\n                    removed[i].transform._parentID = -1;\n                }\n            }\n\n            this._boundsID++;\n\n            this.onChildrenChange(beginIndex);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].emit('removed', this);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return [];\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n\n    /**\n     * Updates the transform on all children of this container for rendering\n     */\n    updateTransform()\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n\n        // TODO: check render flags, how to process stuff here\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            if (child.visible)\n            {\n                child.updateTransform();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the bounds of the container.\n     *\n     */\n    calculateBounds()\n    {\n        this._bounds.clear();\n\n        this._calculateBounds();\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            const child = this.children[i];\n\n            if (!child.visible || !child.renderable)\n            {\n                continue;\n            }\n\n            child.calculateBounds();\n\n            // TODO: filter+mask, need to mask both somehow\n            if (child._mask)\n            {\n                child._mask.calculateBounds();\n                this._bounds.addBoundsMask(child._bounds, child._mask._bounds);\n            }\n            else if (child.filterArea)\n            {\n                this._bounds.addBoundsArea(child._bounds, child.filterArea);\n            }\n            else\n            {\n                this._bounds.addBounds(child._bounds);\n            }\n        }\n\n        this._lastBoundsID = this._boundsID;\n    }\n\n    /**\n     * Recalculates the bounds of the object. Override this to\n     * calculate the bounds of the specific object (not including children).\n     *\n     */\n    _calculateBounds()\n    {\n        // FILL IN//\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderWebGL(renderer)\n    {\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        // do a quick check to see if this element has a mask or a filter.\n        if (this._mask || (this.filters && this.filters.length))\n        {\n            this.renderAdvancedWebGL(renderer);\n        }\n        else\n        {\n            this._renderWebGL(renderer);\n\n            // simple render children!\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                this.children[i].renderWebGL(renderer);\n            }\n        }\n    }\n\n    /**\n     * Render the object using the WebGL renderer and advanced features.\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderAdvancedWebGL(renderer)\n    {\n        renderer.flush();\n\n        const filters = this._filters;\n        const mask = this._mask;\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (filters)\n        {\n            if (!this._enabledFilters)\n            {\n                this._enabledFilters = [];\n            }\n\n            this._enabledFilters.length = 0;\n\n            for (let i = 0; i < filters.length; i++)\n            {\n                if (filters[i].enabled)\n                {\n                    this._enabledFilters.push(filters[i]);\n                }\n            }\n\n            if (this._enabledFilters.length)\n            {\n                renderer.filterManager.pushFilter(this, this._enabledFilters);\n            }\n        }\n\n        if (mask)\n        {\n            renderer.maskManager.pushMask(this, this._mask);\n        }\n\n        // add this object to the batch, only rendered if it has a texture.\n        this._renderWebGL(renderer);\n\n        // now loop through the children and make sure they get rendered\n        for (let i = 0, j = this.children.length; i < j; i++)\n        {\n            this.children[i].renderWebGL(renderer);\n        }\n\n        renderer.flush();\n\n        if (mask)\n        {\n            renderer.maskManager.popMask(this, this._mask);\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filterManager.popFilter();\n        }\n    }\n\n    /**\n     * To be overridden by the subclasses.\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer) // eslint-disable-line no-unused-vars\n    {\n        // this is where content itself gets rendered...\n    }\n\n    /**\n     * To be overridden by the subclass\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer) // eslint-disable-line no-unused-vars\n    {\n        // this is where content itself gets rendered...\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    renderCanvas(renderer)\n    {\n        // if not visible or the alpha is 0 then no need to render this\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.pushMask(this._mask);\n        }\n\n        this._renderCanvas(renderer);\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            this.children[i].renderCanvas(renderer);\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.popMask(renderer);\n        }\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this.scale.x * this.getLocalBounds().width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        const width = this.getLocalBounds().width;\n\n        if (width !== 0)\n        {\n            this.scale.x = value / width;\n        }\n        else\n        {\n            this.scale.x = 1;\n        }\n\n        this._width = value;\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this.scale.y * this.getLocalBounds().height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        const height = this.getLocalBounds().height;\n\n        if (height !== 0)\n        {\n            this.scale.y = value / height;\n        }\n        else\n        {\n            this.scale.y = 1;\n        }\n\n        this._height = value;\n    }\n}\n\n// performance increase to avoid using call.. (10x faster)\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}