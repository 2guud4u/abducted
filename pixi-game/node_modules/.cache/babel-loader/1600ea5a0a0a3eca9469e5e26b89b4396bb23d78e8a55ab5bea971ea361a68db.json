{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _extractUniformsFromSrc = require('./extractUniformsFromSrc');\nvar _extractUniformsFromSrc2 = _interopRequireDefault(_extractUniformsFromSrc);\nvar _utils = require('../../../utils');\nvar _const = require('../../../const');\nvar _settings = require('../../../settings');\nvar _settings2 = _interopRequireDefault(_settings);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar SOURCE_KEY_MAP = {};\n\n// let math = require('../../../math');\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.Shader\n */\n\nvar Filter = function () {\n  /**\n   * @param {string} [vertexSrc] - The source of the vertex shader.\n   * @param {string} [fragmentSrc] - The source of the fragment shader.\n   * @param {object} [uniformData] - Custom uniforms to use to augment the built-in ones.\n   */\n  function Filter(vertexSrc, fragmentSrc, uniformData) {\n    _classCallCheck(this, Filter);\n\n    /**\n     * The vertex shader.\n     *\n     * @member {string}\n     */\n    this.vertexSrc = vertexSrc || Filter.defaultVertexSrc;\n\n    /**\n     * The fragment shader.\n     *\n     * @member {string}\n     */\n    this.fragmentSrc = fragmentSrc || Filter.defaultFragmentSrc;\n    this._blendMode = _const.BLEND_MODES.NORMAL;\n    this.uniformData = uniformData || (0, _extractUniformsFromSrc2.default)(this.vertexSrc, this.fragmentSrc, 'projectionMatrix|uSampler');\n\n    /**\n     * An object containing the current values of custom uniforms.\n     * @example <caption>Updating the value of a custom uniform</caption>\n     * filter.uniforms.time = performance.now();\n     *\n     * @member {object}\n     */\n    this.uniforms = {};\n    for (var i in this.uniformData) {\n      this.uniforms[i] = this.uniformData[i].value;\n      if (this.uniformData[i].type) {\n        this.uniformData[i].type = this.uniformData[i].type.toLowerCase();\n      }\n    }\n\n    // this is where we store shader references..\n    // TODO we could cache this!\n    this.glShaders = {};\n\n    // used for caching.. sure there is a better way!\n    if (!SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc]) {\n      SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc] = (0, _utils.uid)();\n    }\n    this.glShaderKey = SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc];\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     *\n     * @member {number}\n     */\n    this.padding = 4;\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     *\n     * @member {number}\n     */\n    this.resolution = _settings2.default.FILTER_RESOLUTION;\n\n    /**\n     * If enabled is true the filter is applied, if false it will not.\n     *\n     * @member {boolean}\n     */\n    this.enabled = true;\n\n    /**\n     * If enabled, PixiJS will fit the filter area into boundaries for better performance.\n     * Switch it off if it does not work for specific shader.\n     *\n     * @member {boolean}\n     */\n    this.autoFit = true;\n  }\n\n  /**\n   * Applies the filter\n   *\n   * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from\n   * @param {PIXI.RenderTarget} input - The input render target.\n   * @param {PIXI.RenderTarget} output - The target to output to.\n   * @param {boolean} clear - Should the output be cleared before rendering to it\n   * @param {object} [currentState] - It's current state of filter.\n   *        There are some useful properties in the currentState :\n   *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution\n   */\n\n  Filter.prototype.apply = function apply(filterManager, input, output, clear, currentState)\n  // eslint-disable-line no-unused-vars\n  {\n    // --- //\n    //  this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(tempMatrix, window.panda );\n\n    // do as you please!\n\n    filterManager.applyFilter(this, input, output, clear);\n\n    // or just do a regular render..\n  };\n\n  /**\n   * Sets the blendmode of the filter\n   *\n   * @member {number}\n   * @default PIXI.BLEND_MODES.NORMAL\n   */\n\n  _createClass(Filter, [{\n    key: 'blendMode',\n    get: function get() {\n      return this._blendMode;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this._blendMode = value;\n    }\n\n    /**\n     * The default vertex shader source\n     *\n     * @static\n     * @constant\n     */\n  }], [{\n    key: 'defaultVertexSrc',\n    get: function get() {\n      return ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform mat3 projectionMatrix;', 'uniform mat3 filterMatrix;', 'varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;', '   vTextureCoord = aTextureCoord ;', '}'].join('\\n');\n    }\n\n    /**\n     * The default fragment shader source\n     *\n     * @static\n     * @constant\n     */\n  }, {\n    key: 'defaultFragmentSrc',\n    get: function get() {\n      return ['varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'uniform sampler2D uSampler;', 'uniform sampler2D filterSampler;', 'void main(void){', '   vec4 masky = texture2D(filterSampler, vFilterCoord);', '   vec4 sample = texture2D(uSampler, vTextureCoord);', '   vec4 color;', '   if(mod(vFilterCoord.x, 1.0) > 0.5)', '   {', '     color = vec4(1.0, 0.0, 0.0, 1.0);', '   }', '   else', '   {', '     color = vec4(0.0, 1.0, 0.0, 1.0);', '   }',\n      // '   gl_FragColor = vec4(mod(vFilterCoord.x, 1.5), vFilterCoord.y,0.0,1.0);',\n      '   gl_FragColor = mix(sample, masky, 0.5);', '   gl_FragColor *= sample.a;', '}'].join('\\n');\n    }\n  }]);\n  return Filter;\n}();\nexports.default = Filter;","map":{"version":3,"names":["_extractUniformsFromSrc","require","_utils","_const","_settings","SOURCE_KEY_MAP","Filter","vertexSrc","fragmentSrc","uniformData","_classCallCheck","defaultVertexSrc","defaultFragmentSrc","_blendMode","BLEND_MODES","NORMAL","_extractUniformsFromSrc2","default","uniforms","i","value","type","toLowerCase","glShaders","uid","glShaderKey","padding","resolution","_settings2","FILTER_RESOLUTION","enabled","autoFit","apply","filterManager","input","output","clear","currentState","applyFilter","join"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/renderers/webgl/filters/Filter.js"],"sourcesContent":["import extractUniformsFromSrc from './extractUniformsFromSrc';\nimport { uid } from '../../../utils';\nimport { BLEND_MODES } from '../../../const';\nimport settings from '../../../settings';\n\nconst SOURCE_KEY_MAP = {};\n\n// let math = require('../../../math');\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.Shader\n */\nexport default class Filter\n{\n    /**\n     * @param {string} [vertexSrc] - The source of the vertex shader.\n     * @param {string} [fragmentSrc] - The source of the fragment shader.\n     * @param {object} [uniformData] - Custom uniforms to use to augment the built-in ones.\n     */\n    constructor(vertexSrc, fragmentSrc, uniformData)\n    {\n        /**\n         * The vertex shader.\n         *\n         * @member {string}\n         */\n        this.vertexSrc = vertexSrc || Filter.defaultVertexSrc;\n\n        /**\n         * The fragment shader.\n         *\n         * @member {string}\n         */\n        this.fragmentSrc = fragmentSrc || Filter.defaultFragmentSrc;\n\n        this._blendMode = BLEND_MODES.NORMAL;\n\n        this.uniformData = uniformData || extractUniformsFromSrc(\n            this.vertexSrc,\n            this.fragmentSrc,\n            'projectionMatrix|uSampler'\n        );\n\n        /**\n         * An object containing the current values of custom uniforms.\n         * @example <caption>Updating the value of a custom uniform</caption>\n         * filter.uniforms.time = performance.now();\n         *\n         * @member {object}\n         */\n        this.uniforms = {};\n\n        for (const i in this.uniformData)\n        {\n            this.uniforms[i] = this.uniformData[i].value;\n            if (this.uniformData[i].type)\n            {\n                this.uniformData[i].type = this.uniformData[i].type.toLowerCase();\n            }\n        }\n\n        // this is where we store shader references..\n        // TODO we could cache this!\n        this.glShaders = {};\n\n        // used for caching.. sure there is a better way!\n        if (!SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc])\n        {\n            SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc] = uid();\n        }\n\n        this.glShaderKey = SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc];\n\n        /**\n         * The padding of the filter. Some filters require extra space to breath such as a blur.\n         * Increasing this will add extra width and height to the bounds of the object that the\n         * filter is applied to.\n         *\n         * @member {number}\n         */\n        this.padding = 4;\n\n        /**\n         * The resolution of the filter. Setting this to be lower will lower the quality but\n         * increase the performance of the filter.\n         *\n         * @member {number}\n         */\n        this.resolution = settings.FILTER_RESOLUTION;\n\n        /**\n         * If enabled is true the filter is applied, if false it will not.\n         *\n         * @member {boolean}\n         */\n        this.enabled = true;\n\n        /**\n         * If enabled, PixiJS will fit the filter area into boundaries for better performance.\n         * Switch it off if it does not work for specific shader.\n         *\n         * @member {boolean}\n         */\n        this.autoFit = true;\n    }\n\n    /**\n     * Applies the filter\n     *\n     * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from\n     * @param {PIXI.RenderTarget} input - The input render target.\n     * @param {PIXI.RenderTarget} output - The target to output to.\n     * @param {boolean} clear - Should the output be cleared before rendering to it\n     * @param {object} [currentState] - It's current state of filter.\n     *        There are some useful properties in the currentState :\n     *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution\n     */\n    apply(filterManager, input, output, clear, currentState) // eslint-disable-line no-unused-vars\n    {\n        // --- //\n        //  this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(tempMatrix, window.panda );\n\n        // do as you please!\n\n        filterManager.applyFilter(this, input, output, clear);\n\n        // or just do a regular render..\n    }\n\n    /**\n     * Sets the blendmode of the filter\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    get blendMode()\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value) // eslint-disable-line require-jsdoc\n    {\n        this._blendMode = value;\n    }\n\n    /**\n     * The default vertex shader source\n     *\n     * @static\n     * @constant\n     */\n    static get defaultVertexSrc()\n    {\n        return [\n            'attribute vec2 aVertexPosition;',\n            'attribute vec2 aTextureCoord;',\n\n            'uniform mat3 projectionMatrix;',\n            'uniform mat3 filterMatrix;',\n\n            'varying vec2 vTextureCoord;',\n            'varying vec2 vFilterCoord;',\n\n            'void main(void){',\n            '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;',\n            '   vTextureCoord = aTextureCoord ;',\n            '}',\n        ].join('\\n');\n    }\n\n    /**\n     * The default fragment shader source\n     *\n     * @static\n     * @constant\n     */\n    static get defaultFragmentSrc()\n    {\n        return [\n            'varying vec2 vTextureCoord;',\n            'varying vec2 vFilterCoord;',\n\n            'uniform sampler2D uSampler;',\n            'uniform sampler2D filterSampler;',\n\n            'void main(void){',\n            '   vec4 masky = texture2D(filterSampler, vFilterCoord);',\n            '   vec4 sample = texture2D(uSampler, vTextureCoord);',\n            '   vec4 color;',\n            '   if(mod(vFilterCoord.x, 1.0) > 0.5)',\n            '   {',\n            '     color = vec4(1.0, 0.0, 0.0, 1.0);',\n            '   }',\n            '   else',\n            '   {',\n            '     color = vec4(0.0, 1.0, 0.0, 1.0);',\n            '   }',\n            // '   gl_FragColor = vec4(mod(vFilterCoord.x, 1.5), vFilterCoord.y,0.0,1.0);',\n            '   gl_FragColor = mix(sample, masky, 0.5);',\n            '   gl_FragColor *= sample.a;',\n            '}',\n        ].join('\\n');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}