{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.calculateScreenSpaceMatrix = calculateScreenSpaceMatrix;\nexports.calculateNormalizedScreenSpaceMatrix = calculateNormalizedScreenSpaceMatrix;\nexports.calculateSpriteMatrix = calculateSpriteMatrix;\nvar _math = require('../../../math');\n\n/**\n * Calculates the mapped matrix\n * @param filterArea {Rectangle} The filter area\n * @param sprite {Sprite} the target sprite\n * @param outputMatrix {Matrix} @alvin\n * @private\n */\n// TODO playing around here.. this is temporary - (will end up in the shader)\n// this returns a matrix that will normalise map filter cords in the filter to screen space\nfunction calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {\n  // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),\n  // let texture = {width:1136, height:700};//sprite._texture.baseTexture;\n\n  // TODO unwrap?\n  var mappedMatrix = outputMatrix.identity();\n  mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n  mappedMatrix.scale(textureSize.width, textureSize.height);\n  return mappedMatrix;\n}\nfunction calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {\n  var mappedMatrix = outputMatrix.identity();\n  mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n  var translateScaleX = textureSize.width / filterArea.width;\n  var translateScaleY = textureSize.height / filterArea.height;\n  mappedMatrix.scale(translateScaleX, translateScaleY);\n  return mappedMatrix;\n}\n\n// this will map the filter coord so that a texture can be used based on the transform of a sprite\nfunction calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {\n  var orig = sprite._texture.orig;\n  var mappedMatrix = outputMatrix.set(textureSize.width, 0, 0, textureSize.height, filterArea.x, filterArea.y);\n  var worldTransform = sprite.worldTransform.copy(_math.Matrix.TEMP_MATRIX);\n  worldTransform.invert();\n  mappedMatrix.prepend(worldTransform);\n  mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);\n  mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n  return mappedMatrix;\n}","map":{"version":3,"names":["calculateScreenSpaceMatrix","calculateNormalizedScreenSpaceMatrix","calculateSpriteMatrix","_math","require","outputMatrix","filterArea","textureSize","mappedMatrix","identity","translate","x","width","y","height","scale","translateScaleX","translateScaleY","sprite","orig","_texture","set","worldTransform","copy","Matrix","TEMP_MATRIX","invert","prepend","anchor"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/renderers/webgl/filters/filterTransforms.js"],"sourcesContent":["import { Matrix } from '../../../math';\n\n/**\n * Calculates the mapped matrix\n * @param filterArea {Rectangle} The filter area\n * @param sprite {Sprite} the target sprite\n * @param outputMatrix {Matrix} @alvin\n * @private\n */\n// TODO playing around here.. this is temporary - (will end up in the shader)\n// this returns a matrix that will normalise map filter cords in the filter to screen space\nexport function calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize)\n{\n     // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),\n    // let texture = {width:1136, height:700};//sprite._texture.baseTexture;\n\n    // TODO unwrap?\n    const mappedMatrix = outputMatrix.identity();\n\n    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n\n    mappedMatrix.scale(textureSize.width, textureSize.height);\n\n    return mappedMatrix;\n}\n\nexport function calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize)\n{\n    const mappedMatrix = outputMatrix.identity();\n\n    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n\n    const translateScaleX = (textureSize.width / filterArea.width);\n    const translateScaleY = (textureSize.height / filterArea.height);\n\n    mappedMatrix.scale(translateScaleX, translateScaleY);\n\n    return mappedMatrix;\n}\n\n// this will map the filter coord so that a texture can be used based on the transform of a sprite\nexport function calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite)\n{\n    const orig = sprite._texture.orig;\n    const mappedMatrix = outputMatrix.set(textureSize.width, 0, 0, textureSize.height, filterArea.x, filterArea.y);\n    const worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX);\n\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n    return mappedMatrix;\n}\n"],"mappings":";;;QAWgBA,0B,GAAAA,0B;QAeAC,oC,GAAAA,oC;QAeAC,qB,GAAAA,qB;AAzChB,IAAAC,KAAA,GAAAC,OAAA;;AAEA;;;;;;;AAOA;AACA;AACO,SAASJ,0BAATA,CAAoCK,YAApC,EAAkDC,UAAlD,EAA8DC,WAA9D,EACP;EACK;EACD;;EAEA;EACA,IAAMC,YAAA,GAAeH,YAAA,CAAaI,QAAb,EAArB;EAEAD,YAAA,CAAaE,SAAb,CAAuBJ,UAAA,CAAWK,CAAX,GAAeJ,WAAA,CAAYK,KAAlD,EAAyDN,UAAA,CAAWO,CAAX,GAAeN,WAAA,CAAYO,MAApF;EAEAN,YAAA,CAAaO,KAAb,CAAmBR,WAAA,CAAYK,KAA/B,EAAsCL,WAAA,CAAYO,MAAlD;EAEA,OAAON,YAAP;AACH;AAEM,SAASP,oCAATA,CAA8CI,YAA9C,EAA4DC,UAA5D,EAAwEC,WAAxE,EACP;EACI,IAAMC,YAAA,GAAeH,YAAA,CAAaI,QAAb,EAArB;EAEAD,YAAA,CAAaE,SAAb,CAAuBJ,UAAA,CAAWK,CAAX,GAAeJ,WAAA,CAAYK,KAAlD,EAAyDN,UAAA,CAAWO,CAAX,GAAeN,WAAA,CAAYO,MAApF;EAEA,IAAME,eAAA,GAAmBT,WAAA,CAAYK,KAAZ,GAAoBN,UAAA,CAAWM,KAAxD;EACA,IAAMK,eAAA,GAAmBV,WAAA,CAAYO,MAAZ,GAAqBR,UAAA,CAAWQ,MAAzD;EAEAN,YAAA,CAAaO,KAAb,CAAmBC,eAAnB,EAAoCC,eAApC;EAEA,OAAOT,YAAP;AACH;;AAED;AACO,SAASN,qBAATA,CAA+BG,YAA/B,EAA6CC,UAA7C,EAAyDC,WAAzD,EAAsEW,MAAtE,EACP;EACI,IAAMC,IAAA,GAAOD,MAAA,CAAOE,QAAP,CAAgBD,IAA7B;EACA,IAAMX,YAAA,GAAeH,YAAA,CAAagB,GAAb,CAAiBd,WAAA,CAAYK,KAA7B,EAAoC,CAApC,EAAuC,CAAvC,EAA0CL,WAAA,CAAYO,MAAtD,EAA8DR,UAAA,CAAWK,CAAzE,EAA4EL,UAAA,CAAWO,CAAvF,CAArB;EACA,IAAMS,cAAA,GAAiBJ,MAAA,CAAOI,cAAP,CAAsBC,IAAtB,CAA2BpB,KAAA,CAAAqB,MAAA,CAAOC,WAAlC,CAAvB;EAEAH,cAAA,CAAeI,MAAf;EACAlB,YAAA,CAAamB,OAAb,CAAqBL,cAArB;EACAd,YAAA,CAAaO,KAAb,CAAmB,MAAMI,IAAA,CAAKP,KAA9B,EAAqC,MAAMO,IAAA,CAAKL,MAAhD;EACAN,YAAA,CAAaE,SAAb,CAAuBQ,MAAA,CAAOU,MAAP,CAAcjB,CAArC,EAAwCO,MAAA,CAAOU,MAAP,CAAcf,CAAtD;EAEA,OAAOL,YAAP;AACH"},"metadata":{},"sourceType":"script","externalDependencies":[]}