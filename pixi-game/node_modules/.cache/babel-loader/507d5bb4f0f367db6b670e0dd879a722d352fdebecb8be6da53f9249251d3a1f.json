{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _utils = require('../../utils');\nvar _const = require('../../const');\nvar _ObjectRenderer2 = require('../../renderers/webgl/utils/ObjectRenderer');\nvar _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);\nvar _WebGLRenderer = require('../../renderers/webgl/WebGLRenderer');\nvar _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);\nvar _WebGLGraphicsData = require('./WebGLGraphicsData');\nvar _WebGLGraphicsData2 = _interopRequireDefault(_WebGLGraphicsData);\nvar _PrimitiveShader = require('./shaders/PrimitiveShader');\nvar _PrimitiveShader2 = _interopRequireDefault(_PrimitiveShader);\nvar _buildPoly = require('./utils/buildPoly');\nvar _buildPoly2 = _interopRequireDefault(_buildPoly);\nvar _buildRectangle = require('./utils/buildRectangle');\nvar _buildRectangle2 = _interopRequireDefault(_buildRectangle);\nvar _buildRoundedRectangle = require('./utils/buildRoundedRectangle');\nvar _buildRoundedRectangle2 = _interopRequireDefault(_buildRoundedRectangle);\nvar _buildCircle = require('./utils/buildCircle');\nvar _buildCircle2 = _interopRequireDefault(_buildCircle);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * Renders the graphics object.\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nvar GraphicsRenderer = function (_ObjectRenderer) {\n  _inherits(GraphicsRenderer, _ObjectRenderer);\n\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this object renderer works for.\n   */\n  function GraphicsRenderer(renderer) {\n    _classCallCheck(this, GraphicsRenderer);\n    var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));\n    _this.graphicsDataPool = [];\n    _this.primitiveShader = null;\n    _this.gl = renderer.gl;\n\n    // easy access!\n    _this.CONTEXT_UID = 0;\n    return _this;\n  }\n\n  /**\n   * Called when there is a WebGL context change\n   *\n   * @private\n   *\n   */\n\n  GraphicsRenderer.prototype.onContextChange = function onContextChange() {\n    this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    this.primitiveShader = new _PrimitiveShader2.default(this.gl);\n  };\n\n  /**\n   * Destroys this renderer.\n   *\n   */\n\n  GraphicsRenderer.prototype.destroy = function destroy() {\n    _ObjectRenderer3.default.prototype.destroy.call(this);\n    for (var i = 0; i < this.graphicsDataPool.length; ++i) {\n      this.graphicsDataPool[i].destroy();\n    }\n    this.graphicsDataPool = null;\n  };\n\n  /**\n   * Renders a graphics object.\n   *\n   * @param {PIXI.Graphics} graphics - The graphics object to render.\n   */\n\n  GraphicsRenderer.prototype.render = function render(graphics) {\n    var renderer = this.renderer;\n    var gl = renderer.gl;\n    var webGLData = void 0;\n    var webGL = graphics._webGL[this.CONTEXT_UID];\n    if (!webGL || graphics.dirty !== webGL.dirty) {\n      this.updateGraphics(graphics);\n      webGL = graphics._webGL[this.CONTEXT_UID];\n    }\n\n    // This  could be speeded up for sure!\n    var shader = this.primitiveShader;\n    renderer.bindShader(shader);\n    renderer.state.setBlendMode(graphics.blendMode);\n    for (var i = 0, n = webGL.data.length; i < n; i++) {\n      webGLData = webGL.data[i];\n      var shaderTemp = webGLData.shader;\n      renderer.bindShader(shaderTemp);\n      shaderTemp.uniforms.translationMatrix = graphics.transform.worldTransform.toArray(true);\n      shaderTemp.uniforms.tint = (0, _utils.hex2rgb)(graphics.tint);\n      shaderTemp.uniforms.alpha = graphics.worldAlpha;\n      renderer.bindVao(webGLData.vao);\n      if (webGLData.nativeLines) {\n        gl.drawArrays(gl.LINES, 0, webGLData.points.length / 6);\n      } else {\n        webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length);\n      }\n    }\n  };\n\n  /**\n   * Updates the graphics object\n   *\n   * @private\n   * @param {PIXI.Graphics} graphics - The graphics object to update\n   */\n\n  GraphicsRenderer.prototype.updateGraphics = function updateGraphics(graphics) {\n    var gl = this.renderer.gl;\n\n    // get the contexts graphics object\n    var webGL = graphics._webGL[this.CONTEXT_UID];\n\n    // if the graphics object does not exist in the webGL context time to create it!\n    if (!webGL) {\n      webGL = graphics._webGL[this.CONTEXT_UID] = {\n        lastIndex: 0,\n        data: [],\n        gl: gl,\n        clearDirty: -1,\n        dirty: -1\n      };\n    }\n\n    // flag the graphics as not dirty as we are about to update it...\n    webGL.dirty = graphics.dirty;\n\n    // if the user cleared the graphics object we will need to clear every object\n    if (graphics.clearDirty !== webGL.clearDirty) {\n      webGL.clearDirty = graphics.clearDirty;\n\n      // loop through and return all the webGLDatas to the object pool so than can be reused later on\n      for (var i = 0; i < webGL.data.length; i++) {\n        this.graphicsDataPool.push(webGL.data[i]);\n      }\n\n      // clear the array and reset the index..\n      webGL.data.length = 0;\n      webGL.lastIndex = 0;\n    }\n    var webGLData = void 0;\n    var webGLDataNativeLines = void 0;\n\n    // loop through the graphics datas and construct each one..\n    // if the object is a complex fill then the new stencil buffer technique will be used\n    // other wise graphics objects will be pushed into a batch..\n    for (var _i = webGL.lastIndex; _i < graphics.graphicsData.length; _i++) {\n      var data = graphics.graphicsData[_i];\n\n      // TODO - this can be simplified\n      webGLData = this.getWebGLData(webGL, 0);\n      if (data.nativeLines && data.lineWidth) {\n        webGLDataNativeLines = this.getWebGLData(webGL, 0, true);\n        webGL.lastIndex++;\n      }\n      if (data.type === _const.SHAPES.POLY) {\n        (0, _buildPoly2.default)(data, webGLData, webGLDataNativeLines);\n      }\n      if (data.type === _const.SHAPES.RECT) {\n        (0, _buildRectangle2.default)(data, webGLData, webGLDataNativeLines);\n      } else if (data.type === _const.SHAPES.CIRC || data.type === _const.SHAPES.ELIP) {\n        (0, _buildCircle2.default)(data, webGLData, webGLDataNativeLines);\n      } else if (data.type === _const.SHAPES.RREC) {\n        (0, _buildRoundedRectangle2.default)(data, webGLData, webGLDataNativeLines);\n      }\n      webGL.lastIndex++;\n    }\n    this.renderer.bindVao(null);\n\n    // upload all the dirty data...\n    for (var _i2 = 0; _i2 < webGL.data.length; _i2++) {\n      webGLData = webGL.data[_i2];\n      if (webGLData.dirty) {\n        webGLData.upload();\n      }\n    }\n  };\n\n  /**\n   *\n   * @private\n   * @param {WebGLRenderingContext} gl - the current WebGL drawing context\n   * @param {number} type - TODO @Alvin\n   * @param {number} nativeLines - indicate whether the webGLData use for nativeLines.\n   * @return {*} TODO\n   */\n\n  GraphicsRenderer.prototype.getWebGLData = function getWebGLData(gl, type, nativeLines) {\n    var webGLData = gl.data[gl.data.length - 1];\n    if (!webGLData || webGLData.nativeLines !== nativeLines || webGLData.points.length > 320000) {\n      webGLData = this.graphicsDataPool.pop() || new _WebGLGraphicsData2.default(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);\n      webGLData.nativeLines = nativeLines;\n      webGLData.reset(type);\n      gl.data.push(webGLData);\n    }\n    webGLData.dirty = true;\n    return webGLData;\n  };\n  return GraphicsRenderer;\n}(_ObjectRenderer3.default);\nexports.default = GraphicsRenderer;\n_WebGLRenderer2.default.registerPlugin('graphics', GraphicsRenderer);","map":{"version":3,"names":["_utils","require","_const","_ObjectRenderer2","_WebGLRenderer","_WebGLGraphicsData","_PrimitiveShader","_buildPoly","_buildRectangle","_buildRoundedRectangle","_buildCircle","GraphicsRenderer","renderer","_classCallCheck","_this","_possibleConstructorReturn","_ObjectRenderer","call","graphicsDataPool","primitiveShader","gl","CONTEXT_UID","onContextChange","_PrimitiveShader2","default","destroy","_ObjectRenderer3","prototype","i","length","render","graphics","webGLData","webGL","_webGL","dirty","updateGraphics","shader","bindShader","state","setBlendMode","blendMode","n","data","shaderTemp","uniforms","translationMatrix","transform","worldTransform","toArray","tint","hex2rgb","alpha","worldAlpha","bindVao","vao","nativeLines","drawArrays","LINES","points","draw","TRIANGLE_STRIP","indices","lastIndex","clearDirty","push","webGLDataNativeLines","_i","graphicsData","getWebGLData","lineWidth","type","SHAPES","POLY","_buildPoly2","RECT","_buildRectangle2","CIRC","ELIP","_buildCircle2","RREC","_buildRoundedRectangle2","_i2","upload","pop","_WebGLGraphicsData2","attribsState","reset","_WebGLRenderer2","registerPlugin"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/graphics/webgl/GraphicsRenderer.js"],"sourcesContent":["import { hex2rgb } from '../../utils';\nimport { SHAPES } from '../../const';\nimport ObjectRenderer from '../../renderers/webgl/utils/ObjectRenderer';\nimport WebGLRenderer from '../../renderers/webgl/WebGLRenderer';\nimport WebGLGraphicsData from './WebGLGraphicsData';\nimport PrimitiveShader from './shaders/PrimitiveShader';\n\nimport buildPoly from './utils/buildPoly';\nimport buildRectangle from './utils/buildRectangle';\nimport buildRoundedRectangle from './utils/buildRoundedRectangle';\nimport buildCircle from './utils/buildCircle';\n\n/**\n * Renders the graphics object.\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport default class GraphicsRenderer extends ObjectRenderer\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this object renderer works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.graphicsDataPool = [];\n\n        this.primitiveShader = null;\n\n        this.gl = renderer.gl;\n\n        // easy access!\n        this.CONTEXT_UID = 0;\n    }\n\n    /**\n     * Called when there is a WebGL context change\n     *\n     * @private\n     *\n     */\n    onContextChange()\n    {\n        this.gl = this.renderer.gl;\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n        this.primitiveShader = new PrimitiveShader(this.gl);\n    }\n\n    /**\n     * Destroys this renderer.\n     *\n     */\n    destroy()\n    {\n        ObjectRenderer.prototype.destroy.call(this);\n\n        for (let i = 0; i < this.graphicsDataPool.length; ++i)\n        {\n            this.graphicsDataPool[i].destroy();\n        }\n\n        this.graphicsDataPool = null;\n    }\n\n    /**\n     * Renders a graphics object.\n     *\n     * @param {PIXI.Graphics} graphics - The graphics object to render.\n     */\n    render(graphics)\n    {\n        const renderer = this.renderer;\n        const gl = renderer.gl;\n\n        let webGLData;\n        let webGL = graphics._webGL[this.CONTEXT_UID];\n\n        if (!webGL || graphics.dirty !== webGL.dirty)\n        {\n            this.updateGraphics(graphics);\n\n            webGL = graphics._webGL[this.CONTEXT_UID];\n        }\n\n        // This  could be speeded up for sure!\n        const shader = this.primitiveShader;\n\n        renderer.bindShader(shader);\n        renderer.state.setBlendMode(graphics.blendMode);\n\n        for (let i = 0, n = webGL.data.length; i < n; i++)\n        {\n            webGLData = webGL.data[i];\n            const shaderTemp = webGLData.shader;\n\n            renderer.bindShader(shaderTemp);\n            shaderTemp.uniforms.translationMatrix = graphics.transform.worldTransform.toArray(true);\n            shaderTemp.uniforms.tint = hex2rgb(graphics.tint);\n            shaderTemp.uniforms.alpha = graphics.worldAlpha;\n\n            renderer.bindVao(webGLData.vao);\n\n            if (webGLData.nativeLines)\n            {\n                gl.drawArrays(gl.LINES, 0, webGLData.points.length / 6);\n            }\n            else\n            {\n                webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length);\n            }\n        }\n    }\n\n    /**\n     * Updates the graphics object\n     *\n     * @private\n     * @param {PIXI.Graphics} graphics - The graphics object to update\n     */\n    updateGraphics(graphics)\n    {\n        const gl = this.renderer.gl;\n\n         // get the contexts graphics object\n        let webGL = graphics._webGL[this.CONTEXT_UID];\n\n        // if the graphics object does not exist in the webGL context time to create it!\n        if (!webGL)\n        {\n            webGL = graphics._webGL[this.CONTEXT_UID] = { lastIndex: 0, data: [], gl, clearDirty: -1, dirty: -1 };\n        }\n\n        // flag the graphics as not dirty as we are about to update it...\n        webGL.dirty = graphics.dirty;\n\n        // if the user cleared the graphics object we will need to clear every object\n        if (graphics.clearDirty !== webGL.clearDirty)\n        {\n            webGL.clearDirty = graphics.clearDirty;\n\n            // loop through and return all the webGLDatas to the object pool so than can be reused later on\n            for (let i = 0; i < webGL.data.length; i++)\n            {\n                this.graphicsDataPool.push(webGL.data[i]);\n            }\n\n            // clear the array and reset the index..\n            webGL.data.length = 0;\n            webGL.lastIndex = 0;\n        }\n\n        let webGLData;\n        let webGLDataNativeLines;\n\n        // loop through the graphics datas and construct each one..\n        // if the object is a complex fill then the new stencil buffer technique will be used\n        // other wise graphics objects will be pushed into a batch..\n        for (let i = webGL.lastIndex; i < graphics.graphicsData.length; i++)\n        {\n            const data = graphics.graphicsData[i];\n\n            // TODO - this can be simplified\n            webGLData = this.getWebGLData(webGL, 0);\n\n            if (data.nativeLines && data.lineWidth)\n            {\n                webGLDataNativeLines = this.getWebGLData(webGL, 0, true);\n                webGL.lastIndex++;\n            }\n\n            if (data.type === SHAPES.POLY)\n            {\n                buildPoly(data, webGLData, webGLDataNativeLines);\n            }\n            if (data.type === SHAPES.RECT)\n            {\n                buildRectangle(data, webGLData, webGLDataNativeLines);\n            }\n            else if (data.type === SHAPES.CIRC || data.type === SHAPES.ELIP)\n            {\n                buildCircle(data, webGLData, webGLDataNativeLines);\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                buildRoundedRectangle(data, webGLData, webGLDataNativeLines);\n            }\n\n            webGL.lastIndex++;\n        }\n\n        this.renderer.bindVao(null);\n\n        // upload all the dirty data...\n        for (let i = 0; i < webGL.data.length; i++)\n        {\n            webGLData = webGL.data[i];\n\n            if (webGLData.dirty)\n            {\n                webGLData.upload();\n            }\n        }\n    }\n\n    /**\n     *\n     * @private\n     * @param {WebGLRenderingContext} gl - the current WebGL drawing context\n     * @param {number} type - TODO @Alvin\n     * @param {number} nativeLines - indicate whether the webGLData use for nativeLines.\n     * @return {*} TODO\n     */\n    getWebGLData(gl, type, nativeLines)\n    {\n        let webGLData = gl.data[gl.data.length - 1];\n\n        if (!webGLData || webGLData.nativeLines !== nativeLines || webGLData.points.length > 320000)\n        {\n            webGLData = this.graphicsDataPool.pop()\n                || new WebGLGraphicsData(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);\n            webGLData.nativeLines = nativeLines;\n            webGLData.reset(type);\n            gl.data.push(webGLData);\n        }\n\n        webGLData.dirty = true;\n\n        return webGLData;\n    }\n}\n\nWebGLRenderer.registerPlugin('graphics', GraphicsRenderer);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}