{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _utils = require('../../utils');\nvar _canUseNewCanvasBlendModes = require('../../renderers/canvas/utils/canUseNewCanvasBlendModes');\nvar _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Utility methods for Sprite/Texture tinting.\n *\n * @class\n * @memberof PIXI\n */\nvar CanvasTinter = {\n  /**\n   * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Sprite} sprite - the sprite to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @return {HTMLCanvasElement} The tinted canvas\n   */\n  getTintedTexture: function getTintedTexture(sprite, color) {\n    var texture = sprite._texture;\n    color = CanvasTinter.roundColor(color);\n    var stringColor = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n    texture.tintCache = texture.tintCache || {};\n    var cachedTexture = texture.tintCache[stringColor];\n    var canvas = void 0;\n    if (cachedTexture) {\n      if (cachedTexture.tintId === texture._updateID) {\n        return texture.tintCache[stringColor];\n      }\n      canvas = texture.tintCache[stringColor];\n    } else {\n      canvas = CanvasTinter.canvas || document.createElement('canvas');\n    }\n    CanvasTinter.tintMethod(texture, color, canvas);\n    canvas.tintId = texture._updateID;\n    if (CanvasTinter.convertTintToImage) {\n      // is this better?\n      var tintImage = new Image();\n      tintImage.src = canvas.toDataURL();\n      texture.tintCache[stringColor] = tintImage;\n    } else {\n      texture.tintCache[stringColor] = canvas;\n      // if we are not converting the texture to an image then we need to lose the reference to the canvas\n      CanvasTinter.canvas = null;\n    }\n    return canvas;\n  },\n  /**\n   * Tint a texture using the 'multiply' operation.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Texture} texture - the texture to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @param {HTMLCanvasElement} canvas - the current canvas\n   */\n  tintWithMultiply: function tintWithMultiply(texture, color, canvas) {\n    var context = canvas.getContext('2d');\n    var crop = texture._frame.clone();\n    var resolution = texture.baseTexture.resolution;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    canvas.width = Math.ceil(crop.width);\n    canvas.height = Math.ceil(crop.height);\n    context.save();\n    context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, crop.width, crop.height);\n    context.globalCompositeOperation = 'multiply';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n    context.globalCompositeOperation = 'destination-atop';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n    context.restore();\n  },\n  /**\n   * Tint a texture using the 'overlay' operation.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Texture} texture - the texture to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @param {HTMLCanvasElement} canvas - the current canvas\n   */\n  tintWithOverlay: function tintWithOverlay(texture, color, canvas) {\n    var context = canvas.getContext('2d');\n    var crop = texture._frame.clone();\n    var resolution = texture.baseTexture.resolution;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    canvas.width = Math.ceil(crop.width);\n    canvas.height = Math.ceil(crop.height);\n    context.save();\n    context.globalCompositeOperation = 'copy';\n    context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, crop.width, crop.height);\n    context.globalCompositeOperation = 'destination-atop';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n\n    // context.globalCompositeOperation = 'copy';\n    context.restore();\n  },\n  /**\n   * Tint a texture pixel per pixel.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Texture} texture - the texture to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @param {HTMLCanvasElement} canvas - the current canvas\n   */\n  tintWithPerPixel: function tintWithPerPixel(texture, color, canvas) {\n    var context = canvas.getContext('2d');\n    var crop = texture._frame.clone();\n    var resolution = texture.baseTexture.resolution;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    canvas.width = Math.ceil(crop.width);\n    canvas.height = Math.ceil(crop.height);\n    context.save();\n    context.globalCompositeOperation = 'copy';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n    context.restore();\n    var rgbValues = (0, _utils.hex2rgb)(color);\n    var r = rgbValues[0];\n    var g = rgbValues[1];\n    var b = rgbValues[2];\n    var pixelData = context.getImageData(0, 0, crop.width, crop.height);\n    var pixels = pixelData.data;\n    for (var i = 0; i < pixels.length; i += 4) {\n      pixels[i + 0] *= r;\n      pixels[i + 1] *= g;\n      pixels[i + 2] *= b;\n    }\n    context.putImageData(pixelData, 0, 0);\n  },\n  /**\n   * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {number} color - the color to round, should be a hex color\n   * @return {number} The rounded color.\n   */\n  roundColor: function roundColor(color) {\n    var step = CanvasTinter.cacheStepsPerColorChannel;\n    var rgbValues = (0, _utils.hex2rgb)(color);\n    rgbValues[0] = Math.min(255, rgbValues[0] / step * step);\n    rgbValues[1] = Math.min(255, rgbValues[1] / step * step);\n    rgbValues[2] = Math.min(255, rgbValues[2] / step * step);\n    return (0, _utils.rgb2hex)(rgbValues);\n  },\n  /**\n   * Number of steps which will be used as a cap when rounding colors.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {number}\n   */\n  cacheStepsPerColorChannel: 8,\n  /**\n   * Tint cache boolean flag.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {boolean}\n   */\n  convertTintToImage: false,\n  /**\n   * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {boolean}\n   */\n  canUseMultiply: (0, _canUseNewCanvasBlendModes2.default)(),\n  /**\n   * The tinting method that will be used.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {tintMethodFunctionType}\n   */\n  tintMethod: 0\n};\nCanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;\n\n/**\n * The tintMethod type.\n *\n * @memberof PIXI.CanvasTinter\n * @callback tintMethodFunctionType\n * @param texture {PIXI.Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\n\nexports.default = CanvasTinter;","map":{"version":3,"names":["_utils","require","_canUseNewCanvasBlendModes","CanvasTinter","getTintedTexture","sprite","color","texture","_texture","roundColor","stringColor","toString","substr","tintCache","cachedTexture","canvas","tintId","_updateID","document","createElement","tintMethod","convertTintToImage","tintImage","Image","src","toDataURL","tintWithMultiply","context","getContext","crop","_frame","clone","resolution","baseTexture","x","y","width","height","Math","ceil","save","fillStyle","fillRect","globalCompositeOperation","drawImage","source","restore","tintWithOverlay","tintWithPerPixel","rgbValues","hex2rgb","r","g","b","pixelData","getImageData","pixels","data","i","length","putImageData","step","cacheStepsPerColorChannel","min","rgb2hex","canUseMultiply","_canUseNewCanvasBlendModes2","default"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/sprites/canvas/CanvasTinter.js"],"sourcesContent":["import { hex2rgb, rgb2hex } from '../../utils';\nimport canUseNewCanvasBlendModes from '../../renderers/canvas/utils/canUseNewCanvasBlendModes';\n\n/**\n * Utility methods for Sprite/Texture tinting.\n *\n * @class\n * @memberof PIXI\n */\nconst CanvasTinter = {\n    /**\n     * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Sprite} sprite - the sprite to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @return {HTMLCanvasElement} The tinted canvas\n     */\n    getTintedTexture: (sprite, color) =>\n    {\n        const texture = sprite._texture;\n\n        color = CanvasTinter.roundColor(color);\n\n        const stringColor = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n\n        texture.tintCache = texture.tintCache || {};\n\n        const cachedTexture = texture.tintCache[stringColor];\n\n        let canvas;\n\n        if (cachedTexture)\n        {\n            if (cachedTexture.tintId === texture._updateID)\n            {\n                return texture.tintCache[stringColor];\n            }\n\n            canvas = texture.tintCache[stringColor];\n        }\n        else\n        {\n            canvas = CanvasTinter.canvas || document.createElement('canvas');\n        }\n\n        CanvasTinter.tintMethod(texture, color, canvas);\n\n        canvas.tintId = texture._updateID;\n\n        if (CanvasTinter.convertTintToImage)\n        {\n            // is this better?\n            const tintImage = new Image();\n\n            tintImage.src = canvas.toDataURL();\n\n            texture.tintCache[stringColor] = tintImage;\n        }\n        else\n        {\n            texture.tintCache[stringColor] = canvas;\n            // if we are not converting the texture to an image then we need to lose the reference to the canvas\n            CanvasTinter.canvas = null;\n        }\n\n        return canvas;\n    },\n\n    /**\n     * Tint a texture using the 'multiply' operation.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithMultiply: (texture, color, canvas) =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.save();\n        context.fillStyle = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n\n        context.fillRect(0, 0, crop.width, crop.height);\n\n        context.globalCompositeOperation = 'multiply';\n\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        context.globalCompositeOperation = 'destination-atop';\n\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n        context.restore();\n    },\n\n    /**\n     * Tint a texture using the 'overlay' operation.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithOverlay(texture, color, canvas)\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.save();\n        context.globalCompositeOperation = 'copy';\n        context.fillStyle = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n        context.fillRect(0, 0, crop.width, crop.height);\n\n        context.globalCompositeOperation = 'destination-atop';\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        // context.globalCompositeOperation = 'copy';\n        context.restore();\n    },\n\n    /**\n     * Tint a texture pixel per pixel.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithPerPixel: (texture, color, canvas) =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.save();\n        context.globalCompositeOperation = 'copy';\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n        context.restore();\n\n        const rgbValues = hex2rgb(color);\n        const r = rgbValues[0];\n        const g = rgbValues[1];\n        const b = rgbValues[2];\n\n        const pixelData = context.getImageData(0, 0, crop.width, crop.height);\n\n        const pixels = pixelData.data;\n\n        for (let i = 0; i < pixels.length; i += 4)\n        {\n            pixels[i + 0] *= r;\n            pixels[i + 1] *= g;\n            pixels[i + 2] *= b;\n        }\n\n        context.putImageData(pixelData, 0, 0);\n    },\n\n    /**\n     * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {number} color - the color to round, should be a hex color\n     * @return {number} The rounded color.\n     */\n    roundColor: (color) =>\n    {\n        const step = CanvasTinter.cacheStepsPerColorChannel;\n\n        const rgbValues = hex2rgb(color);\n\n        rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);\n        rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);\n        rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);\n\n        return rgb2hex(rgbValues);\n    },\n\n    /**\n     * Number of steps which will be used as a cap when rounding colors.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {number}\n     */\n    cacheStepsPerColorChannel: 8,\n\n    /**\n     * Tint cache boolean flag.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {boolean}\n     */\n    convertTintToImage: false,\n\n    /**\n     * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {boolean}\n     */\n    canUseMultiply: canUseNewCanvasBlendModes(),\n\n    /**\n     * The tinting method that will be used.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {tintMethodFunctionType}\n     */\n    tintMethod: 0,\n};\n\nCanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;\n\n/**\n * The tintMethod type.\n *\n * @memberof PIXI.CanvasTinter\n * @callback tintMethodFunctionType\n * @param texture {PIXI.Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\n\nexport default CanvasTinter;\n"],"mappings":";;;AAAA,IAAAA,MAAA,GAAAC,OAAA;AACA,IAAAC,0BAAA,GAAAD,OAAA;;;;;;;;AAEA;;;;;;AAMA,IAAME,YAAA,GAAe;EACjB;;;;;;;;EAQAC,gBAAA,EAAkB,SAAAA,iBAACC,MAAD,EAASC,KAAT,EAClB;IACI,IAAMC,OAAA,GAAUF,MAAA,CAAOG,QAAvB;IAEAF,KAAA,GAAQH,YAAA,CAAaM,UAAb,CAAwBH,KAAxB,CAAR;IAEA,IAAMI,WAAA,SAAkB,WAAS,CAACJ,KAAA,GAAQ,CAAT,EAAYK,QAAZ,CAAqB,EAArB,CAAT,EAAqCC,MAArC,CAA4C,CAAC,CAA7C,CAAxB;IAEAL,OAAA,CAAQM,SAAR,GAAoBN,OAAA,CAAQM,SAAR,IAAqB,EAAzC;IAEA,IAAMC,aAAA,GAAgBP,OAAA,CAAQM,SAAR,CAAkBH,WAAlB,CAAtB;IAEA,IAAIK,MAAA,SAAJ;IAEA,IAAID,aAAJ,EACA;MACI,IAAIA,aAAA,CAAcE,MAAd,KAAyBT,OAAA,CAAQU,SAArC,EACA;QACI,OAAOV,OAAA,CAAQM,SAAR,CAAkBH,WAAlB,CAAP;MACH;MAEDK,MAAA,GAASR,OAAA,CAAQM,SAAR,CAAkBH,WAAlB,CAAT;IACH,CARD,MAUA;MACIK,MAAA,GAASZ,YAAA,CAAaY,MAAb,IAAuBG,QAAA,CAASC,aAAT,CAAuB,QAAvB,CAAhC;IACH;IAEDhB,YAAA,CAAaiB,UAAb,CAAwBb,OAAxB,EAAiCD,KAAjC,EAAwCS,MAAxC;IAEAA,MAAA,CAAOC,MAAP,GAAgBT,OAAA,CAAQU,SAAxB;IAEA,IAAId,YAAA,CAAakB,kBAAjB,EACA;MACI;MACA,IAAMC,SAAA,GAAY,IAAIC,KAAJ,EAAlB;MAEAD,SAAA,CAAUE,GAAV,GAAgBT,MAAA,CAAOU,SAAP,EAAhB;MAEAlB,OAAA,CAAQM,SAAR,CAAkBH,WAAlB,IAAiCY,SAAjC;IACH,CARD,MAUA;MACIf,OAAA,CAAQM,SAAR,CAAkBH,WAAlB,IAAiCK,MAAjC;MACA;MACAZ,YAAA,CAAaY,MAAb,GAAsB,IAAtB;IACH;IAED,OAAOA,MAAP;EACH,CA1DgB;EA4DjB;;;;;;;;EAQAW,gBAAA,EAAkB,SAAAA,iBAACnB,OAAD,EAAUD,KAAV,EAAiBS,MAAjB,EAClB;IACI,IAAMY,OAAA,GAAUZ,MAAA,CAAOa,UAAP,CAAkB,IAAlB,CAAhB;IACA,IAAMC,IAAA,GAAOtB,OAAA,CAAQuB,MAAR,CAAeC,KAAf,EAAb;IACA,IAAMC,UAAA,GAAazB,OAAA,CAAQ0B,WAAR,CAAoBD,UAAvC;IAEAH,IAAA,CAAKK,CAAL,IAAUF,UAAV;IACAH,IAAA,CAAKM,CAAL,IAAUH,UAAV;IACAH,IAAA,CAAKO,KAAL,IAAcJ,UAAd;IACAH,IAAA,CAAKQ,MAAL,IAAeL,UAAf;IAEAjB,MAAA,CAAOqB,KAAP,GAAeE,IAAA,CAAKC,IAAL,CAAUV,IAAA,CAAKO,KAAf,CAAf;IACArB,MAAA,CAAOsB,MAAP,GAAgBC,IAAA,CAAKC,IAAL,CAAUV,IAAA,CAAKQ,MAAf,CAAhB;IAEAV,OAAA,CAAQa,IAAR;IACAb,OAAA,CAAQc,SAAR,SAAwB,WAAS,CAACnC,KAAA,GAAQ,CAAT,EAAYK,QAAZ,CAAqB,EAArB,CAAT,EAAqCC,MAArC,CAA4C,CAAC,CAA7C,CAAxB;IAEAe,OAAA,CAAQe,QAAR,CAAiB,CAAjB,EAAoB,CAApB,EAAuBb,IAAA,CAAKO,KAA5B,EAAmCP,IAAA,CAAKQ,MAAxC;IAEAV,OAAA,CAAQgB,wBAAR,GAAmC,UAAnC;IAEAhB,OAAA,CAAQiB,SAAR,CACIrC,OAAA,CAAQ0B,WAAR,CAAoBY,MADxB,EAEIhB,IAAA,CAAKK,CAFT,EAGIL,IAAA,CAAKM,CAHT,EAIIN,IAAA,CAAKO,KAJT,EAKIP,IAAA,CAAKQ,MALT,EAMI,CANJ,EAOI,CAPJ,EAQIR,IAAA,CAAKO,KART,EASIP,IAAA,CAAKQ,MATT;IAYAV,OAAA,CAAQgB,wBAAR,GAAmC,kBAAnC;IAEAhB,OAAA,CAAQiB,SAAR,CACIrC,OAAA,CAAQ0B,WAAR,CAAoBY,MADxB,EAEIhB,IAAA,CAAKK,CAFT,EAGIL,IAAA,CAAKM,CAHT,EAIIN,IAAA,CAAKO,KAJT,EAKIP,IAAA,CAAKQ,MALT,EAMI,CANJ,EAOI,CAPJ,EAQIR,IAAA,CAAKO,KART,EASIP,IAAA,CAAKQ,MATT;IAWAV,OAAA,CAAQmB,OAAR;EACH,CAnHgB;EAqHjB;;;;;;;;EAQAC,eA7HiB,WAAAA,gBA6HDxC,OA7HC,EA6HQD,KA7HR,EA6HeS,MA7Hf,EA8HjB;IACI,IAAMY,OAAA,GAAUZ,MAAA,CAAOa,UAAP,CAAkB,IAAlB,CAAhB;IACA,IAAMC,IAAA,GAAOtB,OAAA,CAAQuB,MAAR,CAAeC,KAAf,EAAb;IACA,IAAMC,UAAA,GAAazB,OAAA,CAAQ0B,WAAR,CAAoBD,UAAvC;IAEAH,IAAA,CAAKK,CAAL,IAAUF,UAAV;IACAH,IAAA,CAAKM,CAAL,IAAUH,UAAV;IACAH,IAAA,CAAKO,KAAL,IAAcJ,UAAd;IACAH,IAAA,CAAKQ,MAAL,IAAeL,UAAf;IAEAjB,MAAA,CAAOqB,KAAP,GAAeE,IAAA,CAAKC,IAAL,CAAUV,IAAA,CAAKO,KAAf,CAAf;IACArB,MAAA,CAAOsB,MAAP,GAAgBC,IAAA,CAAKC,IAAL,CAAUV,IAAA,CAAKQ,MAAf,CAAhB;IAEAV,OAAA,CAAQa,IAAR;IACAb,OAAA,CAAQgB,wBAAR,GAAmC,MAAnC;IACAhB,OAAA,CAAQc,SAAR,SAAwB,WAAS,CAACnC,KAAA,GAAQ,CAAT,EAAYK,QAAZ,CAAqB,EAArB,CAAT,EAAqCC,MAArC,CAA4C,CAAC,CAA7C,CAAxB;IACAe,OAAA,CAAQe,QAAR,CAAiB,CAAjB,EAAoB,CAApB,EAAuBb,IAAA,CAAKO,KAA5B,EAAmCP,IAAA,CAAKQ,MAAxC;IAEAV,OAAA,CAAQgB,wBAAR,GAAmC,kBAAnC;IACAhB,OAAA,CAAQiB,SAAR,CACIrC,OAAA,CAAQ0B,WAAR,CAAoBY,MADxB,EAEIhB,IAAA,CAAKK,CAFT,EAGIL,IAAA,CAAKM,CAHT,EAIIN,IAAA,CAAKO,KAJT,EAKIP,IAAA,CAAKQ,MALT,EAMI,CANJ,EAOI,CAPJ,EAQIR,IAAA,CAAKO,KART,EASIP,IAAA,CAAKQ,MATT;;IAYA;IACAV,OAAA,CAAQmB,OAAR;EACH,CA/JgB;EAiKjB;;;;;;;;EAQAE,gBAAA,EAAkB,SAAAA,iBAACzC,OAAD,EAAUD,KAAV,EAAiBS,MAAjB,EAClB;IACI,IAAMY,OAAA,GAAUZ,MAAA,CAAOa,UAAP,CAAkB,IAAlB,CAAhB;IACA,IAAMC,IAAA,GAAOtB,OAAA,CAAQuB,MAAR,CAAeC,KAAf,EAAb;IACA,IAAMC,UAAA,GAAazB,OAAA,CAAQ0B,WAAR,CAAoBD,UAAvC;IAEAH,IAAA,CAAKK,CAAL,IAAUF,UAAV;IACAH,IAAA,CAAKM,CAAL,IAAUH,UAAV;IACAH,IAAA,CAAKO,KAAL,IAAcJ,UAAd;IACAH,IAAA,CAAKQ,MAAL,IAAeL,UAAf;IAEAjB,MAAA,CAAOqB,KAAP,GAAeE,IAAA,CAAKC,IAAL,CAAUV,IAAA,CAAKO,KAAf,CAAf;IACArB,MAAA,CAAOsB,MAAP,GAAgBC,IAAA,CAAKC,IAAL,CAAUV,IAAA,CAAKQ,MAAf,CAAhB;IAEAV,OAAA,CAAQa,IAAR;IACAb,OAAA,CAAQgB,wBAAR,GAAmC,MAAnC;IACAhB,OAAA,CAAQiB,SAAR,CACIrC,OAAA,CAAQ0B,WAAR,CAAoBY,MADxB,EAEIhB,IAAA,CAAKK,CAFT,EAGIL,IAAA,CAAKM,CAHT,EAIIN,IAAA,CAAKO,KAJT,EAKIP,IAAA,CAAKQ,MALT,EAMI,CANJ,EAOI,CAPJ,EAQIR,IAAA,CAAKO,KART,EASIP,IAAA,CAAKQ,MATT;IAWAV,OAAA,CAAQmB,OAAR;IAEA,IAAMG,SAAA,GAAY,IAAAjD,MAAA,CAAAkD,OAAA,EAAQ5C,KAAR,CAAlB;IACA,IAAM6C,CAAA,GAAIF,SAAA,CAAU,CAAV,CAAV;IACA,IAAMG,CAAA,GAAIH,SAAA,CAAU,CAAV,CAAV;IACA,IAAMI,CAAA,GAAIJ,SAAA,CAAU,CAAV,CAAV;IAEA,IAAMK,SAAA,GAAY3B,OAAA,CAAQ4B,YAAR,CAAqB,CAArB,EAAwB,CAAxB,EAA2B1B,IAAA,CAAKO,KAAhC,EAAuCP,IAAA,CAAKQ,MAA5C,CAAlB;IAEA,IAAMmB,MAAA,GAASF,SAAA,CAAUG,IAAzB;IAEA,KAAK,IAAIC,CAAA,GAAI,CAAb,EAAgBA,CAAA,GAAIF,MAAA,CAAOG,MAA3B,EAAmCD,CAAA,IAAK,CAAxC,EACA;MACIF,MAAA,CAAOE,CAAA,GAAI,CAAX,KAAiBP,CAAjB;MACAK,MAAA,CAAOE,CAAA,GAAI,CAAX,KAAiBN,CAAjB;MACAI,MAAA,CAAOE,CAAA,GAAI,CAAX,KAAiBL,CAAjB;IACH;IAED1B,OAAA,CAAQiC,YAAR,CAAqBN,SAArB,EAAgC,CAAhC,EAAmC,CAAnC;EACH,CAvNgB;EAyNjB;;;;;;;EAOA7C,UAAA,EAAY,SAAAA,WAACH,KAAD,EACZ;IACI,IAAMuD,IAAA,GAAO1D,YAAA,CAAa2D,yBAA1B;IAEA,IAAMb,SAAA,GAAY,IAAAjD,MAAA,CAAAkD,OAAA,EAAQ5C,KAAR,CAAlB;IAEA2C,SAAA,CAAU,CAAV,IAAeX,IAAA,CAAKyB,GAAL,CAAS,GAAT,EAAed,SAAA,CAAU,CAAV,IAAeY,IAAhB,GAAwBA,IAAtC,CAAf;IACAZ,SAAA,CAAU,CAAV,IAAeX,IAAA,CAAKyB,GAAL,CAAS,GAAT,EAAed,SAAA,CAAU,CAAV,IAAeY,IAAhB,GAAwBA,IAAtC,CAAf;IACAZ,SAAA,CAAU,CAAV,IAAeX,IAAA,CAAKyB,GAAL,CAAS,GAAT,EAAed,SAAA,CAAU,CAAV,IAAeY,IAAhB,GAAwBA,IAAtC,CAAf;IAEA,OAAO,IAAA7D,MAAA,CAAAgE,OAAA,EAAQf,SAAR,CAAP;EACH,CA3OgB;EA6OjB;;;;;;EAMAa,yBAAA,EAA2B,CAnPV;EAqPjB;;;;;;EAMAzC,kBAAA,EAAoB,KA3PH;EA6PjB;;;;;;EAMA4C,cAAA,EAAgB,IAAAC,2BAAA,CAAAC,OAAA,GAnQC;EAqQjB;;;;;;EAMA/C,UAAA,EAAY;AA3QK,CAArB;AA8QAjB,YAAA,CAAaiB,UAAb,GAA0BjB,YAAA,CAAa8D,cAAb,GAA8B9D,YAAA,CAAauB,gBAA3C,GAA8DvB,YAAA,CAAa6C,gBAArG;;AAEA;;;;;;;;;;kBAUe7C,Y"},"metadata":{},"sourceType":"script","externalDependencies":[]}