{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _core = require('../../core');\nvar core = _interopRequireWildcard(_core);\nvar _const = require('../../core/const');\nvar _path = require('path');\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar tempMat = new core.Matrix();\n\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI.extras\n * @extends PIXI.ObjectRenderer\n */\n\nvar TilingSpriteRenderer = function (_core$ObjectRenderer) {\n  _inherits(TilingSpriteRenderer, _core$ObjectRenderer);\n\n  /**\n   * constructor for renderer\n   *\n   * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.\n   */\n  function TilingSpriteRenderer(renderer) {\n    _classCallCheck(this, TilingSpriteRenderer);\n    var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));\n    _this.shader = null;\n    _this.simpleShader = null;\n    _this.quad = null;\n    return _this;\n  }\n\n  /**\n   * Sets up the renderer context and necessary buffers.\n   *\n   * @private\n   */\n\n  TilingSpriteRenderer.prototype.onContextChange = function onContextChange() {\n    var gl = this.renderer.gl;\n    this.shader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n', 'varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    vec4 sample = texture2D(uSampler, coord);\\n    gl_FragColor = sample * uColor;\\n}\\n');\n    this.simpleShader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n', 'varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec4 sample = texture2D(uSampler, vTextureCoord);\\n    gl_FragColor = sample * uColor;\\n}\\n');\n    this.renderer.bindVao(null);\n    this.quad = new core.Quad(gl, this.renderer.state.attribState);\n    this.quad.initVao(this.shader);\n  };\n\n  /**\n   *\n   * @param {PIXI.extras.TilingSprite} ts tilingSprite to be rendered\n   */\n\n  TilingSpriteRenderer.prototype.render = function render(ts) {\n    var renderer = this.renderer;\n    var quad = this.quad;\n    renderer.bindVao(quad.vao);\n    var vertices = quad.vertices;\n    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;\n    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n    vertices[2] = vertices[4] = ts._width * (1.0 - ts.anchor.x);\n    vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n    if (ts.uvRespectAnchor) {\n      vertices = quad.uvs;\n      vertices[0] = vertices[6] = -ts.anchor.x;\n      vertices[1] = vertices[3] = -ts.anchor.y;\n      vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\n      vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\n    }\n    quad.upload();\n    var tex = ts._texture;\n    var baseTex = tex.baseTexture;\n    var lt = ts.tileTransform.localTransform;\n    var uv = ts.uvTransform;\n    var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n    // auto, force repeat wrapMode for big tiling textures\n    if (isSimple) {\n      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n        if (baseTex.wrapMode === _const.WRAP_MODES.CLAMP) {\n          baseTex.wrapMode = _const.WRAP_MODES.REPEAT;\n        }\n      } else {\n        isSimple = baseTex.wrapMode !== _const.WRAP_MODES.CLAMP;\n      }\n    }\n    var shader = isSimple ? this.simpleShader : this.shader;\n    renderer.bindShader(shader);\n    var w = tex.width;\n    var h = tex.height;\n    var W = ts._width;\n    var H = ts._height;\n    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\n\n    // that part is the same as above:\n    // tempMat.identity();\n    // tempMat.scale(tex.width, tex.height);\n    // tempMat.prepend(lt);\n    // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n    tempMat.invert();\n    if (isSimple) {\n      tempMat.prepend(uv.mapCoord);\n    } else {\n      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n      shader.uniforms.uClampFrame = uv.uClampFrame;\n      shader.uniforms.uClampOffset = uv.uClampOffset;\n    }\n    shader.uniforms.uTransform = tempMat.toArray(true);\n    shader.uniforms.uColor = core.utils.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.premultipliedAlpha);\n    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n    shader.uniforms.uSampler = renderer.bindTexture(tex);\n    renderer.setBlendMode(core.utils.correctBlendMode(ts.blendMode, baseTex.premultipliedAlpha));\n    quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  };\n  return TilingSpriteRenderer;\n}(core.ObjectRenderer);\nexports.default = TilingSpriteRenderer;\ncore.WebGLRenderer.registerPlugin('tilingSprite', TilingSpriteRenderer);","map":{"version":3,"names":["_core","require","core","_const","_path","tempMat","Matrix","TilingSpriteRenderer","renderer","_classCallCheck","_this","_possibleConstructorReturn","_core$ObjectRenderer","call","shader","simpleShader","quad","onContextChange","gl","Shader","bindVao","Quad","state","attribState","initVao","render","ts","vao","vertices","_width","anchor","x","_height","y","uvRespectAnchor","uvs","upload","tex","_texture","baseTex","baseTexture","lt","tileTransform","localTransform","uv","uvTransform","isSimple","isPowerOfTwo","frame","width","height","_glTextures","CONTEXT_UID","wrapMode","WRAP_MODES","CLAMP","REPEAT","bindShader","w","h","W","H","set","a","b","c","d","tx","ty","invert","prepend","mapCoord","uniforms","uMapCoord","toArray","uClampFrame","uClampOffset","uTransform","uColor","utils","premultiplyTintToRgba","tint","worldAlpha","premultipliedAlpha","translationMatrix","transform","worldTransform","uSampler","bindTexture","setBlendMode","correctBlendMode","blendMode","draw","TRIANGLES","ObjectRenderer","WebGLRenderer","registerPlugin"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/extras/webgl/TilingSpriteRenderer.js"],"sourcesContent":["import * as core from '../../core';\nimport { WRAP_MODES } from '../../core/const';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\n\nconst tempMat = new core.Matrix();\n\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI.extras\n * @extends PIXI.ObjectRenderer\n */\nexport default class TilingSpriteRenderer extends core.ObjectRenderer\n{\n\n    /**\n     * constructor for renderer\n     *\n     * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.shader = null;\n        this.simpleShader = null;\n        this.quad = null;\n    }\n\n    /**\n     * Sets up the renderer context and necessary buffers.\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        this.shader = new core.Shader(gl,\n            readFileSync(join(__dirname, './tilingSprite.vert'), 'utf8'),\n            readFileSync(join(__dirname, './tilingSprite.frag'), 'utf8'));\n        this.simpleShader = new core.Shader(gl,\n            readFileSync(join(__dirname, './tilingSprite.vert'), 'utf8'),\n            readFileSync(join(__dirname, './tilingSprite_simple.frag'), 'utf8'));\n\n        this.renderer.bindVao(null);\n        this.quad = new core.Quad(gl, this.renderer.state.attribState);\n        this.quad.initVao(this.shader);\n    }\n\n    /**\n     *\n     * @param {PIXI.extras.TilingSprite} ts tilingSprite to be rendered\n     */\n    render(ts)\n    {\n        const renderer = this.renderer;\n        const quad = this.quad;\n\n        renderer.bindVao(quad.vao);\n\n        let vertices = quad.vertices;\n\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n        if (ts.uvRespectAnchor)\n        {\n            vertices = quad.uvs;\n\n            vertices[0] = vertices[6] = -ts.anchor.x;\n            vertices[1] = vertices[3] = -ts.anchor.y;\n\n            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\n            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\n        }\n\n        quad.upload();\n\n        const tex = ts._texture;\n        const baseTex = tex.baseTexture;\n        const lt = ts.tileTransform.localTransform;\n        const uv = ts.uvTransform;\n        let isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple)\n        {\n            if (!baseTex._glTextures[renderer.CONTEXT_UID])\n            {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else\n            {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n\n        const shader = isSimple ? this.simpleShader : this.shader;\n\n        renderer.bindShader(shader);\n\n        const w = tex.width;\n        const h = tex.height;\n        const W = ts._width;\n        const H = ts._height;\n\n        tempMat.set(lt.a * w / W,\n            lt.b * w / H,\n            lt.c * h / W,\n            lt.d * h / H,\n            lt.tx / W,\n            lt.ty / H);\n\n        // that part is the same as above:\n        // tempMat.identity();\n        // tempMat.scale(tex.width, tex.height);\n        // tempMat.prepend(lt);\n        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n        tempMat.invert();\n        if (isSimple)\n        {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else\n        {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = core.utils.premultiplyTintToRgba(ts.tint, ts.worldAlpha,\n            shader.uniforms.uColor, baseTex.premultipliedAlpha);\n        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n\n        shader.uniforms.uSampler = renderer.bindTexture(tex);\n\n        renderer.setBlendMode(core.utils.correctBlendMode(ts.blendMode, baseTex.premultipliedAlpha));\n\n        quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }\n}\n\ncore.WebGLRenderer.registerPlugin('tilingSprite', TilingSpriteRenderer);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}