{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _BaseTexture = require('./BaseTexture');\nvar _BaseTexture2 = _interopRequireDefault(_BaseTexture);\nvar _VideoBaseTexture = require('./VideoBaseTexture');\nvar _VideoBaseTexture2 = _interopRequireDefault(_VideoBaseTexture);\nvar _TextureUvs = require('./TextureUvs');\nvar _TextureUvs2 = _interopRequireDefault(_TextureUvs);\nvar _eventemitter = require('eventemitter3');\nvar _eventemitter2 = _interopRequireDefault(_eventemitter);\nvar _math = require('../math');\nvar _utils = require('../utils');\nvar _settings = require('../settings');\nvar _settings2 = _interopRequireDefault(_settings);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided\n * then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * let texture = PIXI.Texture.fromImage('assets/image.png');\n * let sprite1 = new PIXI.Sprite(texture);\n * let sprite2 = new PIXI.Sprite(texture);\n * ```\n *\n * Textures made from SVGs, loaded or not, cannot be used before the file finishes processing.\n * You can check for this by checking the sprite's _textureID property.\n * ```js\n * var texture = PIXI.Texture.fromImage('assets/image.svg');\n * var sprite1 = new PIXI.Sprite(texture);\n * //sprite1._textureID should not be undefined if the texture has finished processing the SVG file\n * ```\n * You can use a ticker or rAF to ensure your sprites load the finished textures after processing. See issue #3068.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\nvar Texture = function (_EventEmitter) {\n  _inherits(Texture, _EventEmitter);\n\n  /**\n   * @param {PIXI.BaseTexture} baseTexture - The base texture source to create the texture from\n   * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show\n   * @param {PIXI.Rectangle} [orig] - The area of original texture\n   * @param {PIXI.Rectangle} [trim] - Trimmed rectangle of original texture\n   * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}\n   * @param {PIXI.Point} [anchor] - Default anchor point used for sprite placement / rotation\n   */\n  function Texture(baseTexture, frame, orig, trim, rotate, anchor) {\n    _classCallCheck(this, Texture);\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * @member {boolean}\n     */\n    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));\n    _this.noFrame = false;\n    if (!frame) {\n      _this.noFrame = true;\n      frame = new _math.Rectangle(0, 0, 1, 1);\n    }\n    if (baseTexture instanceof Texture) {\n      baseTexture = baseTexture.baseTexture;\n    }\n\n    /**\n     * The base texture that this texture uses.\n     *\n     * @member {PIXI.BaseTexture}\n     */\n    _this.baseTexture = baseTexture;\n\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     *\n     * @member {PIXI.Rectangle}\n     */\n    _this._frame = frame;\n\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `_updateUvs()` after you change coordinates of `trim` manually.\n     *\n     * @member {PIXI.Rectangle}\n     */\n    _this.trim = trim;\n\n    /**\n     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n     *\n     * @member {boolean}\n     */\n    _this.valid = false;\n\n    /**\n     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)\n     *\n     * @member {boolean}\n     */\n    _this.requiresUpdate = false;\n\n    /**\n     * The WebGL UV data cache.\n     *\n     * @member {PIXI.TextureUvs}\n     * @private\n     */\n    _this._uvs = null;\n\n    /**\n     * This is the area of original texture, before it was put in atlas\n     *\n     * @member {PIXI.Rectangle}\n     */\n    _this.orig = orig || frame; // new Rectangle(0, 0, 1, 1);\n\n    _this._rotate = Number(rotate || 0);\n    if (rotate === true) {\n      // this is old texturepacker legacy, some games/libraries are passing \"true\" for rotated textures\n      _this._rotate = 2;\n    } else if (_this._rotate % 2 !== 0) {\n      throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');\n    }\n    if (baseTexture.hasLoaded) {\n      if (_this.noFrame) {\n        frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n\n        // if there is no frame we should monitor for any base texture changes..\n        baseTexture.on('update', _this.onBaseTextureUpdated, _this);\n      }\n      _this.frame = frame;\n    } else {\n      baseTexture.once('loaded', _this.onBaseTextureLoaded, _this);\n    }\n\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @member {PIXI.Point}\n     * @default {0,0}\n     */\n    _this.defaultAnchor = anchor ? new _math.Point(anchor.x, anchor.y) : new _math.Point(0, 0);\n\n    /**\n     * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.\n     *\n     * @event PIXI.Texture#update\n     * @protected\n     * @param {PIXI.Texture} texture - Instance of texture being updated.\n     */\n\n    _this._updateID = 0;\n\n    /**\n     * Contains data for uvs. May contain clamp settings and some matrices.\n     * Its a bit heavy, so by default that object is not created.\n     * @member {PIXI.TextureMatrix}\n     * @default null\n     */\n    _this.transform = null;\n\n    /**\n     * The ids under which this Texture has been added to the texture cache. This is\n     * automatically set as long as Texture.addToCache is used, but may not be set if a\n     * Texture is added directly to the TextureCache array.\n     *\n     * @member {string[]}\n     */\n    _this.textureCacheIds = [];\n    return _this;\n  }\n\n  /**\n   * Updates this texture on the gpu.\n   *\n   */\n\n  Texture.prototype.update = function update() {\n    this.baseTexture.update();\n  };\n\n  /**\n   * Called when the base texture is loaded\n   *\n   * @private\n   * @param {PIXI.BaseTexture} baseTexture - The base texture.\n   */\n\n  Texture.prototype.onBaseTextureLoaded = function onBaseTextureLoaded(baseTexture) {\n    this._updateID++;\n\n    // TODO this code looks confusing.. boo to abusing getters and setters!\n    if (this.noFrame) {\n      this.frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n    } else {\n      this.frame = this._frame;\n    }\n    this.baseTexture.on('update', this.onBaseTextureUpdated, this);\n    this.emit('update', this);\n  };\n\n  /**\n   * Called when the base texture is updated\n   *\n   * @private\n   * @param {PIXI.BaseTexture} baseTexture - The base texture.\n   */\n\n  Texture.prototype.onBaseTextureUpdated = function onBaseTextureUpdated(baseTexture) {\n    this._updateID++;\n    this._frame.width = baseTexture.width;\n    this._frame.height = baseTexture.height;\n    this.emit('update', this);\n  };\n\n  /**\n   * Destroys this texture\n   *\n   * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n   */\n\n  Texture.prototype.destroy = function destroy(destroyBase) {\n    if (this.baseTexture) {\n      if (destroyBase) {\n        // delete the texture if it exists in the texture cache..\n        // this only needs to be removed if the base texture is actually destroyed too..\n        if (_utils.TextureCache[this.baseTexture.imageUrl]) {\n          Texture.removeFromCache(this.baseTexture.imageUrl);\n        }\n        this.baseTexture.destroy();\n      }\n      this.baseTexture.off('update', this.onBaseTextureUpdated, this);\n      this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);\n      this.baseTexture = null;\n    }\n    this._frame = null;\n    this._uvs = null;\n    this.trim = null;\n    this.orig = null;\n    this.valid = false;\n    Texture.removeFromCache(this);\n    this.textureCacheIds = null;\n  };\n\n  /**\n   * Creates a new texture object that acts the same as this one.\n   *\n   * @return {PIXI.Texture} The new texture\n   */\n\n  Texture.prototype.clone = function clone() {\n    return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);\n  };\n\n  /**\n   * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.\n   */\n\n  Texture.prototype._updateUvs = function _updateUvs() {\n    if (!this._uvs) {\n      this._uvs = new _TextureUvs2.default();\n    }\n    this._uvs.set(this._frame, this.baseTexture, this.rotate);\n    this._updateID++;\n  };\n\n  /**\n   * Helper function that creates a Texture object from the given image url.\n   * If the image is not in the texture cache it will be  created and loaded.\n   *\n   * @static\n   * @param {string} imageUrl - The image url of the texture\n   * @param {boolean} [crossorigin] - Whether requests should be treated as crossorigin\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {number} [sourceScale=(auto)] - Scale for the original image, used with SVG images.\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n  Texture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {\n    var texture = _utils.TextureCache[imageUrl];\n    if (!texture) {\n      texture = new Texture(_BaseTexture2.default.fromImage(imageUrl, crossorigin, scaleMode, sourceScale));\n      Texture.addToCache(texture, imageUrl);\n    }\n    return texture;\n  };\n\n  /**\n   * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n   * The frame ids are created when a Texture packer file has been loaded\n   *\n   * @static\n   * @param {string} frameId - The frame Id of the texture in the cache\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n  Texture.fromFrame = function fromFrame(frameId) {\n    var texture = _utils.TextureCache[frameId];\n    if (!texture) {\n      throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache');\n    }\n    return texture;\n  };\n\n  /**\n   * Helper function that creates a new Texture based on the given canvas element.\n   *\n   * @static\n   * @param {HTMLCanvasElement} canvas - The canvas element source of the texture\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {string} [origin='canvas'] - A string origin of who created the base texture\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n  Texture.fromCanvas = function fromCanvas(canvas, scaleMode) {\n    var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'canvas';\n    return new Texture(_BaseTexture2.default.fromCanvas(canvas, scaleMode, origin));\n  };\n\n  /**\n   * Helper function that creates a new Texture based on the given video element.\n   *\n   * @static\n   * @param {HTMLVideoElement|string} video - The URL or actual element of the video\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n  Texture.fromVideo = function fromVideo(video, scaleMode, crossorigin, autoPlay) {\n    if (typeof video === 'string') {\n      return Texture.fromVideoUrl(video, scaleMode, crossorigin, autoPlay);\n    }\n    return new Texture(_VideoBaseTexture2.default.fromVideo(video, scaleMode, autoPlay));\n  };\n\n  /**\n   * Helper function that creates a new Texture based on the video url.\n   *\n   * @static\n   * @param {string} videoUrl - URL of the video\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n  Texture.fromVideoUrl = function fromVideoUrl(videoUrl, scaleMode, crossorigin, autoPlay) {\n    return new Texture(_VideoBaseTexture2.default.fromUrl(videoUrl, scaleMode, crossorigin, autoPlay));\n  };\n\n  /**\n   * Helper function that creates a new Texture based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   *\n   * @static\n   * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture}\n   *        source - Source to create texture from\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n  Texture.from = function from(source) {\n    // TODO auto detect cross origin..\n    // TODO pass in scale mode?\n    if (typeof source === 'string') {\n      var texture = _utils.TextureCache[source];\n      if (!texture) {\n        // check if its a video..\n        var isVideo = source.match(/\\.(mp4|webm|ogg|h264|avi|mov)$/) !== null;\n        if (isVideo) {\n          return Texture.fromVideoUrl(source);\n        }\n        return Texture.fromImage(source);\n      }\n      return texture;\n    } else if (source instanceof HTMLImageElement) {\n      return new Texture(_BaseTexture2.default.from(source));\n    } else if (source instanceof HTMLCanvasElement) {\n      return Texture.fromCanvas(source, _settings2.default.SCALE_MODE, 'HTMLCanvasElement');\n    } else if (source instanceof HTMLVideoElement) {\n      return Texture.fromVideo(source);\n    } else if (source instanceof _BaseTexture2.default) {\n      return new Texture(source);\n    }\n\n    // lets assume its a texture!\n    return source;\n  };\n\n  /**\n   * Create a texture from a source and add to the cache.\n   *\n   * @static\n   * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.\n   * @param {String} imageUrl - File name of texture, for cache and resolving resolution.\n   * @param {String} [name] - Human readible name for the texture cache. If no name is\n   *        specified, only `imageUrl` will be used as the cache ID.\n   * @return {PIXI.Texture} Output texture\n   */\n\n  Texture.fromLoader = function fromLoader(source, imageUrl, name) {\n    var baseTexture = new _BaseTexture2.default(source, undefined, (0, _utils.getResolutionOfUrl)(imageUrl));\n    var texture = new Texture(baseTexture);\n    baseTexture.imageUrl = imageUrl;\n\n    // No name, use imageUrl instead\n    if (!name) {\n      name = imageUrl;\n    }\n\n    // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions\n    _BaseTexture2.default.addToCache(texture.baseTexture, name);\n    Texture.addToCache(texture, name);\n\n    // also add references by url if they are different.\n    if (name !== imageUrl) {\n      _BaseTexture2.default.addToCache(texture.baseTexture, imageUrl);\n      Texture.addToCache(texture, imageUrl);\n    }\n    return texture;\n  };\n\n  /**\n   * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.\n   *\n   * @static\n   * @param {PIXI.Texture} texture - The Texture to add to the cache.\n   * @param {string} id - The id that the Texture will be stored against.\n   */\n\n  Texture.addToCache = function addToCache(texture, id) {\n    if (id) {\n      if (texture.textureCacheIds.indexOf(id) === -1) {\n        texture.textureCacheIds.push(id);\n      }\n\n      // @if DEBUG\n      /* eslint-disable no-console */\n      if (_utils.TextureCache[id]) {\n        console.warn('Texture added to the cache with an id [' + id + '] that already had an entry');\n      }\n      /* eslint-enable no-console */\n      // @endif\n\n      _utils.TextureCache[id] = texture;\n    }\n  };\n\n  /**\n   * Remove a Texture from the global TextureCache.\n   *\n   * @static\n   * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself\n   * @return {PIXI.Texture|null} The Texture that was removed\n   */\n\n  Texture.removeFromCache = function removeFromCache(texture) {\n    if (typeof texture === 'string') {\n      var textureFromCache = _utils.TextureCache[texture];\n      if (textureFromCache) {\n        var index = textureFromCache.textureCacheIds.indexOf(texture);\n        if (index > -1) {\n          textureFromCache.textureCacheIds.splice(index, 1);\n        }\n        delete _utils.TextureCache[texture];\n        return textureFromCache;\n      }\n    } else if (texture && texture.textureCacheIds) {\n      for (var i = 0; i < texture.textureCacheIds.length; ++i) {\n        // Check that texture matches the one being passed in before deleting it from the cache.\n        if (_utils.TextureCache[texture.textureCacheIds[i]] === texture) {\n          delete _utils.TextureCache[texture.textureCacheIds[i]];\n        }\n      }\n      texture.textureCacheIds.length = 0;\n      return texture;\n    }\n    return null;\n  };\n\n  /**\n   * The frame specifies the region of the base texture that this texture uses.\n   * Please call `_updateUvs()` after you change coordinates of `frame` manually.\n   *\n   * @member {PIXI.Rectangle}\n   */\n\n  _createClass(Texture, [{\n    key: 'frame',\n    get: function get() {\n      return this._frame;\n    },\n    set: function set(frame)\n    // eslint-disable-line require-jsdoc\n    {\n      this._frame = frame;\n      this.noFrame = false;\n      var x = frame.x,\n        y = frame.y,\n        width = frame.width,\n        height = frame.height;\n      var xNotFit = x + width > this.baseTexture.width;\n      var yNotFit = y + height > this.baseTexture.height;\n      if (xNotFit || yNotFit) {\n        var relationship = xNotFit && yNotFit ? 'and' : 'or';\n        var errorX = 'X: ' + x + ' + ' + width + ' = ' + (x + width) + ' > ' + this.baseTexture.width;\n        var errorY = 'Y: ' + y + ' + ' + height + ' = ' + (y + height) + ' > ' + this.baseTexture.height;\n        throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: ' + (errorX + ' ' + relationship + ' ' + errorY));\n      }\n\n      // this.valid = width && height && this.baseTexture.source && this.baseTexture.hasLoaded;\n      this.valid = width && height && this.baseTexture.hasLoaded;\n      if (!this.trim && !this.rotate) {\n        this.orig = frame;\n      }\n      if (this.valid) {\n        this._updateUvs();\n      }\n    }\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link PIXI.GroupD8} for explanation\n     *\n     * @member {number}\n     */\n  }, {\n    key: 'rotate',\n    get: function get() {\n      return this._rotate;\n    },\n    set: function set(rotate)\n    // eslint-disable-line require-jsdoc\n    {\n      this._rotate = rotate;\n      if (this.valid) {\n        this._updateUvs();\n      }\n    }\n\n    /**\n     * The width of the Texture in pixels.\n     *\n     * @member {number}\n     */\n  }, {\n    key: 'width',\n    get: function get() {\n      return this.orig.width;\n    }\n\n    /**\n     * The height of the Texture in pixels.\n     *\n     * @member {number}\n     */\n  }, {\n    key: 'height',\n    get: function get() {\n      return this.orig.height;\n    }\n  }]);\n  return Texture;\n}(_eventemitter2.default);\nexports.default = Texture;\nfunction createWhiteTexture() {\n  var canvas = document.createElement('canvas');\n  canvas.width = 10;\n  canvas.height = 10;\n  var context = canvas.getContext('2d');\n  context.fillStyle = 'white';\n  context.fillRect(0, 0, 10, 10);\n  return new Texture(new _BaseTexture2.default(canvas));\n}\nfunction removeAllHandlers(tex) {\n  tex.destroy = function _emptyDestroy() {/* empty */};\n  tex.on = function _emptyOn() {/* empty */};\n  tex.once = function _emptyOnce() {/* empty */};\n  tex.emit = function _emptyEmit() {/* empty */};\n}\n\n/**\n * An empty texture, used often to not have to create multiple empty textures.\n * Can not be destroyed.\n *\n * @static\n * @constant\n */\nTexture.EMPTY = new Texture(new _BaseTexture2.default());\nremoveAllHandlers(Texture.EMPTY);\nremoveAllHandlers(Texture.EMPTY.baseTexture);\n\n/**\n * A white texture of 10x10 size, used for graphics and other things\n * Can not be destroyed.\n *\n * @static\n * @constant\n */\nTexture.WHITE = createWhiteTexture();\nremoveAllHandlers(Texture.WHITE);\nremoveAllHandlers(Texture.WHITE.baseTexture);","map":{"version":3,"names":["_BaseTexture","require","_VideoBaseTexture","_TextureUvs","_eventemitter","_math","_utils","_settings","Texture","baseTexture","frame","orig","trim","rotate","anchor","_classCallCheck","_this","_possibleConstructorReturn","_EventEmitter","call","noFrame","Rectangle","_frame","valid","requiresUpdate","_uvs","_rotate","Number","Error","hasLoaded","width","height","on","onBaseTextureUpdated","once","onBaseTextureLoaded","defaultAnchor","Point","x","y","_updateID","transform","textureCacheIds","update","emit","destroy","destroyBase","TextureCache","imageUrl","removeFromCache","off","clone","_updateUvs","_TextureUvs2","default","set","fromImage","crossorigin","scaleMode","sourceScale","texture","_BaseTexture2","addToCache","fromFrame","frameId","fromCanvas","canvas","origin","arguments","length","undefined","fromVideo","video","autoPlay","fromVideoUrl","_VideoBaseTexture2","videoUrl","fromUrl","from","source","isVideo","match","HTMLImageElement","HTMLCanvasElement","_settings2","SCALE_MODE","HTMLVideoElement","fromLoader","name","getResolutionOfUrl","id","indexOf","push","console","warn","textureFromCache","index","splice","i","xNotFit","yNotFit","relationship","errorX","errorY","createWhiteTexture","document","createElement","context","getContext","fillStyle","fillRect","removeAllHandlers","tex","_emptyDestroy","_emptyOn","_emptyOnce","_emptyEmit","EMPTY","WHITE"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/textures/Texture.js"],"sourcesContent":["import BaseTexture from './BaseTexture';\nimport VideoBaseTexture from './VideoBaseTexture';\nimport TextureUvs from './TextureUvs';\nimport EventEmitter from 'eventemitter3';\nimport { Rectangle, Point } from '../math';\nimport { TextureCache, getResolutionOfUrl } from '../utils';\nimport settings from '../settings';\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided\n * then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * let texture = PIXI.Texture.fromImage('assets/image.png');\n * let sprite1 = new PIXI.Sprite(texture);\n * let sprite2 = new PIXI.Sprite(texture);\n * ```\n *\n * Textures made from SVGs, loaded or not, cannot be used before the file finishes processing.\n * You can check for this by checking the sprite's _textureID property.\n * ```js\n * var texture = PIXI.Texture.fromImage('assets/image.svg');\n * var sprite1 = new PIXI.Sprite(texture);\n * //sprite1._textureID should not be undefined if the texture has finished processing the SVG file\n * ```\n * You can use a ticker or rAF to ensure your sprites load the finished textures after processing. See issue #3068.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\nexport default class Texture extends EventEmitter\n{\n    /**\n     * @param {PIXI.BaseTexture} baseTexture - The base texture source to create the texture from\n     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show\n     * @param {PIXI.Rectangle} [orig] - The area of original texture\n     * @param {PIXI.Rectangle} [trim] - Trimmed rectangle of original texture\n     * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}\n     * @param {PIXI.Point} [anchor] - Default anchor point used for sprite placement / rotation\n     */\n    constructor(baseTexture, frame, orig, trim, rotate, anchor)\n    {\n        super();\n\n        /**\n         * Does this Texture have any frame data assigned to it?\n         *\n         * @member {boolean}\n         */\n        this.noFrame = false;\n\n        if (!frame)\n        {\n            this.noFrame = true;\n            frame = new Rectangle(0, 0, 1, 1);\n        }\n\n        if (baseTexture instanceof Texture)\n        {\n            baseTexture = baseTexture.baseTexture;\n        }\n\n        /**\n         * The base texture that this texture uses.\n         *\n         * @member {PIXI.BaseTexture}\n         */\n        this.baseTexture = baseTexture;\n\n        /**\n         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this._frame = frame;\n\n        /**\n         * This is the trimmed area of original texture, before it was put in atlas\n         * Please call `_updateUvs()` after you change coordinates of `trim` manually.\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.trim = trim;\n\n        /**\n         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n         *\n         * @member {boolean}\n         */\n        this.valid = false;\n\n        /**\n         * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)\n         *\n         * @member {boolean}\n         */\n        this.requiresUpdate = false;\n\n        /**\n         * The WebGL UV data cache.\n         *\n         * @member {PIXI.TextureUvs}\n         * @private\n         */\n        this._uvs = null;\n\n        /**\n         * This is the area of original texture, before it was put in atlas\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.orig = orig || frame;// new Rectangle(0, 0, 1, 1);\n\n        this._rotate = Number(rotate || 0);\n\n        if (rotate === true)\n        {\n            // this is old texturepacker legacy, some games/libraries are passing \"true\" for rotated textures\n            this._rotate = 2;\n        }\n        else if (this._rotate % 2 !== 0)\n        {\n            throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');\n        }\n\n        if (baseTexture.hasLoaded)\n        {\n            if (this.noFrame)\n            {\n                frame = new Rectangle(0, 0, baseTexture.width, baseTexture.height);\n\n                // if there is no frame we should monitor for any base texture changes..\n                baseTexture.on('update', this.onBaseTextureUpdated, this);\n            }\n            this.frame = frame;\n        }\n        else\n        {\n            baseTexture.once('loaded', this.onBaseTextureLoaded, this);\n        }\n\n        /**\n         * Anchor point that is used as default if sprite is created with this texture.\n         * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n         * @member {PIXI.Point}\n         * @default {0,0}\n         */\n        this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);\n\n        /**\n         * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.\n         *\n         * @event PIXI.Texture#update\n         * @protected\n         * @param {PIXI.Texture} texture - Instance of texture being updated.\n         */\n\n        this._updateID = 0;\n\n        /**\n         * Contains data for uvs. May contain clamp settings and some matrices.\n         * Its a bit heavy, so by default that object is not created.\n         * @member {PIXI.TextureMatrix}\n         * @default null\n         */\n        this.transform = null;\n\n        /**\n         * The ids under which this Texture has been added to the texture cache. This is\n         * automatically set as long as Texture.addToCache is used, but may not be set if a\n         * Texture is added directly to the TextureCache array.\n         *\n         * @member {string[]}\n         */\n        this.textureCacheIds = [];\n    }\n\n    /**\n     * Updates this texture on the gpu.\n     *\n     */\n    update()\n    {\n        this.baseTexture.update();\n    }\n\n    /**\n     * Called when the base texture is loaded\n     *\n     * @private\n     * @param {PIXI.BaseTexture} baseTexture - The base texture.\n     */\n    onBaseTextureLoaded(baseTexture)\n    {\n        this._updateID++;\n\n        // TODO this code looks confusing.. boo to abusing getters and setters!\n        if (this.noFrame)\n        {\n            this.frame = new Rectangle(0, 0, baseTexture.width, baseTexture.height);\n        }\n        else\n        {\n            this.frame = this._frame;\n        }\n\n        this.baseTexture.on('update', this.onBaseTextureUpdated, this);\n        this.emit('update', this);\n    }\n\n    /**\n     * Called when the base texture is updated\n     *\n     * @private\n     * @param {PIXI.BaseTexture} baseTexture - The base texture.\n     */\n    onBaseTextureUpdated(baseTexture)\n    {\n        this._updateID++;\n\n        this._frame.width = baseTexture.width;\n        this._frame.height = baseTexture.height;\n\n        this.emit('update', this);\n    }\n\n    /**\n     * Destroys this texture\n     *\n     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n     */\n    destroy(destroyBase)\n    {\n        if (this.baseTexture)\n        {\n            if (destroyBase)\n            {\n                // delete the texture if it exists in the texture cache..\n                // this only needs to be removed if the base texture is actually destroyed too..\n                if (TextureCache[this.baseTexture.imageUrl])\n                {\n                    Texture.removeFromCache(this.baseTexture.imageUrl);\n                }\n\n                this.baseTexture.destroy();\n            }\n\n            this.baseTexture.off('update', this.onBaseTextureUpdated, this);\n            this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);\n\n            this.baseTexture = null;\n        }\n\n        this._frame = null;\n        this._uvs = null;\n        this.trim = null;\n        this.orig = null;\n\n        this.valid = false;\n\n        Texture.removeFromCache(this);\n        this.textureCacheIds = null;\n    }\n\n    /**\n     * Creates a new texture object that acts the same as this one.\n     *\n     * @return {PIXI.Texture} The new texture\n     */\n    clone()\n    {\n        return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);\n    }\n\n    /**\n     * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.\n     */\n    _updateUvs()\n    {\n        if (!this._uvs)\n        {\n            this._uvs = new TextureUvs();\n        }\n\n        this._uvs.set(this._frame, this.baseTexture, this.rotate);\n\n        this._updateID++;\n    }\n\n    /**\n     * Helper function that creates a Texture object from the given image url.\n     * If the image is not in the texture cache it will be  created and loaded.\n     *\n     * @static\n     * @param {string} imageUrl - The image url of the texture\n     * @param {boolean} [crossorigin] - Whether requests should be treated as crossorigin\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with SVG images.\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromImage(imageUrl, crossorigin, scaleMode, sourceScale)\n    {\n        let texture = TextureCache[imageUrl];\n\n        if (!texture)\n        {\n            texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode, sourceScale));\n            Texture.addToCache(texture, imageUrl);\n        }\n\n        return texture;\n    }\n\n    /**\n     * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n     * The frame ids are created when a Texture packer file has been loaded\n     *\n     * @static\n     * @param {string} frameId - The frame Id of the texture in the cache\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromFrame(frameId)\n    {\n        const texture = TextureCache[frameId];\n\n        if (!texture)\n        {\n            throw new Error(`The frameId \"${frameId}\" does not exist in the texture cache`);\n        }\n\n        return texture;\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the given canvas element.\n     *\n     * @static\n     * @param {HTMLCanvasElement} canvas - The canvas element source of the texture\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {string} [origin='canvas'] - A string origin of who created the base texture\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromCanvas(canvas, scaleMode, origin = 'canvas')\n    {\n        return new Texture(BaseTexture.fromCanvas(canvas, scaleMode, origin));\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the given video element.\n     *\n     * @static\n     * @param {HTMLVideoElement|string} video - The URL or actual element of the video\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromVideo(video, scaleMode, crossorigin, autoPlay)\n    {\n        if (typeof video === 'string')\n        {\n            return Texture.fromVideoUrl(video, scaleMode, crossorigin, autoPlay);\n        }\n\n        return new Texture(VideoBaseTexture.fromVideo(video, scaleMode, autoPlay));\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the video url.\n     *\n     * @static\n     * @param {string} videoUrl - URL of the video\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromVideoUrl(videoUrl, scaleMode, crossorigin, autoPlay)\n    {\n        return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode, crossorigin, autoPlay));\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture}\n     *        source - Source to create texture from\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static from(source)\n    {\n        // TODO auto detect cross origin..\n        // TODO pass in scale mode?\n        if (typeof source === 'string')\n        {\n            const texture = TextureCache[source];\n\n            if (!texture)\n            {\n                // check if its a video..\n                const isVideo = source.match(/\\.(mp4|webm|ogg|h264|avi|mov)$/) !== null;\n\n                if (isVideo)\n                {\n                    return Texture.fromVideoUrl(source);\n                }\n\n                return Texture.fromImage(source);\n            }\n\n            return texture;\n        }\n        else if (source instanceof HTMLImageElement)\n        {\n            return new Texture(BaseTexture.from(source));\n        }\n        else if (source instanceof HTMLCanvasElement)\n        {\n            return Texture.fromCanvas(source, settings.SCALE_MODE, 'HTMLCanvasElement');\n        }\n        else if (source instanceof HTMLVideoElement)\n        {\n            return Texture.fromVideo(source);\n        }\n        else if (source instanceof BaseTexture)\n        {\n            return new Texture(source);\n        }\n\n        // lets assume its a texture!\n        return source;\n    }\n\n    /**\n     * Create a texture from a source and add to the cache.\n     *\n     * @static\n     * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.\n     * @param {String} imageUrl - File name of texture, for cache and resolving resolution.\n     * @param {String} [name] - Human readible name for the texture cache. If no name is\n     *        specified, only `imageUrl` will be used as the cache ID.\n     * @return {PIXI.Texture} Output texture\n     */\n    static fromLoader(source, imageUrl, name)\n    {\n        const baseTexture = new BaseTexture(source, undefined, getResolutionOfUrl(imageUrl));\n        const texture = new Texture(baseTexture);\n\n        baseTexture.imageUrl = imageUrl;\n\n        // No name, use imageUrl instead\n        if (!name)\n        {\n            name = imageUrl;\n        }\n\n        // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions\n        BaseTexture.addToCache(texture.baseTexture, name);\n        Texture.addToCache(texture, name);\n\n        // also add references by url if they are different.\n        if (name !== imageUrl)\n        {\n            BaseTexture.addToCache(texture.baseTexture, imageUrl);\n            Texture.addToCache(texture, imageUrl);\n        }\n\n        return texture;\n    }\n\n    /**\n     * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.\n     *\n     * @static\n     * @param {PIXI.Texture} texture - The Texture to add to the cache.\n     * @param {string} id - The id that the Texture will be stored against.\n     */\n    static addToCache(texture, id)\n    {\n        if (id)\n        {\n            if (texture.textureCacheIds.indexOf(id) === -1)\n            {\n                texture.textureCacheIds.push(id);\n            }\n\n            // @if DEBUG\n            /* eslint-disable no-console */\n            if (TextureCache[id])\n            {\n                console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);\n            }\n            /* eslint-enable no-console */\n            // @endif\n\n            TextureCache[id] = texture;\n        }\n    }\n\n    /**\n     * Remove a Texture from the global TextureCache.\n     *\n     * @static\n     * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself\n     * @return {PIXI.Texture|null} The Texture that was removed\n     */\n    static removeFromCache(texture)\n    {\n        if (typeof texture === 'string')\n        {\n            const textureFromCache = TextureCache[texture];\n\n            if (textureFromCache)\n            {\n                const index = textureFromCache.textureCacheIds.indexOf(texture);\n\n                if (index > -1)\n                {\n                    textureFromCache.textureCacheIds.splice(index, 1);\n                }\n\n                delete TextureCache[texture];\n\n                return textureFromCache;\n            }\n        }\n        else if (texture && texture.textureCacheIds)\n        {\n            for (let i = 0; i < texture.textureCacheIds.length; ++i)\n            {\n                // Check that texture matches the one being passed in before deleting it from the cache.\n                if (TextureCache[texture.textureCacheIds[i]] === texture)\n                {\n                    delete TextureCache[texture.textureCacheIds[i]];\n                }\n            }\n\n            texture.textureCacheIds.length = 0;\n\n            return texture;\n        }\n\n        return null;\n    }\n\n    /**\n     * The frame specifies the region of the base texture that this texture uses.\n     * Please call `_updateUvs()` after you change coordinates of `frame` manually.\n     *\n     * @member {PIXI.Rectangle}\n     */\n    get frame()\n    {\n        return this._frame;\n    }\n\n    set frame(frame) // eslint-disable-line require-jsdoc\n    {\n        this._frame = frame;\n\n        this.noFrame = false;\n\n        const { x, y, width, height } = frame;\n        const xNotFit = x + width > this.baseTexture.width;\n        const yNotFit = y + height > this.baseTexture.height;\n\n        if (xNotFit || yNotFit)\n        {\n            const relationship = xNotFit && yNotFit ? 'and' : 'or';\n            const errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`;\n            const errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;\n\n            throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: '\n                + `${errorX} ${relationship} ${errorY}`);\n        }\n\n        // this.valid = width && height && this.baseTexture.source && this.baseTexture.hasLoaded;\n        this.valid = width && height && this.baseTexture.hasLoaded;\n\n        if (!this.trim && !this.rotate)\n        {\n            this.orig = frame;\n        }\n\n        if (this.valid)\n        {\n            this._updateUvs();\n        }\n    }\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link PIXI.GroupD8} for explanation\n     *\n     * @member {number}\n     */\n    get rotate()\n    {\n        return this._rotate;\n    }\n\n    set rotate(rotate) // eslint-disable-line require-jsdoc\n    {\n        this._rotate = rotate;\n        if (this.valid)\n        {\n            this._updateUvs();\n        }\n    }\n\n    /**\n     * The width of the Texture in pixels.\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this.orig.width;\n    }\n\n    /**\n     * The height of the Texture in pixels.\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this.orig.height;\n    }\n}\n\nfunction createWhiteTexture()\n{\n    const canvas = document.createElement('canvas');\n\n    canvas.width = 10;\n    canvas.height = 10;\n\n    const context = canvas.getContext('2d');\n\n    context.fillStyle = 'white';\n    context.fillRect(0, 0, 10, 10);\n\n    return new Texture(new BaseTexture(canvas));\n}\n\nfunction removeAllHandlers(tex)\n{\n    tex.destroy = function _emptyDestroy() { /* empty */ };\n    tex.on = function _emptyOn() { /* empty */ };\n    tex.once = function _emptyOnce() { /* empty */ };\n    tex.emit = function _emptyEmit() { /* empty */ };\n}\n\n/**\n * An empty texture, used often to not have to create multiple empty textures.\n * Can not be destroyed.\n *\n * @static\n * @constant\n */\nTexture.EMPTY = new Texture(new BaseTexture());\nremoveAllHandlers(Texture.EMPTY);\nremoveAllHandlers(Texture.EMPTY.baseTexture);\n\n/**\n * A white texture of 10x10 size, used for graphics and other things\n * Can not be destroyed.\n *\n * @static\n * @constant\n */\nTexture.WHITE = createWhiteTexture();\nremoveAllHandlers(Texture.WHITE);\nremoveAllHandlers(Texture.WHITE.baseTexture);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}