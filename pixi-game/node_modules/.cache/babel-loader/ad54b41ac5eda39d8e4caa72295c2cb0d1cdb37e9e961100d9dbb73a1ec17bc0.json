{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _core = require('../core');\nvar core = _interopRequireWildcard(_core);\nvar _CanvasTinter = require('../core/sprites/canvas/CanvasTinter');\nvar _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar tempPoint = new core.Point();\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n */\n\nvar TilingSprite = function (_core$Sprite) {\n  _inherits(TilingSprite, _core$Sprite);\n\n  /**\n   * @param {PIXI.Texture} texture - the texture of the tiling sprite\n   * @param {number} [width=100] - the width of the tiling sprite\n   * @param {number} [height=100] - the height of the tiling sprite\n   */\n  function TilingSprite(texture) {\n    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n    _classCallCheck(this, TilingSprite);\n\n    /**\n     * Tile transform\n     *\n     * @member {PIXI.TransformStatic}\n     */\n    var _this = _possibleConstructorReturn(this, _core$Sprite.call(this, texture));\n    _this.tileTransform = new core.TransformStatic();\n\n    // /// private\n\n    /**\n     * The with of the tiling sprite\n     *\n     * @member {number}\n     * @private\n     */\n    _this._width = width;\n\n    /**\n     * The height of the tiling sprite\n     *\n     * @member {number}\n     * @private\n     */\n    _this._height = height;\n\n    /**\n     * Canvas pattern\n     *\n     * @type {CanvasPattern}\n     * @private\n     */\n    _this._canvasPattern = null;\n\n    /**\n     * transform that is applied to UV to get the texture coords\n     *\n     * @member {PIXI.TextureMatrix}\n     */\n    _this.uvTransform = texture.transform || new core.TextureMatrix(texture);\n\n    /**\n     * Plugin that is responsible for rendering this element.\n     * Allows to customize the rendering process without overriding '_renderWebGL' method.\n     *\n     * @member {string}\n     * @default 'tilingSprite'\n     */\n    _this.pluginName = 'tilingSprite';\n\n    /**\n     * Whether or not anchor affects uvs\n     *\n     * @member {boolean}\n     * @default false\n     */\n    _this.uvRespectAnchor = false;\n    return _this;\n  }\n  /**\n   * Changes frame clamping in corresponding textureTransform, shortcut\n   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n   *\n   * @default 0.5\n   * @member {number}\n   */\n\n  /**\n   * @private\n   */\n  TilingSprite.prototype._onTextureUpdate = function _onTextureUpdate() {\n    if (this.uvTransform) {\n      this.uvTransform.texture = this._texture;\n    }\n    this.cachedTint = 0xFFFFFF;\n  };\n\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n  TilingSprite.prototype._renderWebGL = function _renderWebGL(renderer) {\n    // tweak our texture temporarily..\n    var texture = this._texture;\n    if (!texture || !texture.valid) {\n      return;\n    }\n    this.tileTransform.updateLocalTransform();\n    this.uvTransform.update();\n    renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  };\n\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n   */\n\n  TilingSprite.prototype._renderCanvas = function _renderCanvas(renderer) {\n    var texture = this._texture;\n    if (!texture.baseTexture.hasLoaded) {\n      return;\n    }\n    var context = renderer.context;\n    var transform = this.worldTransform;\n    var resolution = renderer.resolution;\n    var isTextureRotated = texture.rotate === 2;\n    var baseTexture = texture.baseTexture;\n    var baseTextureResolution = baseTexture.resolution;\n    var modX = this.tilePosition.x / this.tileScale.x % texture.orig.width * baseTextureResolution;\n    var modY = this.tilePosition.y / this.tileScale.y % texture.orig.height * baseTextureResolution;\n\n    // create a nice shiny pattern!\n    if (this._textureID !== this._texture._updateID || this.cachedTint !== this.tint) {\n      this._textureID = this._texture._updateID;\n      // cut an object from a spritesheet..\n      var tempCanvas = new core.CanvasRenderTarget(texture.orig.width, texture.orig.height, baseTextureResolution);\n\n      // Tint the tiling sprite\n      if (this.tint !== 0xFFFFFF) {\n        this.tintedTexture = _CanvasTinter2.default.getTintedTexture(this, this.tint);\n        tempCanvas.context.drawImage(this.tintedTexture, 0, 0);\n      } else {\n        var sx = texture._frame.x * baseTextureResolution;\n        var sy = texture._frame.y * baseTextureResolution;\n        var sWidth = texture._frame.width * baseTextureResolution;\n        var sHeight = texture._frame.height * baseTextureResolution;\n        var dWidth = (texture.trim ? texture.trim.width : texture.orig.width) * baseTextureResolution;\n        var dHeight = (texture.trim ? texture.trim.height : texture.orig.height) * baseTextureResolution;\n        var dx = (texture.trim ? texture.trim.x : 0) * baseTextureResolution;\n        var dy = (texture.trim ? texture.trim.y : 0) * baseTextureResolution;\n        if (isTextureRotated) {\n          // Apply rotation and transform\n          tempCanvas.context.rotate(-Math.PI / 2);\n          tempCanvas.context.translate(-dHeight, 0);\n          tempCanvas.context.drawImage(baseTexture.source, sx, sy, sWidth, sHeight, -dy, dx, dHeight, dWidth);\n        } else {\n          tempCanvas.context.drawImage(baseTexture.source, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n        }\n      }\n      this.cachedTint = this.tint;\n      this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n    }\n\n    // set context state..\n    context.globalAlpha = this.worldAlpha;\n    context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);\n    renderer.setBlendMode(this.blendMode);\n\n    // fill the pattern!\n    context.fillStyle = this._canvasPattern;\n\n    // TODO - this should be rolled into the setTransform above..\n    context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n    var anchorX = this.anchor.x * -this._width * baseTextureResolution;\n    var anchorY = this.anchor.y * -this._height * baseTextureResolution;\n    if (this.uvRespectAnchor) {\n      context.translate(modX, modY);\n      context.fillRect(-modX + anchorX, -modY + anchorY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution);\n    } else {\n      context.translate(modX + anchorX, modY + anchorY);\n      context.fillRect(-modX, -modY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution);\n    }\n  };\n\n  /**\n   * Updates the bounds of the tiling sprite.\n   *\n   * @private\n   */\n\n  TilingSprite.prototype._calculateBounds = function _calculateBounds() {\n    var minX = this._width * -this._anchor._x;\n    var minY = this._height * -this._anchor._y;\n    var maxX = this._width * (1 - this._anchor._x);\n    var maxY = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n\n  /**\n   * Gets the local bounds of the sprite object.\n   *\n   * @param {PIXI.Rectangle} rect - The output rectangle.\n   * @return {PIXI.Rectangle} The bounds.\n   */\n\n  TilingSprite.prototype.getLocalBounds = function getLocalBounds(rect) {\n    // we can do a fast local bounds if the sprite has no children!\n    if (this.children.length === 0) {\n      this._bounds.minX = this._width * -this._anchor._x;\n      this._bounds.minY = this._height * -this._anchor._y;\n      this._bounds.maxX = this._width * (1 - this._anchor._x);\n      this._bounds.maxY = this._height * (1 - this._anchor._y);\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new core.Rectangle();\n        }\n        rect = this._localBoundsRect;\n      }\n      return this._bounds.getRectangle(rect);\n    }\n    return _core$Sprite.prototype.getLocalBounds.call(this, rect);\n  };\n\n  /**\n   * Checks if a point is inside this tiling sprite.\n   *\n   * @param {PIXI.Point} point - the point to check\n   * @return {boolean} Whether or not the sprite contains the point.\n   */\n\n  TilingSprite.prototype.containsPoint = function containsPoint(point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    var width = this._width;\n    var height = this._height;\n    var x1 = -width * this.anchor._x;\n    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n      var y1 = -height * this.anchor._y;\n      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Destroys this sprite and optionally its texture and children\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *      method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n   * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n   */\n\n  TilingSprite.prototype.destroy = function destroy(options) {\n    _core$Sprite.prototype.destroy.call(this, options);\n    this.tileTransform = null;\n    this.uvTransform = null;\n  };\n\n  /**\n   * Helper function that creates a new tiling sprite based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   *\n   * @static\n   * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n   * @param {number} width - the width of the tiling sprite\n   * @param {number} height - the height of the tiling sprite\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n  TilingSprite.from = function from(source, width, height) {\n    return new TilingSprite(core.Texture.from(source), width, height);\n  };\n\n  /**\n   * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n   * The frame ids are created when a Texture packer file has been loaded\n   *\n   * @static\n   * @param {string} frameId - The frame Id of the texture in the cache\n   * @param {number} width - the width of the tiling sprite\n   * @param {number} height - the height of the tiling sprite\n   * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n   */\n\n  TilingSprite.fromFrame = function fromFrame(frameId, width, height) {\n    var texture = core.utils.TextureCache[frameId];\n    if (!texture) {\n      throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache ' + this);\n    }\n    return new TilingSprite(texture, width, height);\n  };\n\n  /**\n   * Helper function that creates a sprite that will contain a texture based on an image url\n   * If the image is not in the texture cache it will be loaded\n   *\n   * @static\n   * @param {string} imageId - The image url of the texture\n   * @param {number} width - the width of the tiling sprite\n   * @param {number} height - the height of the tiling sprite\n   * @param {boolean} [crossorigin] - if you want to specify the cross-origin parameter\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,\n   *  see {@link PIXI.SCALE_MODES} for possible values\n   * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n   */\n\n  TilingSprite.fromImage = function fromImage(imageId, width, height, crossorigin, scaleMode) {\n    return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);\n  };\n\n  /**\n   * The width of the sprite, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   */\n\n  _createClass(TilingSprite, [{\n    key: 'clampMargin',\n    get: function get() {\n      return this.uvTransform.clampMargin;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.uvTransform.clampMargin = value;\n      this.uvTransform.update(true);\n    }\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n  }, {\n    key: 'tileScale',\n    get: function get() {\n      return this.tileTransform.scale;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.tileTransform.scale.copy(value);\n    }\n\n    /**\n     * The offset of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n  }, {\n    key: 'tilePosition',\n    get: function get() {\n      return this.tileTransform.position;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.tileTransform.position.copy(value);\n    }\n  }, {\n    key: 'width',\n    get: function get() {\n      return this._width;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this._width = value;\n    }\n\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n  }, {\n    key: 'height',\n    get: function get() {\n      return this._height;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this._height = value;\n    }\n  }]);\n  return TilingSprite;\n}(core.Sprite);\nexports.default = TilingSprite;","map":{"version":3,"names":["_core","require","core","_CanvasTinter","tempPoint","Point","TilingSprite","texture","width","arguments","length","undefined","height","_classCallCheck","_this","_possibleConstructorReturn","_core$Sprite","call","tileTransform","TransformStatic","_width","_height","_canvasPattern","uvTransform","transform","TextureMatrix","pluginName","uvRespectAnchor","_onTextureUpdate","_texture","cachedTint","_renderWebGL","renderer","valid","updateLocalTransform","update","setObjectRenderer","plugins","render","_renderCanvas","baseTexture","hasLoaded","context","worldTransform","resolution","isTextureRotated","rotate","baseTextureResolution","modX","tilePosition","x","tileScale","orig","modY","y","_textureID","_updateID","tint","tempCanvas","CanvasRenderTarget","tintedTexture","_CanvasTinter2","default","getTintedTexture","drawImage","sx","_frame","sy","sWidth","sHeight","dWidth","trim","dHeight","dx","dy","Math","PI","translate","source","createPattern","canvas","globalAlpha","worldAlpha","setTransform","a","b","c","d","tx","ty","setBlendMode","blendMode","fillStyle","scale","anchorX","anchor","anchorY","fillRect","_calculateBounds","minX","_anchor","_x","minY","_y","maxX","maxY","_bounds","addFrame","getLocalBounds","rect","children","_localBoundsRect","Rectangle","getRectangle","prototype","containsPoint","point","applyInverse","x1","y1","destroy","options","from","Texture","fromFrame","frameId","utils","TextureCache","Error","fromImage","imageId","crossorigin","scaleMode","clampMargin","value","copy","position","Sprite"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/extras/TilingSprite.js"],"sourcesContent":["import * as core from '../core';\nimport CanvasTinter from '../core/sprites/canvas/CanvasTinter';\n\nconst tempPoint = new core.Point();\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n */\nexport default class TilingSprite extends core.Sprite\n{\n    /**\n     * @param {PIXI.Texture} texture - the texture of the tiling sprite\n     * @param {number} [width=100] - the width of the tiling sprite\n     * @param {number} [height=100] - the height of the tiling sprite\n     */\n    constructor(texture, width = 100, height = 100)\n    {\n        super(texture);\n\n        /**\n         * Tile transform\n         *\n         * @member {PIXI.TransformStatic}\n         */\n        this.tileTransform = new core.TransformStatic();\n\n        // /// private\n\n        /**\n         * The with of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._width = width;\n\n        /**\n         * The height of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._height = height;\n\n        /**\n         * Canvas pattern\n         *\n         * @type {CanvasPattern}\n         * @private\n         */\n        this._canvasPattern = null;\n\n        /**\n         * transform that is applied to UV to get the texture coords\n         *\n         * @member {PIXI.TextureMatrix}\n         */\n        this.uvTransform = texture.transform || new core.TextureMatrix(texture);\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' method.\n         *\n         * @member {string}\n         * @default 'tilingSprite'\n         */\n        this.pluginName = 'tilingSprite';\n\n        /**\n         * Whether or not anchor affects uvs\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.uvRespectAnchor = false;\n    }\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     *\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this.uvTransform.clampMargin;\n    }\n\n    set clampMargin(value) // eslint-disable-line require-jsdoc\n    {\n        this.uvTransform.clampMargin = value;\n        this.uvTransform.update(true);\n    }\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tileScale()\n    {\n        return this.tileTransform.scale;\n    }\n\n    set tileScale(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.scale.copy(value);\n    }\n\n    /**\n     * The offset of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tilePosition()\n    {\n        return this.tileTransform.position;\n    }\n\n    set tilePosition(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.position.copy(value);\n    }\n\n    /**\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        if (this.uvTransform)\n        {\n            this.uvTransform.texture = this._texture;\n        }\n        this.cachedTint = 0xFFFFFF;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer)\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        this.tileTransform.updateLocalTransform();\n        this.uvTransform.update();\n\n        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n     */\n    _renderCanvas(renderer)\n    {\n        const texture = this._texture;\n\n        if (!texture.baseTexture.hasLoaded)\n        {\n            return;\n        }\n\n        const context = renderer.context;\n        const transform = this.worldTransform;\n        const resolution = renderer.resolution;\n        const isTextureRotated = texture.rotate === 2;\n        const baseTexture = texture.baseTexture;\n        const baseTextureResolution = baseTexture.resolution;\n        const modX = ((this.tilePosition.x / this.tileScale.x) % texture.orig.width) * baseTextureResolution;\n        const modY = ((this.tilePosition.y / this.tileScale.y) % texture.orig.height) * baseTextureResolution;\n\n        // create a nice shiny pattern!\n        if (this._textureID !== this._texture._updateID || this.cachedTint !== this.tint)\n        {\n            this._textureID = this._texture._updateID;\n            // cut an object from a spritesheet..\n            const tempCanvas = new core.CanvasRenderTarget(texture.orig.width,\n                                                        texture.orig.height,\n                                                        baseTextureResolution);\n\n            // Tint the tiling sprite\n            if (this.tint !== 0xFFFFFF)\n            {\n                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);\n                tempCanvas.context.drawImage(this.tintedTexture, 0, 0);\n            }\n            else\n            {\n                const sx = texture._frame.x * baseTextureResolution;\n                const sy = texture._frame.y * baseTextureResolution;\n                const sWidth = texture._frame.width * baseTextureResolution;\n                const sHeight = texture._frame.height * baseTextureResolution;\n                const dWidth = (texture.trim ? texture.trim.width : texture.orig.width) * baseTextureResolution;\n                const dHeight = (texture.trim ? texture.trim.height : texture.orig.height) * baseTextureResolution;\n                const dx = (texture.trim ? texture.trim.x : 0) * baseTextureResolution;\n                const dy = (texture.trim ? texture.trim.y : 0) * baseTextureResolution;\n\n                if (isTextureRotated)\n                {\n                    // Apply rotation and transform\n                    tempCanvas.context.rotate(-Math.PI / 2);\n                    tempCanvas.context.translate(-dHeight, 0);\n                    tempCanvas.context.drawImage(baseTexture.source,\n                                                sx, sy,\n                                                sWidth, sHeight,\n                                                -dy, dx,\n                                                dHeight, dWidth);\n                }\n                else\n                    {\n                    tempCanvas.context.drawImage(baseTexture.source,\n                                                sx, sy,\n                                                sWidth, sHeight,\n                                                dx, dy,\n                                                dWidth, dHeight);\n                }\n            }\n\n            this.cachedTint = this.tint;\n            this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n        }\n\n        // set context state..\n        context.globalAlpha = this.worldAlpha;\n        context.setTransform(transform.a * resolution,\n                           transform.b * resolution,\n                           transform.c * resolution,\n                           transform.d * resolution,\n                           transform.tx * resolution,\n                           transform.ty * resolution);\n\n        renderer.setBlendMode(this.blendMode);\n\n        // fill the pattern!\n        context.fillStyle = this._canvasPattern;\n\n        // TODO - this should be rolled into the setTransform above..\n        context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n\n        const anchorX = this.anchor.x * -this._width * baseTextureResolution;\n        const anchorY = this.anchor.y * -this._height * baseTextureResolution;\n\n        if (this.uvRespectAnchor)\n        {\n            context.translate(modX, modY);\n\n            context.fillRect(-modX + anchorX, -modY + anchorY,\n                this._width / this.tileScale.x * baseTextureResolution,\n                this._height / this.tileScale.y * baseTextureResolution);\n        }\n        else\n        {\n            context.translate(modX + anchorX, modY + anchorY);\n\n            context.fillRect(-modX, -modY,\n                this._width / this.tileScale.x * baseTextureResolution,\n                this._height / this.tileScale.y * baseTextureResolution);\n        }\n    }\n\n    /**\n     * Updates the bounds of the tiling sprite.\n     *\n     * @private\n     */\n    _calculateBounds()\n    {\n        const minX = this._width * -this._anchor._x;\n        const minY = this._height * -this._anchor._y;\n        const maxX = this._width * (1 - this._anchor._x);\n        const maxY = this._height * (1 - this._anchor._y);\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     *\n     * @param {PIXI.Rectangle} rect - The output rectangle.\n     * @return {PIXI.Rectangle} The bounds.\n     */\n    getLocalBounds(rect)\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            this._bounds.minX = this._width * -this._anchor._x;\n            this._bounds.minY = this._height * -this._anchor._y;\n            this._bounds.maxX = this._width * (1 - this._anchor._x);\n            this._bounds.maxY = this._height * (1 - this._anchor._y);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new core.Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._bounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Checks if a point is inside this tiling sprite.\n     *\n     * @param {PIXI.Point} point - the point to check\n     * @return {boolean} Whether or not the sprite contains the point.\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this.anchor._x;\n\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width)\n        {\n            const y1 = -height * this.anchor._y;\n\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite and optionally its texture and children\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        this.tileTransform = null;\n        this.uvTransform = null;\n    }\n\n    /**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static from(source, width, height)\n    {\n        return new TilingSprite(core.Texture.from(source), width, height);\n    }\n\n    /**\n     * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n     * The frame ids are created when a Texture packer file has been loaded\n     *\n     * @static\n     * @param {string} frameId - The frame Id of the texture in the cache\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n     */\n    static fromFrame(frameId, width, height)\n    {\n        const texture = core.utils.TextureCache[frameId];\n\n        if (!texture)\n        {\n            throw new Error(`The frameId \"${frameId}\" does not exist in the texture cache ${this}`);\n        }\n\n        return new TilingSprite(texture, width, height);\n    }\n\n    /**\n     * Helper function that creates a sprite that will contain a texture based on an image url\n     * If the image is not in the texture cache it will be loaded\n     *\n     * @static\n     * @param {string} imageId - The image url of the texture\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @param {boolean} [crossorigin] - if you want to specify the cross-origin parameter\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,\n     *  see {@link PIXI.SCALE_MODES} for possible values\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n     */\n    static fromImage(imageId, width, height, crossorigin, scaleMode)\n    {\n        return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this._width = value;\n    }\n\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this._height = value;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}