{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _SystemRenderer2 = require('../SystemRenderer');\nvar _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);\nvar _CanvasMaskManager = require('./utils/CanvasMaskManager');\nvar _CanvasMaskManager2 = _interopRequireDefault(_CanvasMaskManager);\nvar _CanvasRenderTarget = require('./utils/CanvasRenderTarget');\nvar _CanvasRenderTarget2 = _interopRequireDefault(_CanvasRenderTarget);\nvar _mapCanvasBlendModesToPixi = require('./utils/mapCanvasBlendModesToPixi');\nvar _mapCanvasBlendModesToPixi2 = _interopRequireDefault(_mapCanvasBlendModesToPixi);\nvar _utils = require('../../utils');\nvar _const = require('../../const');\nvar _settings = require('../../settings');\nvar _settings2 = _interopRequireDefault(_settings);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should\n * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to\n * your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\nvar CanvasRenderer = function (_SystemRenderer) {\n  _inherits(CanvasRenderer, _SystemRenderer);\n\n  // eslint-disable-next-line valid-jsdoc\n  /**\n   * @param {object} [options] - The optional renderer parameters\n   * @param {number} [options.width=800] - the width of the screen\n   * @param {number} [options.height=600] - the height of the screen\n   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n   * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n   * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)\n   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The\n   *  resolution of the renderer retina would be 2.\n   * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n   *  enable this if you need to call toDataUrl on the webgl context.\n   * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or\n   *      not before the new render pass.\n   * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n   *  (shown if not transparent).\n   * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,\n   *  stopping pixel interpolation.\n   */\n  function CanvasRenderer(options, arg2, arg3) {\n    _classCallCheck(this, CanvasRenderer);\n    var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'Canvas', options, arg2, arg3));\n    _this.type = _const.RENDERER_TYPE.CANVAS;\n\n    /**\n     * The root canvas 2d context that everything is drawn with.\n     *\n     * @member {CanvasRenderingContext2D}\n     */\n    _this.rootContext = _this.view.getContext('2d', {\n      alpha: _this.transparent\n    });\n\n    /**\n     * The currently active canvas 2d context (could change with renderTextures)\n     *\n     * @member {CanvasRenderingContext2D}\n     */\n    _this.context = _this.rootContext;\n\n    /**\n     * Boolean flag controlling canvas refresh.\n     *\n     * @member {boolean}\n     */\n    _this.refresh = true;\n\n    /**\n     * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.\n     *\n     * @member {PIXI.CanvasMaskManager}\n     */\n    _this.maskManager = new _CanvasMaskManager2.default(_this);\n\n    /**\n     * The canvas property used to set the canvas smoothing property.\n     *\n     * @member {string}\n     */\n    _this.smoothProperty = 'imageSmoothingEnabled';\n    if (!_this.rootContext.imageSmoothingEnabled) {\n      if (_this.rootContext.webkitImageSmoothingEnabled) {\n        _this.smoothProperty = 'webkitImageSmoothingEnabled';\n      } else if (_this.rootContext.mozImageSmoothingEnabled) {\n        _this.smoothProperty = 'mozImageSmoothingEnabled';\n      } else if (_this.rootContext.oImageSmoothingEnabled) {\n        _this.smoothProperty = 'oImageSmoothingEnabled';\n      } else if (_this.rootContext.msImageSmoothingEnabled) {\n        _this.smoothProperty = 'msImageSmoothingEnabled';\n      }\n    }\n    _this.initPlugins();\n    _this.blendModes = (0, _mapCanvasBlendModesToPixi2.default)();\n    _this._activeBlendMode = null;\n    _this.renderingToScreen = false;\n    _this.resize(_this.options.width, _this.options.height);\n\n    /**\n     * Fired after rendering finishes.\n     *\n     * @event PIXI.CanvasRenderer#postrender\n     */\n\n    /**\n     * Fired before rendering starts.\n     *\n     * @event PIXI.CanvasRenderer#prerender\n     */\n    return _this;\n  }\n\n  /**\n   * Renders the object to this canvas view\n   *\n   * @param {PIXI.DisplayObject} displayObject - The object to be rendered\n   * @param {PIXI.RenderTexture} [renderTexture] - A render texture to be rendered to.\n   *  If unset, it will render to the root context.\n   * @param {boolean} [clear=false] - Whether to clear the canvas before drawing\n   * @param {PIXI.Matrix} [transform] - A transformation to be applied\n   * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform\n   */\n\n  CanvasRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {\n    if (!this.view) {\n      return;\n    }\n\n    // can be handy to know!\n    this.renderingToScreen = !renderTexture;\n    this.emit('prerender');\n    var rootResolution = this.resolution;\n    if (renderTexture) {\n      renderTexture = renderTexture.baseTexture || renderTexture;\n      if (!renderTexture._canvasRenderTarget) {\n        renderTexture._canvasRenderTarget = new _CanvasRenderTarget2.default(renderTexture.width, renderTexture.height, renderTexture.resolution);\n        renderTexture.source = renderTexture._canvasRenderTarget.canvas;\n        renderTexture.valid = true;\n      }\n      this.context = renderTexture._canvasRenderTarget.context;\n      this.resolution = renderTexture._canvasRenderTarget.resolution;\n    } else {\n      this.context = this.rootContext;\n    }\n    var context = this.context;\n    if (!renderTexture) {\n      this._lastObjectRendered = displayObject;\n    }\n    if (!skipUpdateTransform) {\n      // update the scene graph\n      var cacheParent = displayObject.parent;\n      var tempWt = this._tempDisplayObjectParent.transform.worldTransform;\n      if (transform) {\n        transform.copy(tempWt);\n\n        // lets not forget to flag the parent transform as dirty...\n        this._tempDisplayObjectParent.transform._worldID = -1;\n      } else {\n        tempWt.identity();\n      }\n      displayObject.parent = this._tempDisplayObjectParent;\n      displayObject.updateTransform();\n      displayObject.parent = cacheParent;\n      // displayObject.hitArea = //TODO add a temp hit area\n    }\n\n    context.save();\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    context.globalAlpha = 1;\n    this._activeBlendMode = _const.BLEND_MODES.NORMAL;\n    context.globalCompositeOperation = this.blendModes[_const.BLEND_MODES.NORMAL];\n    if (navigator.isCocoonJS && this.view.screencanvas) {\n      context.fillStyle = 'black';\n      context.clear();\n    }\n    if (clear !== undefined ? clear : this.clearBeforeRender) {\n      if (this.renderingToScreen) {\n        if (this.transparent) {\n          context.clearRect(0, 0, this.width, this.height);\n        } else {\n          context.fillStyle = this._backgroundColorString;\n          context.fillRect(0, 0, this.width, this.height);\n        }\n      } // else {\n      // TODO: implement background for CanvasRenderTarget or RenderTexture?\n      // }\n    }\n\n    // TODO RENDER TARGET STUFF HERE..\n    var tempContext = this.context;\n    this.context = context;\n    displayObject.renderCanvas(this);\n    this.context = tempContext;\n    context.restore();\n    this.resolution = rootResolution;\n    this.emit('postrender');\n  };\n\n  /**\n   * Clear the canvas of renderer.\n   *\n   * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.\n   */\n\n  CanvasRenderer.prototype.clear = function clear(clearColor) {\n    var context = this.context;\n    clearColor = clearColor || this._backgroundColorString;\n    if (!this.transparent && clearColor) {\n      context.fillStyle = clearColor;\n      context.fillRect(0, 0, this.width, this.height);\n    } else {\n      context.clearRect(0, 0, this.width, this.height);\n    }\n  };\n\n  /**\n   * Sets the blend mode of the renderer.\n   *\n   * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.\n   */\n\n  CanvasRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {\n    if (this._activeBlendMode === blendMode) {\n      return;\n    }\n    this._activeBlendMode = blendMode;\n    this.context.globalCompositeOperation = this.blendModes[blendMode];\n  };\n\n  /**\n   * Removes everything from the renderer and optionally removes the Canvas DOM element.\n   *\n   * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n   */\n\n  CanvasRenderer.prototype.destroy = function destroy(removeView) {\n    this.destroyPlugins();\n\n    // call the base destroy\n    _SystemRenderer.prototype.destroy.call(this, removeView);\n    this.context = null;\n    this.refresh = true;\n    this.maskManager.destroy();\n    this.maskManager = null;\n    this.smoothProperty = null;\n  };\n\n  /**\n   * Resizes the canvas view to the specified width and height.\n   *\n   * @extends PIXI.SystemRenderer#resize\n   *\n   * @param {number} screenWidth - the new width of the screen\n   * @param {number} screenHeight - the new height of the screen\n   */\n\n  CanvasRenderer.prototype.resize = function resize(screenWidth, screenHeight) {\n    _SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight);\n\n    // reset the scale mode.. oddly this seems to be reset when the canvas is resized.\n    // surely a browser bug?? Let PixiJS fix that for you..\n    if (this.smoothProperty) {\n      this.rootContext[this.smoothProperty] = _settings2.default.SCALE_MODE === _const.SCALE_MODES.LINEAR;\n    }\n  };\n\n  /**\n   * Checks if blend mode has changed.\n   */\n\n  CanvasRenderer.prototype.invalidateBlendMode = function invalidateBlendMode() {\n    this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);\n  };\n  return CanvasRenderer;\n}(_SystemRenderer3.default);\n\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.CanvasRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.CanvasExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.CanvasPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.CanvasRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\nexports.default = CanvasRenderer;\n_utils.pluginTarget.mixin(CanvasRenderer);","map":{"version":3,"names":["_SystemRenderer2","require","_CanvasMaskManager","_CanvasRenderTarget","_mapCanvasBlendModesToPixi","_utils","_const","_settings","CanvasRenderer","options","arg2","arg3","_classCallCheck","_this","_possibleConstructorReturn","_SystemRenderer","call","type","RENDERER_TYPE","CANVAS","rootContext","view","getContext","alpha","transparent","context","refresh","maskManager","_CanvasMaskManager2","default","smoothProperty","imageSmoothingEnabled","webkitImageSmoothingEnabled","mozImageSmoothingEnabled","oImageSmoothingEnabled","msImageSmoothingEnabled","initPlugins","blendModes","_mapCanvasBlendModesToPixi2","_activeBlendMode","renderingToScreen","resize","width","height","render","displayObject","renderTexture","clear","transform","skipUpdateTransform","emit","rootResolution","resolution","baseTexture","_canvasRenderTarget","_CanvasRenderTarget2","source","canvas","valid","_lastObjectRendered","cacheParent","parent","tempWt","_tempDisplayObjectParent","worldTransform","copy","_worldID","identity","updateTransform","save","setTransform","globalAlpha","BLEND_MODES","NORMAL","globalCompositeOperation","navigator","isCocoonJS","screencanvas","fillStyle","undefined","clearBeforeRender","clearRect","_backgroundColorString","fillRect","tempContext","renderCanvas","restore","clearColor","setBlendMode","blendMode","destroy","removeView","destroyPlugins","prototype","screenWidth","screenHeight","_settings2","SCALE_MODE","SCALE_MODES","LINEAR","invalidateBlendMode","indexOf","pluginTarget","mixin"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/renderers/canvas/CanvasRenderer.js"],"sourcesContent":["import SystemRenderer from '../SystemRenderer';\nimport CanvasMaskManager from './utils/CanvasMaskManager';\nimport CanvasRenderTarget from './utils/CanvasRenderTarget';\nimport mapCanvasBlendModesToPixi from './utils/mapCanvasBlendModesToPixi';\nimport { pluginTarget } from '../../utils';\nimport { RENDERER_TYPE, SCALE_MODES, BLEND_MODES } from '../../const';\nimport settings from '../../settings';\n\n/**\n * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should\n * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to\n * your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\nexport default class CanvasRenderer extends SystemRenderer\n{\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * @param {object} [options] - The optional renderer parameters\n     * @param {number} [options.width=800] - the width of the screen\n     * @param {number} [options.height=600] - the height of the screen\n     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n     * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)\n     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The\n     *  resolution of the renderer retina would be 2.\n     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n     *  enable this if you need to call toDataUrl on the webgl context.\n     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or\n     *      not before the new render pass.\n     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n     *  (shown if not transparent).\n     * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,\n     *  stopping pixel interpolation.\n     */\n    constructor(options, arg2, arg3)\n    {\n        super('Canvas', options, arg2, arg3);\n\n        this.type = RENDERER_TYPE.CANVAS;\n\n        /**\n         * The root canvas 2d context that everything is drawn with.\n         *\n         * @member {CanvasRenderingContext2D}\n         */\n        this.rootContext = this.view.getContext('2d', { alpha: this.transparent });\n\n        /**\n         * The currently active canvas 2d context (could change with renderTextures)\n         *\n         * @member {CanvasRenderingContext2D}\n         */\n        this.context = this.rootContext;\n\n        /**\n         * Boolean flag controlling canvas refresh.\n         *\n         * @member {boolean}\n         */\n        this.refresh = true;\n\n        /**\n         * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.\n         *\n         * @member {PIXI.CanvasMaskManager}\n         */\n        this.maskManager = new CanvasMaskManager(this);\n\n        /**\n         * The canvas property used to set the canvas smoothing property.\n         *\n         * @member {string}\n         */\n        this.smoothProperty = 'imageSmoothingEnabled';\n\n        if (!this.rootContext.imageSmoothingEnabled)\n        {\n            if (this.rootContext.webkitImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'webkitImageSmoothingEnabled';\n            }\n            else if (this.rootContext.mozImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'mozImageSmoothingEnabled';\n            }\n            else if (this.rootContext.oImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'oImageSmoothingEnabled';\n            }\n            else if (this.rootContext.msImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'msImageSmoothingEnabled';\n            }\n        }\n\n        this.initPlugins();\n\n        this.blendModes = mapCanvasBlendModesToPixi();\n        this._activeBlendMode = null;\n\n        this.renderingToScreen = false;\n\n        this.resize(this.options.width, this.options.height);\n\n        /**\n         * Fired after rendering finishes.\n         *\n         * @event PIXI.CanvasRenderer#postrender\n         */\n\n        /**\n         * Fired before rendering starts.\n         *\n         * @event PIXI.CanvasRenderer#prerender\n         */\n    }\n\n    /**\n     * Renders the object to this canvas view\n     *\n     * @param {PIXI.DisplayObject} displayObject - The object to be rendered\n     * @param {PIXI.RenderTexture} [renderTexture] - A render texture to be rendered to.\n     *  If unset, it will render to the root context.\n     * @param {boolean} [clear=false] - Whether to clear the canvas before drawing\n     * @param {PIXI.Matrix} [transform] - A transformation to be applied\n     * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform\n     */\n    render(displayObject, renderTexture, clear, transform, skipUpdateTransform)\n    {\n        if (!this.view)\n        {\n            return;\n        }\n\n        // can be handy to know!\n        this.renderingToScreen = !renderTexture;\n\n        this.emit('prerender');\n\n        const rootResolution = this.resolution;\n\n        if (renderTexture)\n        {\n            renderTexture = renderTexture.baseTexture || renderTexture;\n\n            if (!renderTexture._canvasRenderTarget)\n            {\n                renderTexture._canvasRenderTarget = new CanvasRenderTarget(\n                    renderTexture.width,\n                    renderTexture.height,\n                    renderTexture.resolution\n                );\n                renderTexture.source = renderTexture._canvasRenderTarget.canvas;\n                renderTexture.valid = true;\n            }\n\n            this.context = renderTexture._canvasRenderTarget.context;\n            this.resolution = renderTexture._canvasRenderTarget.resolution;\n        }\n        else\n        {\n            this.context = this.rootContext;\n        }\n\n        const context = this.context;\n\n        if (!renderTexture)\n        {\n            this._lastObjectRendered = displayObject;\n        }\n\n        if (!skipUpdateTransform)\n        {\n            // update the scene graph\n            const cacheParent = displayObject.parent;\n            const tempWt = this._tempDisplayObjectParent.transform.worldTransform;\n\n            if (transform)\n            {\n                transform.copy(tempWt);\n\n                // lets not forget to flag the parent transform as dirty...\n                this._tempDisplayObjectParent.transform._worldID = -1;\n            }\n            else\n            {\n                tempWt.identity();\n            }\n\n            displayObject.parent = this._tempDisplayObjectParent;\n\n            displayObject.updateTransform();\n            displayObject.parent = cacheParent;\n            // displayObject.hitArea = //TODO add a temp hit area\n        }\n\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.globalAlpha = 1;\n        this._activeBlendMode = BLEND_MODES.NORMAL;\n        context.globalCompositeOperation = this.blendModes[BLEND_MODES.NORMAL];\n\n        if (navigator.isCocoonJS && this.view.screencanvas)\n        {\n            context.fillStyle = 'black';\n            context.clear();\n        }\n\n        if (clear !== undefined ? clear : this.clearBeforeRender)\n        {\n            if (this.renderingToScreen)\n            {\n                if (this.transparent)\n                {\n                    context.clearRect(0, 0, this.width, this.height);\n                }\n                else\n                {\n                    context.fillStyle = this._backgroundColorString;\n                    context.fillRect(0, 0, this.width, this.height);\n                }\n            } // else {\n            // TODO: implement background for CanvasRenderTarget or RenderTexture?\n            // }\n        }\n\n        // TODO RENDER TARGET STUFF HERE..\n        const tempContext = this.context;\n\n        this.context = context;\n        displayObject.renderCanvas(this);\n        this.context = tempContext;\n\n        context.restore();\n\n        this.resolution = rootResolution;\n\n        this.emit('postrender');\n    }\n\n    /**\n     * Clear the canvas of renderer.\n     *\n     * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.\n     */\n    clear(clearColor)\n    {\n        const context = this.context;\n\n        clearColor = clearColor || this._backgroundColorString;\n\n        if (!this.transparent && clearColor)\n        {\n            context.fillStyle = clearColor;\n            context.fillRect(0, 0, this.width, this.height);\n        }\n        else\n        {\n            context.clearRect(0, 0, this.width, this.height);\n        }\n    }\n\n    /**\n     * Sets the blend mode of the renderer.\n     *\n     * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.\n     */\n    setBlendMode(blendMode)\n    {\n        if (this._activeBlendMode === blendMode)\n        {\n            return;\n        }\n\n        this._activeBlendMode = blendMode;\n        this.context.globalCompositeOperation = this.blendModes[blendMode];\n    }\n\n    /**\n     * Removes everything from the renderer and optionally removes the Canvas DOM element.\n     *\n     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n     */\n    destroy(removeView)\n    {\n        this.destroyPlugins();\n\n        // call the base destroy\n        super.destroy(removeView);\n\n        this.context = null;\n\n        this.refresh = true;\n\n        this.maskManager.destroy();\n        this.maskManager = null;\n\n        this.smoothProperty = null;\n    }\n\n    /**\n     * Resizes the canvas view to the specified width and height.\n     *\n     * @extends PIXI.SystemRenderer#resize\n     *\n     * @param {number} screenWidth - the new width of the screen\n     * @param {number} screenHeight - the new height of the screen\n     */\n    resize(screenWidth, screenHeight)\n    {\n        super.resize(screenWidth, screenHeight);\n\n        // reset the scale mode.. oddly this seems to be reset when the canvas is resized.\n        // surely a browser bug?? Let PixiJS fix that for you..\n        if (this.smoothProperty)\n        {\n            this.rootContext[this.smoothProperty] = (settings.SCALE_MODE === SCALE_MODES.LINEAR);\n        }\n    }\n\n    /**\n     * Checks if blend mode has changed.\n     */\n    invalidateBlendMode()\n    {\n        this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);\n    }\n}\n\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.CanvasRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.CanvasExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.CanvasPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.CanvasRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\npluginTarget.mixin(CanvasRenderer);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}