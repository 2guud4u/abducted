{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _core = require('../core');\nvar core = _interopRequireWildcard(_core);\nvar _utils = require('../core/utils');\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * The ParticleContainer class is a really fast version of the Container built solely for speed,\n * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that most advanced\n * functionality will not work. ParticleContainer implements the basic object transform (position, scale, rotation)\n * and some advanced functionality like tint (as of v4.5.6).\n * Other more advanced functionality like masking, children, filters, etc will not work on sprites in this batch.\n *\n * It's extremely easy to use :\n *\n * ```js\n * let container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n *     container.addChild(sprite);\n * }\n * ```\n *\n * And here you have a hundred sprites that will be rendered at the speed of light.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.particles\n */\nvar ParticleContainer = function (_core$Container) {\n  _inherits(ParticleContainer, _core$Container);\n\n  /**\n   * @param {number} [maxSize=1500] - The maximum number of particles that can be rendered by the container.\n   *  Affects size of allocated buffers.\n   * @param {object} [properties] - The properties of children that should be uploaded to the gpu and applied.\n   * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.\n   *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.\n   * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.\n   * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.\n   * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.\n   * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.\n   * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.\n   * @param {boolean} [autoResize=false] If true, container allocates more batches in case\n   *  there are more than `maxSize` particles.\n   */\n  function ParticleContainer() {\n    var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1500;\n    var properties = arguments[1];\n    var batchSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16384;\n    var autoResize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    _classCallCheck(this, ParticleContainer);\n\n    // Making sure the batch size is valid\n    // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n    // so max number of particles is 65536 / 4 = 16384\n    var _this = _possibleConstructorReturn(this, _core$Container.call(this));\n    var maxBatchSize = 16384;\n    if (batchSize > maxBatchSize) {\n      batchSize = maxBatchSize;\n    }\n    if (batchSize > maxSize) {\n      batchSize = maxSize;\n    }\n\n    /**\n     * Set properties to be dynamic (true) / static (false)\n     *\n     * @member {boolean[]}\n     * @private\n     */\n    _this._properties = [false, true, false, false, false];\n\n    /**\n     * @member {number}\n     * @private\n     */\n    _this._maxSize = maxSize;\n\n    /**\n     * @member {number}\n     * @private\n     */\n    _this._batchSize = batchSize;\n\n    /**\n     * @member {object<number, WebGLBuffer>}\n     * @private\n     */\n    _this._glBuffers = {};\n\n    /**\n     * for every batch stores _updateID corresponding to the last change in that batch\n     * @member {number[]}\n     * @private\n     */\n    _this._bufferUpdateIDs = [];\n\n    /**\n     * when child inserted, removed or changes position this number goes up\n     * @member {number[]}\n     * @private\n     */\n    _this._updateID = 0;\n\n    /**\n     * @member {boolean}\n     *\n     */\n    _this.interactiveChildren = false;\n\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`\n     * to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL\n     * @see PIXI.BLEND_MODES\n     */\n    _this.blendMode = core.BLEND_MODES.NORMAL;\n\n    /**\n     * If true, container allocates more batches in case there are more than `maxSize` particles.\n     * @member {boolean}\n     * @default false\n     */\n    _this.autoResize = autoResize;\n\n    /**\n     * Used for canvas renderering. If true then the elements will be positioned at the\n     * nearest pixel. This provides a nice speed boost.\n     *\n     * @member {boolean}\n     * @default true;\n     */\n    _this.roundPixels = true;\n\n    /**\n     * The texture used to render the children.\n     *\n     * @readonly\n     * @member {BaseTexture}\n     */\n    _this.baseTexture = null;\n    _this.setProperties(properties);\n\n    /**\n     * The tint applied to the container.\n     * This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @private\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    _this._tint = 0;\n    _this.tintRgb = new Float32Array(4);\n    _this.tint = 0xFFFFFF;\n    return _this;\n  }\n\n  /**\n   * Sets the private properties array to dynamic / static based on the passed properties object\n   *\n   * @param {object} properties - The properties to be uploaded\n   */\n\n  ParticleContainer.prototype.setProperties = function setProperties(properties) {\n    if (properties) {\n      this._properties[0] = 'vertices' in properties || 'scale' in properties ? !!properties.vertices || !!properties.scale : this._properties[0];\n      this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];\n      this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];\n      this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];\n      this._properties[4] = 'tint' in properties || 'alpha' in properties ? !!properties.tint || !!properties.alpha : this._properties[4];\n    }\n  };\n\n  /**\n   * Updates the object transform for rendering\n   *\n   * @private\n   */\n\n  ParticleContainer.prototype.updateTransform = function updateTransform() {\n    // TODO don't need to!\n    this.displayObjectUpdateTransform();\n    //  PIXI.Container.prototype.updateTransform.call( this );\n  };\n\n  /**\n   * The tint applied to the container. This is a hex value.\n   * A value of 0xFFFFFF will remove any tint effect.\n   ** IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n   * @member {number}\n   * @default 0xFFFFFF\n   */\n\n  /**\n   * Renders the container using the WebGL renderer\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The webgl renderer\n   */\n  ParticleContainer.prototype.renderWebGL = function renderWebGL(renderer) {\n    var _this2 = this;\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {\n      return;\n    }\n    if (!this.baseTexture) {\n      this.baseTexture = this.children[0]._texture.baseTexture;\n      if (!this.baseTexture.hasLoaded) {\n        this.baseTexture.once('update', function () {\n          return _this2.onChildrenChange(0);\n        });\n      }\n    }\n    renderer.setObjectRenderer(renderer.plugins.particle);\n    renderer.plugins.particle.render(this);\n  };\n\n  /**\n   * Set the flag that static data should be updated to true\n   *\n   * @private\n   * @param {number} smallestChildIndex - The smallest child index\n   */\n\n  ParticleContainer.prototype.onChildrenChange = function onChildrenChange(smallestChildIndex) {\n    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n    while (this._bufferUpdateIDs.length < bufferIndex) {\n      this._bufferUpdateIDs.push(0);\n    }\n    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n  };\n\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The canvas renderer\n   */\n\n  ParticleContainer.prototype.renderCanvas = function renderCanvas(renderer) {\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {\n      return;\n    }\n    var context = renderer.context;\n    var transform = this.worldTransform;\n    var isRotated = true;\n    var positionX = 0;\n    var positionY = 0;\n    var finalWidth = 0;\n    var finalHeight = 0;\n    renderer.setBlendMode(this.blendMode);\n    context.globalAlpha = this.worldAlpha;\n    this.displayObjectUpdateTransform();\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this.children[i];\n      if (!child.visible) {\n        continue;\n      }\n      var frame = child._texture.frame;\n      context.globalAlpha = this.worldAlpha * child.alpha;\n      if (child.rotation % (Math.PI * 2) === 0) {\n        // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n        if (isRotated) {\n          context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx * renderer.resolution, transform.ty * renderer.resolution);\n          isRotated = false;\n        }\n        positionX = child.anchor.x * (-frame.width * child.scale.x) + child.position.x + 0.5;\n        positionY = child.anchor.y * (-frame.height * child.scale.y) + child.position.y + 0.5;\n        finalWidth = frame.width * child.scale.x;\n        finalHeight = frame.height * child.scale.y;\n      } else {\n        if (!isRotated) {\n          isRotated = true;\n        }\n        child.displayObjectUpdateTransform();\n        var childTransform = child.worldTransform;\n        if (renderer.roundPixels) {\n          context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx * renderer.resolution | 0, childTransform.ty * renderer.resolution | 0);\n        } else {\n          context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx * renderer.resolution, childTransform.ty * renderer.resolution);\n        }\n        positionX = child.anchor.x * -frame.width + 0.5;\n        positionY = child.anchor.y * -frame.height + 0.5;\n        finalWidth = frame.width;\n        finalHeight = frame.height;\n      }\n      var resolution = child._texture.baseTexture.resolution;\n      context.drawImage(child._texture.baseTexture.source, frame.x * resolution, frame.y * resolution, frame.width * resolution, frame.height * resolution, positionX * renderer.resolution, positionY * renderer.resolution, finalWidth * renderer.resolution, finalHeight * renderer.resolution);\n    }\n  };\n\n  /**\n   * Destroys the container\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their\n   *  destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n  ParticleContainer.prototype.destroy = function destroy(options) {\n    _core$Container.prototype.destroy.call(this, options);\n    if (this._buffers) {\n      for (var i = 0; i < this._buffers.length; ++i) {\n        this._buffers[i].destroy();\n      }\n    }\n    this._properties = null;\n    this._buffers = null;\n    this._bufferUpdateIDs = null;\n  };\n  _createClass(ParticleContainer, [{\n    key: 'tint',\n    get: function get() {\n      return this._tint;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this._tint = value;\n      (0, _utils.hex2rgb)(value, this.tintRgb);\n    }\n  }]);\n  return ParticleContainer;\n}(core.Container);\nexports.default = ParticleContainer;","map":{"version":3,"names":["_core","require","core","_utils","ParticleContainer","maxSize","arguments","length","undefined","properties","batchSize","autoResize","_classCallCheck","_this","_possibleConstructorReturn","_core$Container","call","maxBatchSize","_properties","_maxSize","_batchSize","_glBuffers","_bufferUpdateIDs","_updateID","interactiveChildren","blendMode","BLEND_MODES","NORMAL","roundPixels","baseTexture","setProperties","_tint","tintRgb","Float32Array","tint","vertices","scale","position","rotation","uvs","alpha","updateTransform","displayObjectUpdateTransform","renderWebGL","renderer","_this2","visible","worldAlpha","children","renderable","_texture","hasLoaded","once","onChildrenChange","setObjectRenderer","plugins","particle","render","smallestChildIndex","bufferIndex","Math","floor","push","renderCanvas","context","transform","worldTransform","isRotated","positionX","positionY","finalWidth","finalHeight","setBlendMode","globalAlpha","i","child","frame","PI","setTransform","a","b","c","d","tx","resolution","ty","anchor","x","width","y","height","childTransform","drawImage","source","destroy","options","prototype","_buffers","value","hex2rgb","Container"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/particles/ParticleContainer.js"],"sourcesContent":["import * as core from '../core';\nimport { hex2rgb } from '../core/utils';\n\n/**\n * The ParticleContainer class is a really fast version of the Container built solely for speed,\n * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that most advanced\n * functionality will not work. ParticleContainer implements the basic object transform (position, scale, rotation)\n * and some advanced functionality like tint (as of v4.5.6).\n * Other more advanced functionality like masking, children, filters, etc will not work on sprites in this batch.\n *\n * It's extremely easy to use :\n *\n * ```js\n * let container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n *     container.addChild(sprite);\n * }\n * ```\n *\n * And here you have a hundred sprites that will be rendered at the speed of light.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.particles\n */\nexport default class ParticleContainer extends core.Container\n{\n    /**\n     * @param {number} [maxSize=1500] - The maximum number of particles that can be rendered by the container.\n     *  Affects size of allocated buffers.\n     * @param {object} [properties] - The properties of children that should be uploaded to the gpu and applied.\n     * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.\n     *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.\n     * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.\n     * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.\n     * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.\n     * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.\n     * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.\n     * @param {boolean} [autoResize=false] If true, container allocates more batches in case\n     *  there are more than `maxSize` particles.\n     */\n    constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false)\n    {\n        super();\n\n        // Making sure the batch size is valid\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        const maxBatchSize = 16384;\n\n        if (batchSize > maxBatchSize)\n        {\n            batchSize = maxBatchSize;\n        }\n\n        if (batchSize > maxSize)\n        {\n            batchSize = maxSize;\n        }\n\n        /**\n         * Set properties to be dynamic (true) / static (false)\n         *\n         * @member {boolean[]}\n         * @private\n         */\n        this._properties = [false, true, false, false, false];\n\n        /**\n         * @member {number}\n         * @private\n         */\n        this._maxSize = maxSize;\n\n        /**\n         * @member {number}\n         * @private\n         */\n        this._batchSize = batchSize;\n\n        /**\n         * @member {object<number, WebGLBuffer>}\n         * @private\n         */\n        this._glBuffers = {};\n\n        /**\n         * for every batch stores _updateID corresponding to the last change in that batch\n         * @member {number[]}\n         * @private\n         */\n        this._bufferUpdateIDs = [];\n\n        /**\n         * when child inserted, removed or changes position this number goes up\n         * @member {number[]}\n         * @private\n         */\n        this._updateID = 0;\n\n        /**\n         * @member {boolean}\n         *\n         */\n        this.interactiveChildren = false;\n\n        /**\n         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`\n         * to reset the blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL\n         * @see PIXI.BLEND_MODES\n         */\n        this.blendMode = core.BLEND_MODES.NORMAL;\n\n        /**\n         * If true, container allocates more batches in case there are more than `maxSize` particles.\n         * @member {boolean}\n         * @default false\n         */\n        this.autoResize = autoResize;\n\n        /**\n         * Used for canvas renderering. If true then the elements will be positioned at the\n         * nearest pixel. This provides a nice speed boost.\n         *\n         * @member {boolean}\n         * @default true;\n         */\n        this.roundPixels = true;\n\n        /**\n         * The texture used to render the children.\n         *\n         * @readonly\n         * @member {BaseTexture}\n         */\n        this.baseTexture = null;\n\n        this.setProperties(properties);\n\n        /**\n         * The tint applied to the container.\n         * This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n         *\n         * @private\n         * @member {number}\n         * @default 0xFFFFFF\n         */\n        this._tint = 0;\n        this.tintRgb = new Float32Array(4);\n        this.tint = 0xFFFFFF;\n    }\n\n    /**\n     * Sets the private properties array to dynamic / static based on the passed properties object\n     *\n     * @param {object} properties - The properties to be uploaded\n     */\n    setProperties(properties)\n    {\n        if (properties)\n        {\n            this._properties[0] = 'vertices' in properties || 'scale' in properties\n                ? !!properties.vertices || !!properties.scale : this._properties[0];\n            this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];\n            this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];\n            this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];\n            this._properties[4] = 'tint' in properties || 'alpha' in properties\n                ? !!properties.tint || !!properties.alpha : this._properties[4];\n        }\n    }\n\n    /**\n     * Updates the object transform for rendering\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        // TODO don't need to!\n        this.displayObjectUpdateTransform();\n        //  PIXI.Container.prototype.updateTransform.call( this );\n    }\n\n    /**\n     * The tint applied to the container. This is a hex value.\n     * A value of 0xFFFFFF will remove any tint effect.\n     ** IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    get tint()\n    {\n        return this._tint;\n    }\n\n    set tint(value) // eslint-disable-line require-jsdoc\n    {\n        this._tint = value;\n        hex2rgb(value, this.tintRgb);\n    }\n\n    /**\n     * Renders the container using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The webgl renderer\n     */\n    renderWebGL(renderer)\n    {\n        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n        {\n            return;\n        }\n\n        if (!this.baseTexture)\n        {\n            this.baseTexture = this.children[0]._texture.baseTexture;\n            if (!this.baseTexture.hasLoaded)\n            {\n                this.baseTexture.once('update', () => this.onChildrenChange(0));\n            }\n        }\n\n        renderer.setObjectRenderer(renderer.plugins.particle);\n        renderer.plugins.particle.render(this);\n    }\n\n    /**\n     * Set the flag that static data should be updated to true\n     *\n     * @private\n     * @param {number} smallestChildIndex - The smallest child index\n     */\n    onChildrenChange(smallestChildIndex)\n    {\n        const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n\n        while (this._bufferUpdateIDs.length < bufferIndex)\n        {\n            this._bufferUpdateIDs.push(0);\n        }\n        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer\n     */\n    renderCanvas(renderer)\n    {\n        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n        {\n            return;\n        }\n\n        const context = renderer.context;\n        const transform = this.worldTransform;\n        let isRotated = true;\n\n        let positionX = 0;\n        let positionY = 0;\n\n        let finalWidth = 0;\n        let finalHeight = 0;\n\n        renderer.setBlendMode(this.blendMode);\n\n        context.globalAlpha = this.worldAlpha;\n\n        this.displayObjectUpdateTransform();\n\n        for (let i = 0; i < this.children.length; ++i)\n        {\n            const child = this.children[i];\n\n            if (!child.visible)\n            {\n                continue;\n            }\n\n            const frame = child._texture.frame;\n\n            context.globalAlpha = this.worldAlpha * child.alpha;\n\n            if (child.rotation % (Math.PI * 2) === 0)\n            {\n                // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n                if (isRotated)\n                {\n                    context.setTransform(\n                        transform.a,\n                        transform.b,\n                        transform.c,\n                        transform.d,\n                        transform.tx * renderer.resolution,\n                        transform.ty * renderer.resolution\n                    );\n\n                    isRotated = false;\n                }\n\n                positionX = ((child.anchor.x) * (-frame.width * child.scale.x)) + child.position.x + 0.5;\n                positionY = ((child.anchor.y) * (-frame.height * child.scale.y)) + child.position.y + 0.5;\n\n                finalWidth = frame.width * child.scale.x;\n                finalHeight = frame.height * child.scale.y;\n            }\n            else\n            {\n                if (!isRotated)\n                {\n                    isRotated = true;\n                }\n\n                child.displayObjectUpdateTransform();\n\n                const childTransform = child.worldTransform;\n\n                if (renderer.roundPixels)\n                {\n                    context.setTransform(\n                        childTransform.a,\n                        childTransform.b,\n                        childTransform.c,\n                        childTransform.d,\n                        (childTransform.tx * renderer.resolution) | 0,\n                        (childTransform.ty * renderer.resolution) | 0\n                    );\n                }\n                else\n                {\n                    context.setTransform(\n                        childTransform.a,\n                        childTransform.b,\n                        childTransform.c,\n                        childTransform.d,\n                        childTransform.tx * renderer.resolution,\n                        childTransform.ty * renderer.resolution\n                    );\n                }\n\n                positionX = ((child.anchor.x) * (-frame.width)) + 0.5;\n                positionY = ((child.anchor.y) * (-frame.height)) + 0.5;\n\n                finalWidth = frame.width;\n                finalHeight = frame.height;\n            }\n\n            const resolution = child._texture.baseTexture.resolution;\n\n            context.drawImage(\n                child._texture.baseTexture.source,\n                frame.x * resolution,\n                frame.y * resolution,\n                frame.width * resolution,\n                frame.height * resolution,\n                positionX * renderer.resolution,\n                positionY * renderer.resolution,\n                finalWidth * renderer.resolution,\n                finalHeight * renderer.resolution\n            );\n        }\n    }\n\n    /**\n     * Destroys the container\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        if (this._buffers)\n        {\n            for (let i = 0; i < this._buffers.length; ++i)\n            {\n                this._buffers[i].destroy();\n            }\n        }\n\n        this._properties = null;\n        this._buffers = null;\n        this._bufferUpdateIDs = null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}