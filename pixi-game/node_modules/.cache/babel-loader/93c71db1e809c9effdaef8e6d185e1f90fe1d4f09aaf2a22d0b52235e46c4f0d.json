{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _core = require('../../core');\nvar core = _interopRequireWildcard(_core);\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar TEMP_RECT = new core.Rectangle();\n\n/**\n * The extract manager provides functionality to export content from the renderers.\n *\n * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract\n *\n * @class\n * @memberof PIXI.extract\n */\n\nvar CanvasExtract = function () {\n  /**\n   * @param {PIXI.CanvasRenderer} renderer - A reference to the current renderer\n   */\n  function CanvasExtract(renderer) {\n    _classCallCheck(this, CanvasExtract);\n    this.renderer = renderer;\n    /**\n     * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture\n     *\n     * @member {PIXI.extract.CanvasExtract} extract\n     * @memberof PIXI.CanvasRenderer#\n     * @see PIXI.extract.CanvasExtract\n     */\n    renderer.extract = this;\n  }\n\n  /**\n   * Will return a HTML Image of the target\n   *\n   * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n   *  to convert. If left empty will use use the main renderer\n   * @return {HTMLImageElement} HTML Image of the target\n   */\n\n  CanvasExtract.prototype.image = function image(target) {\n    var image = new Image();\n    image.src = this.base64(target);\n    return image;\n  };\n\n  /**\n   * Will return a a base64 encoded string of this target. It works by calling\n   *  `CanvasExtract.getCanvas` and then running toDataURL on that.\n   *\n   * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n   *  to convert. If left empty will use use the main renderer\n   * @return {string} A base64 encoded string of the texture.\n   */\n\n  CanvasExtract.prototype.base64 = function base64(target) {\n    return this.canvas(target).toDataURL();\n  };\n\n  /**\n   * Creates a Canvas element, renders this target to it and then returns it.\n   *\n   * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n   *  to convert. If left empty will use use the main renderer\n   * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n   */\n\n  CanvasExtract.prototype.canvas = function canvas(target) {\n    var renderer = this.renderer;\n    var context = void 0;\n    var resolution = void 0;\n    var frame = void 0;\n    var renderTexture = void 0;\n    if (target) {\n      if (target instanceof core.RenderTexture) {\n        renderTexture = target;\n      } else {\n        renderTexture = renderer.generateTexture(target);\n      }\n    }\n    if (renderTexture) {\n      context = renderTexture.baseTexture._canvasRenderTarget.context;\n      resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;\n      frame = renderTexture.frame;\n    } else {\n      context = renderer.rootContext;\n      resolution = renderer.resolution;\n      frame = TEMP_RECT;\n      frame.width = this.renderer.width;\n      frame.height = this.renderer.height;\n    }\n    var width = Math.floor(frame.width * resolution + 1e-4);\n    var height = Math.floor(frame.height * resolution + 1e-4);\n    var canvasBuffer = new core.CanvasRenderTarget(width, height, 1);\n    var canvasData = context.getImageData(frame.x * resolution, frame.y * resolution, width, height);\n    canvasBuffer.context.putImageData(canvasData, 0, 0);\n\n    // send the canvas back..\n    return canvasBuffer.canvas;\n  };\n\n  /**\n   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n   * order, with integer values between 0 and 255 (included).\n   *\n   * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n   *  to convert. If left empty will use use the main renderer\n   * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture\n   */\n\n  CanvasExtract.prototype.pixels = function pixels(target) {\n    var renderer = this.renderer;\n    var context = void 0;\n    var resolution = void 0;\n    var frame = void 0;\n    var renderTexture = void 0;\n    if (target) {\n      if (target instanceof core.RenderTexture) {\n        renderTexture = target;\n      } else {\n        renderTexture = renderer.generateTexture(target);\n      }\n    }\n    if (renderTexture) {\n      context = renderTexture.baseTexture._canvasRenderTarget.context;\n      resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;\n      frame = renderTexture.frame;\n    } else {\n      context = renderer.rootContext;\n      frame = TEMP_RECT;\n      frame.width = renderer.width;\n      frame.height = renderer.height;\n    }\n    return context.getImageData(0, 0, frame.width * resolution, frame.height * resolution).data;\n  };\n\n  /**\n   * Destroys the extract\n   *\n   */\n\n  CanvasExtract.prototype.destroy = function destroy() {\n    this.renderer.extract = null;\n    this.renderer = null;\n  };\n  return CanvasExtract;\n}();\nexports.default = CanvasExtract;\ncore.CanvasRenderer.registerPlugin('extract', CanvasExtract);","map":{"version":3,"names":["_core","require","core","TEMP_RECT","Rectangle","CanvasExtract","renderer","_classCallCheck","extract","image","target","Image","src","base64","canvas","toDataURL","context","resolution","frame","renderTexture","RenderTexture","generateTexture","baseTexture","_canvasRenderTarget","rootContext","width","height","Math","floor","canvasBuffer","CanvasRenderTarget","canvasData","getImageData","x","y","putImageData","pixels","data","destroy","CanvasRenderer","registerPlugin"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/extract/canvas/CanvasExtract.js"],"sourcesContent":["import * as core from '../../core';\n\nconst TEMP_RECT = new core.Rectangle();\n\n/**\n * The extract manager provides functionality to export content from the renderers.\n *\n * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract\n *\n * @class\n * @memberof PIXI.extract\n */\nexport default class CanvasExtract\n{\n    /**\n     * @param {PIXI.CanvasRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n        /**\n         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture\n         *\n         * @member {PIXI.extract.CanvasExtract} extract\n         * @memberof PIXI.CanvasRenderer#\n         * @see PIXI.extract.CanvasExtract\n         */\n        renderer.extract = this;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {HTMLImageElement} HTML Image of the target\n     */\n    image(target)\n    {\n        const image = new Image();\n\n        image.src = this.base64(target);\n\n        return image;\n    }\n\n    /**\n     * Will return a a base64 encoded string of this target. It works by calling\n     *  `CanvasExtract.getCanvas` and then running toDataURL on that.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {string} A base64 encoded string of the texture.\n     */\n    base64(target)\n    {\n        return this.canvas(target).toDataURL();\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n     */\n    canvas(target)\n    {\n        const renderer = this.renderer;\n        let context;\n        let resolution;\n        let frame;\n        let renderTexture;\n\n        if (target)\n        {\n            if (target instanceof core.RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = renderer.generateTexture(target);\n            }\n        }\n\n        if (renderTexture)\n        {\n            context = renderTexture.baseTexture._canvasRenderTarget.context;\n            resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;\n            frame = renderTexture.frame;\n        }\n        else\n        {\n            context = renderer.rootContext;\n            resolution = renderer.resolution;\n            frame = TEMP_RECT;\n            frame.width = this.renderer.width;\n            frame.height = this.renderer.height;\n        }\n\n        const width = Math.floor((frame.width * resolution) + 1e-4);\n        const height = Math.floor((frame.height * resolution) + 1e-4);\n\n        const canvasBuffer = new core.CanvasRenderTarget(width, height, 1);\n        const canvasData = context.getImageData(frame.x * resolution, frame.y * resolution, width, height);\n\n        canvasBuffer.context.putImageData(canvasData, 0, 0);\n\n        // send the canvas back..\n        return canvasBuffer.canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture\n     */\n    pixels(target)\n    {\n        const renderer = this.renderer;\n        let context;\n        let resolution;\n        let frame;\n        let renderTexture;\n\n        if (target)\n        {\n            if (target instanceof core.RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = renderer.generateTexture(target);\n            }\n        }\n\n        if (renderTexture)\n        {\n            context = renderTexture.baseTexture._canvasRenderTarget.context;\n            resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;\n            frame = renderTexture.frame;\n        }\n        else\n        {\n            context = renderer.rootContext;\n\n            frame = TEMP_RECT;\n            frame.width = renderer.width;\n            frame.height = renderer.height;\n        }\n\n        return context.getImageData(0, 0, frame.width * resolution, frame.height * resolution).data;\n    }\n\n    /**\n     * Destroys the extract\n     *\n     */\n    destroy()\n    {\n        this.renderer.extract = null;\n        this.renderer = null;\n    }\n}\n\ncore.CanvasRenderer.registerPlugin('extract', CanvasExtract);\n"],"mappings":";;;AAAA,IAAAA,KAAA,GAAAC,OAAA;IAAYC,I;;;;;;;;;;;;;;;;;;;;AAEZ,IAAMC,SAAA,GAAY,IAAID,IAAA,CAAKE,SAAT,EAAlB;;AAEA;;;;;;;;;IAQqBC,a;EAEjB;;;EAGA,SAAAA,cAAYC,QAAZ,EACA;IAAAC,eAAA,OAAAF,aAAA;IACI,KAAKC,QAAL,GAAgBA,QAAhB;IACA;;;;;;;IAOAA,QAAA,CAASE,OAAT,GAAmB,IAAnB;EACH;;EAED;;;;;;;;0BAOAC,K,kBAAMC,M,EACN;IACI,IAAMD,KAAA,GAAQ,IAAIE,KAAJ,EAAd;IAEAF,KAAA,CAAMG,GAAN,GAAY,KAAKC,MAAL,CAAYH,MAAZ,CAAZ;IAEA,OAAOD,KAAP;EACH,C;;EAED;;;;;;;;;0BAQAI,M,mBAAOH,M,EACP;IACI,OAAO,KAAKI,MAAL,CAAYJ,MAAZ,EAAoBK,SAApB,EAAP;EACH,C;;EAED;;;;;;;;0BAOAD,M,mBAAOJ,M,EACP;IACI,IAAMJ,QAAA,GAAW,KAAKA,QAAtB;IACA,IAAIU,OAAA,SAAJ;IACA,IAAIC,UAAA,SAAJ;IACA,IAAIC,KAAA,SAAJ;IACA,IAAIC,aAAA,SAAJ;IAEA,IAAIT,MAAJ,EACA;MACI,IAAIA,MAAA,YAAkBR,IAAA,CAAKkB,aAA3B,EACA;QACID,aAAA,GAAgBT,MAAhB;MACH,CAHD,MAKA;QACIS,aAAA,GAAgBb,QAAA,CAASe,eAAT,CAAyBX,MAAzB,CAAhB;MACH;IACJ;IAED,IAAIS,aAAJ,EACA;MACIH,OAAA,GAAUG,aAAA,CAAcG,WAAd,CAA0BC,mBAA1B,CAA8CP,OAAxD;MACAC,UAAA,GAAaE,aAAA,CAAcG,WAAd,CAA0BC,mBAA1B,CAA8CN,UAA3D;MACAC,KAAA,GAAQC,aAAA,CAAcD,KAAtB;IACH,CALD,MAOA;MACIF,OAAA,GAAUV,QAAA,CAASkB,WAAnB;MACAP,UAAA,GAAaX,QAAA,CAASW,UAAtB;MACAC,KAAA,GAAQf,SAAR;MACAe,KAAA,CAAMO,KAAN,GAAc,KAAKnB,QAAL,CAAcmB,KAA5B;MACAP,KAAA,CAAMQ,MAAN,GAAe,KAAKpB,QAAL,CAAcoB,MAA7B;IACH;IAED,IAAMD,KAAA,GAAQE,IAAA,CAAKC,KAAL,CAAYV,KAAA,CAAMO,KAAN,GAAcR,UAAf,GAA6B,IAAxC,CAAd;IACA,IAAMS,MAAA,GAASC,IAAA,CAAKC,KAAL,CAAYV,KAAA,CAAMQ,MAAN,GAAeT,UAAhB,GAA8B,IAAzC,CAAf;IAEA,IAAMY,YAAA,GAAe,IAAI3B,IAAA,CAAK4B,kBAAT,CAA4BL,KAA5B,EAAmCC,MAAnC,EAA2C,CAA3C,CAArB;IACA,IAAMK,UAAA,GAAaf,OAAA,CAAQgB,YAAR,CAAqBd,KAAA,CAAMe,CAAN,GAAUhB,UAA/B,EAA2CC,KAAA,CAAMgB,CAAN,GAAUjB,UAArD,EAAiEQ,KAAjE,EAAwEC,MAAxE,CAAnB;IAEAG,YAAA,CAAab,OAAb,CAAqBmB,YAArB,CAAkCJ,UAAlC,EAA8C,CAA9C,EAAiD,CAAjD;;IAEA;IACA,OAAOF,YAAA,CAAaf,MAApB;EACH,C;;EAED;;;;;;;;;0BAQAsB,M,mBAAO1B,M,EACP;IACI,IAAMJ,QAAA,GAAW,KAAKA,QAAtB;IACA,IAAIU,OAAA,SAAJ;IACA,IAAIC,UAAA,SAAJ;IACA,IAAIC,KAAA,SAAJ;IACA,IAAIC,aAAA,SAAJ;IAEA,IAAIT,MAAJ,EACA;MACI,IAAIA,MAAA,YAAkBR,IAAA,CAAKkB,aAA3B,EACA;QACID,aAAA,GAAgBT,MAAhB;MACH,CAHD,MAKA;QACIS,aAAA,GAAgBb,QAAA,CAASe,eAAT,CAAyBX,MAAzB,CAAhB;MACH;IACJ;IAED,IAAIS,aAAJ,EACA;MACIH,OAAA,GAAUG,aAAA,CAAcG,WAAd,CAA0BC,mBAA1B,CAA8CP,OAAxD;MACAC,UAAA,GAAaE,aAAA,CAAcG,WAAd,CAA0BC,mBAA1B,CAA8CN,UAA3D;MACAC,KAAA,GAAQC,aAAA,CAAcD,KAAtB;IACH,CALD,MAOA;MACIF,OAAA,GAAUV,QAAA,CAASkB,WAAnB;MAEAN,KAAA,GAAQf,SAAR;MACAe,KAAA,CAAMO,KAAN,GAAcnB,QAAA,CAASmB,KAAvB;MACAP,KAAA,CAAMQ,MAAN,GAAepB,QAAA,CAASoB,MAAxB;IACH;IAED,OAAOV,OAAA,CAAQgB,YAAR,CAAqB,CAArB,EAAwB,CAAxB,EAA2Bd,KAAA,CAAMO,KAAN,GAAcR,UAAzC,EAAqDC,KAAA,CAAMQ,MAAN,GAAeT,UAApE,EAAgFoB,IAAvF;EACH,C;;EAED;;;;;0BAIAC,O,sBACA;IACI,KAAKhC,QAAL,CAAcE,OAAd,GAAwB,IAAxB;IACA,KAAKF,QAAL,GAAgB,IAAhB;EACH,C;;;kBA3JgBD,a;AA8JrBH,IAAA,CAAKqC,cAAL,CAAoBC,cAApB,CAAmC,SAAnC,EAA8CnC,aAA9C"},"metadata":{},"sourceType":"script","externalDependencies":[]}