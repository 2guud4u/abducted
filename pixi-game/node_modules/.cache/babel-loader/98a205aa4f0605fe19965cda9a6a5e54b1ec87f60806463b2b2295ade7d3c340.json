{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _core = require('../core');\nvar core = _interopRequireWildcard(_core);\nvar _ObservablePoint = require('../core/math/ObservablePoint');\nvar _ObservablePoint2 = _interopRequireDefault(_ObservablePoint);\nvar _utils = require('../core/utils');\nvar _settings = require('../core/settings');\nvar _settings2 = _interopRequireDefault(_settings);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font. To\n * split a line you can use '\\n', '\\r' or '\\r\\n' in your string. You can generate the fnt files using:\n *\n * A BitmapText can only be created when the font is loaded\n *\n * ```js\n * // in this case the font is in a file called 'desyrel.fnt'\n * let bitmapText = new PIXI.extras.BitmapText(\"text using a fancy font!\", {font: \"35px Desyrel\", align: \"right\"});\n * ```\n *\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.extras\n */\nvar BitmapText = function (_core$Container) {\n  _inherits(BitmapText, _core$Container);\n\n  /**\n   * @param {string} text - The copy that you would like the text to display\n   * @param {object} style - The style parameters\n   * @param {string|object} style.font - The font descriptor for the object, can be passed as a string of form\n   *      \"24px FontName\" or \"FontName\" or as an object with explicit name/size properties.\n   * @param {string} [style.font.name] - The bitmap font id\n   * @param {number} [style.font.size] - The size of the font in pixels, e.g. 24\n   * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'), does not affect\n   *      single line text\n   * @param {number} [style.tint=0xFFFFFF] - The tint color\n   */\n  function BitmapText(text) {\n    var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, BitmapText);\n\n    /**\n     * Private tracker for the width of the overall text\n     *\n     * @member {number}\n     * @private\n     */\n    var _this = _possibleConstructorReturn(this, _core$Container.call(this));\n    _this._textWidth = 0;\n\n    /**\n     * Private tracker for the height of the overall text\n     *\n     * @member {number}\n     * @private\n     */\n    _this._textHeight = 0;\n\n    /**\n     * Private tracker for the letter sprite pool.\n     *\n     * @member {PIXI.Sprite[]}\n     * @private\n     */\n    _this._glyphs = [];\n\n    /**\n     * Private tracker for the current style.\n     *\n     * @member {object}\n     * @private\n     */\n    _this._font = {\n      tint: style.tint !== undefined ? style.tint : 0xFFFFFF,\n      align: style.align || 'left',\n      name: null,\n      size: 0\n    };\n\n    /**\n     * Private tracker for the current font.\n     *\n     * @member {object}\n     * @private\n     */\n    _this.font = style.font; // run font setter\n\n    /**\n     * Private tracker for the current text.\n     *\n     * @member {string}\n     * @private\n     */\n    _this._text = text;\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     *\n     * @member {number}\n     * @private\n     */\n    _this._maxWidth = 0;\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align.\n     *\n     * @member {number}\n     * @private\n     */\n    _this._maxLineHeight = 0;\n\n    /**\n     * Letter spacing. This is useful for setting the space between characters.\n     * @member {number}\n     * @private\n     */\n    _this._letterSpacing = 0;\n\n    /**\n     * Text anchor. read-only\n     *\n     * @member {PIXI.ObservablePoint}\n     * @private\n     */\n    _this._anchor = new _ObservablePoint2.default(function () {\n      _this.dirty = true;\n    }, _this, 0, 0);\n\n    /**\n     * The dirty state of this object.\n     *\n     * @member {boolean}\n     */\n    _this.dirty = false;\n    _this.updateText();\n    return _this;\n  }\n\n  /**\n   * Renders text and updates it when needed\n   *\n   * @private\n   */\n\n  BitmapText.prototype.updateText = function updateText() {\n    var data = BitmapText.fonts[this._font.name];\n    var scale = this._font.size / data.size;\n    var pos = new core.Point();\n    var chars = [];\n    var lineWidths = [];\n    var text = this.text.replace(/(?:\\r\\n|\\r)/g, '\\n');\n    var textLength = text.length;\n    var maxWidth = this._maxWidth * data.size / this._font.size;\n    var prevCharCode = null;\n    var lastLineWidth = 0;\n    var maxLineWidth = 0;\n    var line = 0;\n    var lastBreakPos = -1;\n    var lastBreakWidth = 0;\n    var spacesRemoved = 0;\n    var maxLineHeight = 0;\n    for (var i = 0; i < textLength; i++) {\n      var charCode = text.charCodeAt(i);\n      var char = text.charAt(i);\n      if (/(?:\\s)/.test(char)) {\n        lastBreakPos = i;\n        lastBreakWidth = lastLineWidth;\n      }\n      if (char === '\\r' || char === '\\n') {\n        lineWidths.push(lastLineWidth);\n        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        ++line;\n        ++spacesRemoved;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        continue;\n      }\n      var charData = data.chars[charCode];\n      if (!charData) {\n        continue;\n      }\n      if (prevCharCode && charData.kerning[prevCharCode]) {\n        pos.x += charData.kerning[prevCharCode];\n      }\n      chars.push({\n        texture: charData.texture,\n        line: line,\n        charCode: charCode,\n        position: new core.Point(pos.x + charData.xOffset + this._letterSpacing / 2, pos.y + charData.yOffset)\n      });\n      pos.x += charData.xAdvance + this._letterSpacing;\n      lastLineWidth = pos.x;\n      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);\n      prevCharCode = charCode;\n      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {\n        ++spacesRemoved;\n        core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n        i = lastBreakPos;\n        lastBreakPos = -1;\n        lineWidths.push(lastBreakWidth);\n        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n        line++;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n      }\n    }\n    var lastChar = text.charAt(text.length - 1);\n    if (lastChar !== '\\r' && lastChar !== '\\n') {\n      if (/(?:\\s)/.test(lastChar)) {\n        lastLineWidth = lastBreakWidth;\n      }\n      lineWidths.push(lastLineWidth);\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n    }\n    var lineAlignOffsets = [];\n    for (var _i = 0; _i <= line; _i++) {\n      var alignOffset = 0;\n      if (this._font.align === 'right') {\n        alignOffset = maxLineWidth - lineWidths[_i];\n      } else if (this._font.align === 'center') {\n        alignOffset = (maxLineWidth - lineWidths[_i]) / 2;\n      }\n      lineAlignOffsets.push(alignOffset);\n    }\n    var lenChars = chars.length;\n    var tint = this.tint;\n    for (var _i2 = 0; _i2 < lenChars; _i2++) {\n      var c = this._glyphs[_i2]; // get the next glyph sprite\n\n      if (c) {\n        c.texture = chars[_i2].texture;\n      } else {\n        c = new core.Sprite(chars[_i2].texture);\n        this._glyphs.push(c);\n      }\n      c.position.x = (chars[_i2].position.x + lineAlignOffsets[chars[_i2].line]) * scale;\n      c.position.y = chars[_i2].position.y * scale;\n      c.scale.x = c.scale.y = scale;\n      c.tint = tint;\n      if (!c.parent) {\n        this.addChild(c);\n      }\n    }\n\n    // remove unnecessary children.\n    for (var _i3 = lenChars; _i3 < this._glyphs.length; ++_i3) {\n      this.removeChild(this._glyphs[_i3]);\n    }\n    this._textWidth = maxLineWidth * scale;\n    this._textHeight = (pos.y + data.lineHeight) * scale;\n\n    // apply anchor\n    if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n      for (var _i4 = 0; _i4 < lenChars; _i4++) {\n        this._glyphs[_i4].x -= this._textWidth * this.anchor.x;\n        this._glyphs[_i4].y -= this._textHeight * this.anchor.y;\n      }\n    }\n    this._maxLineHeight = maxLineHeight * scale;\n  };\n\n  /**\n   * Updates the transform of this object\n   *\n   * @private\n   */\n\n  BitmapText.prototype.updateTransform = function updateTransform() {\n    this.validate();\n    this.containerUpdateTransform();\n  };\n\n  /**\n   * Validates text before calling parent's getLocalBounds\n   *\n   * @return {PIXI.Rectangle} The rectangular bounding area\n   */\n\n  BitmapText.prototype.getLocalBounds = function getLocalBounds() {\n    this.validate();\n    return _core$Container.prototype.getLocalBounds.call(this);\n  };\n\n  /**\n   * Updates text when needed\n   *\n   * @private\n   */\n\n  BitmapText.prototype.validate = function validate() {\n    if (this.dirty) {\n      this.updateText();\n      this.dirty = false;\n    }\n  };\n\n  /**\n   * The tint of the BitmapText object\n   *\n   * @member {number}\n   */\n\n  /**\n   * Register a bitmap font with data and a texture.\n   *\n   * @static\n   * @param {XMLDocument} xml - The XML document data.\n   * @param {Object.<string, PIXI.Texture>|PIXI.Texture|PIXI.Texture[]} textures - List of textures for each page.\n   *  If providing an object, the key is the `<page>` element's `file` attribute in the FNT file.\n   * @return {Object} Result font object with font, size, lineHeight and char fields.\n   */\n  BitmapText.registerFont = function registerFont(xml, textures) {\n    var data = {};\n    var info = xml.getElementsByTagName('info')[0];\n    var common = xml.getElementsByTagName('common')[0];\n    var pages = xml.getElementsByTagName('page');\n    var res = (0, _utils.getResolutionOfUrl)(pages[0].getAttribute('file'), _settings2.default.RESOLUTION);\n    var pagesTextures = {};\n    data.font = info.getAttribute('face');\n    data.size = parseInt(info.getAttribute('size'), 10);\n    data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) / res;\n    data.chars = {};\n\n    // Single texture, convert to list\n    if (textures instanceof core.Texture) {\n      textures = [textures];\n    }\n\n    // Convert the input Texture, Textures or object\n    // into a page Texture lookup by \"id\"\n    for (var i = 0; i < pages.length; i++) {\n      var id = pages[i].getAttribute('id');\n      var file = pages[i].getAttribute('file');\n      pagesTextures[id] = textures instanceof Array ? textures[i] : textures[file];\n    }\n\n    // parse letters\n    var letters = xml.getElementsByTagName('char');\n    for (var _i5 = 0; _i5 < letters.length; _i5++) {\n      var letter = letters[_i5];\n      var charCode = parseInt(letter.getAttribute('id'), 10);\n      var page = letter.getAttribute('page') || 0;\n      var textureRect = new core.Rectangle(parseInt(letter.getAttribute('x'), 10) / res + pagesTextures[page].frame.x / res, parseInt(letter.getAttribute('y'), 10) / res + pagesTextures[page].frame.y / res, parseInt(letter.getAttribute('width'), 10) / res, parseInt(letter.getAttribute('height'), 10) / res);\n      data.chars[charCode] = {\n        xOffset: parseInt(letter.getAttribute('xoffset'), 10) / res,\n        yOffset: parseInt(letter.getAttribute('yoffset'), 10) / res,\n        xAdvance: parseInt(letter.getAttribute('xadvance'), 10) / res,\n        kerning: {},\n        texture: new core.Texture(pagesTextures[page].baseTexture, textureRect),\n        page: page\n      };\n    }\n\n    // parse kernings\n    var kernings = xml.getElementsByTagName('kerning');\n    for (var _i6 = 0; _i6 < kernings.length; _i6++) {\n      var kerning = kernings[_i6];\n      var first = parseInt(kerning.getAttribute('first'), 10) / res;\n      var second = parseInt(kerning.getAttribute('second'), 10) / res;\n      var amount = parseInt(kerning.getAttribute('amount'), 10) / res;\n      if (data.chars[second]) {\n        data.chars[second].kerning[first] = amount;\n      }\n    }\n\n    // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3\n    // but it's very likely to change\n    BitmapText.fonts[data.font] = data;\n    return data;\n  };\n  _createClass(BitmapText, [{\n    key: 'tint',\n    get: function get() {\n      return this._font.tint;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this._font.tint = typeof value === 'number' && value >= 0 ? value : 0xFFFFFF;\n      this.dirty = true;\n    }\n\n    /**\n     * The alignment of the BitmapText object\n     *\n     * @member {string}\n     * @default 'left'\n     */\n  }, {\n    key: 'align',\n    get: function get() {\n      return this._font.align;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this._font.align = value || 'left';\n      this.dirty = true;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is 0,0 this means the text's origin is the top left\n     * Setting the anchor to 0.5,0.5 means the text's origin is centered\n     * Setting the anchor to 1,1 would mean the text's origin point will be the bottom right corner\n     *\n     * @member {PIXI.Point | number}\n     */\n  }, {\n    key: 'anchor',\n    get: function get() {\n      return this._anchor;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      if (typeof value === 'number') {\n        this._anchor.set(value);\n      } else {\n        this._anchor.copy(value);\n      }\n    }\n\n    /**\n     * The font descriptor of the BitmapText object\n     *\n     * @member {string|object}\n     */\n  }, {\n    key: 'font',\n    get: function get() {\n      return this._font;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      if (!value) {\n        return;\n      }\n      if (typeof value === 'string') {\n        value = value.split(' ');\n        this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');\n        this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;\n      } else {\n        this._font.name = value.name;\n        this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);\n      }\n      this.dirty = true;\n    }\n\n    /**\n     * The text of the BitmapText object\n     *\n     * @member {string}\n     */\n  }, {\n    key: 'text',\n    get: function get() {\n      return this._text;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      value = value.toString() || ' ';\n      if (this._text === value) {\n        return;\n      }\n      this._text = value;\n      this.dirty = true;\n    }\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     *\n     * @member {number}\n     */\n  }, {\n    key: 'maxWidth',\n    get: function get() {\n      return this._maxWidth;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      if (this._maxWidth === value) {\n        return;\n      }\n      this._maxWidth = value;\n      this.dirty = true;\n    }\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align.\n     *\n     * @member {number}\n     * @readonly\n     */\n  }, {\n    key: 'maxLineHeight',\n    get: function get() {\n      this.validate();\n      return this._maxLineHeight;\n    }\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n  }, {\n    key: 'textWidth',\n    get: function get() {\n      this.validate();\n      return this._textWidth;\n    }\n\n    /**\n     * Additional space between characters.\n     *\n     * @member {number}\n     */\n  }, {\n    key: 'letterSpacing',\n    get: function get() {\n      return this._letterSpacing;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      if (this._letterSpacing !== value) {\n        this._letterSpacing = value;\n        this.dirty = true;\n      }\n    }\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n  }, {\n    key: 'textHeight',\n    get: function get() {\n      this.validate();\n      return this._textHeight;\n    }\n  }]);\n  return BitmapText;\n}(core.Container);\nexports.default = BitmapText;\nBitmapText.fonts = {};","map":{"version":3,"names":["_core","require","core","_ObservablePoint","_utils","_settings","BitmapText","text","style","arguments","length","undefined","_classCallCheck","_this","_possibleConstructorReturn","_core$Container","call","_textWidth","_textHeight","_glyphs","_font","tint","align","name","size","font","_text","_maxWidth","_maxLineHeight","_letterSpacing","_anchor","_ObservablePoint2","default","dirty","updateText","data","fonts","scale","pos","Point","chars","lineWidths","replace","textLength","maxWidth","prevCharCode","lastLineWidth","maxLineWidth","line","lastBreakPos","lastBreakWidth","spacesRemoved","maxLineHeight","i","charCode","charCodeAt","char","charAt","test","push","Math","max","x","y","lineHeight","charData","kerning","texture","position","xOffset","yOffset","xAdvance","height","utils","removeItems","lastChar","lineAlignOffsets","_i","alignOffset","lenChars","_i2","c","Sprite","parent","addChild","_i3","removeChild","anchor","_i4","updateTransform","validate","containerUpdateTransform","getLocalBounds","prototype","registerFont","xml","textures","info","getElementsByTagName","common","pages","res","getResolutionOfUrl","getAttribute","_settings2","RESOLUTION","pagesTextures","parseInt","Texture","id","file","Array","letters","_i5","letter","page","textureRect","Rectangle","frame","baseTexture","kernings","_i6","first","second","amount","value","set","copy","split","slice","join","toString","Container"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/extras/BitmapText.js"],"sourcesContent":["import * as core from '../core';\nimport ObservablePoint from '../core/math/ObservablePoint';\nimport { getResolutionOfUrl } from '../core/utils';\nimport settings from '../core/settings';\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font. To\n * split a line you can use '\\n', '\\r' or '\\r\\n' in your string. You can generate the fnt files using:\n *\n * A BitmapText can only be created when the font is loaded\n *\n * ```js\n * // in this case the font is in a file called 'desyrel.fnt'\n * let bitmapText = new PIXI.extras.BitmapText(\"text using a fancy font!\", {font: \"35px Desyrel\", align: \"right\"});\n * ```\n *\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.extras\n */\nexport default class BitmapText extends core.Container\n{\n    /**\n     * @param {string} text - The copy that you would like the text to display\n     * @param {object} style - The style parameters\n     * @param {string|object} style.font - The font descriptor for the object, can be passed as a string of form\n     *      \"24px FontName\" or \"FontName\" or as an object with explicit name/size properties.\n     * @param {string} [style.font.name] - The bitmap font id\n     * @param {number} [style.font.size] - The size of the font in pixels, e.g. 24\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'), does not affect\n     *      single line text\n     * @param {number} [style.tint=0xFFFFFF] - The tint color\n     */\n    constructor(text, style = {})\n    {\n        super();\n\n        /**\n         * Private tracker for the width of the overall text\n         *\n         * @member {number}\n         * @private\n         */\n        this._textWidth = 0;\n\n        /**\n         * Private tracker for the height of the overall text\n         *\n         * @member {number}\n         * @private\n         */\n        this._textHeight = 0;\n\n        /**\n         * Private tracker for the letter sprite pool.\n         *\n         * @member {PIXI.Sprite[]}\n         * @private\n         */\n        this._glyphs = [];\n\n        /**\n         * Private tracker for the current style.\n         *\n         * @member {object}\n         * @private\n         */\n        this._font = {\n            tint: style.tint !== undefined ? style.tint : 0xFFFFFF,\n            align: style.align || 'left',\n            name: null,\n            size: 0,\n        };\n\n        /**\n         * Private tracker for the current font.\n         *\n         * @member {object}\n         * @private\n         */\n        this.font = style.font; // run font setter\n\n        /**\n         * Private tracker for the current text.\n         *\n         * @member {string}\n         * @private\n         */\n        this._text = text;\n\n        /**\n         * The max width of this bitmap text in pixels. If the text provided is longer than the\n         * value provided, line breaks will be automatically inserted in the last whitespace.\n         * Disable by setting value to 0\n         *\n         * @member {number}\n         * @private\n         */\n        this._maxWidth = 0;\n\n        /**\n         * The max line height. This is useful when trying to use the total height of the Text,\n         * ie: when trying to vertically align.\n         *\n         * @member {number}\n         * @private\n         */\n        this._maxLineHeight = 0;\n\n        /**\n         * Letter spacing. This is useful for setting the space between characters.\n         * @member {number}\n         * @private\n         */\n        this._letterSpacing = 0;\n\n        /**\n         * Text anchor. read-only\n         *\n         * @member {PIXI.ObservablePoint}\n         * @private\n         */\n        this._anchor = new ObservablePoint(() => { this.dirty = true; }, this, 0, 0);\n\n        /**\n         * The dirty state of this object.\n         *\n         * @member {boolean}\n         */\n        this.dirty = false;\n\n        this.updateText();\n    }\n\n    /**\n     * Renders text and updates it when needed\n     *\n     * @private\n     */\n    updateText()\n    {\n        const data = BitmapText.fonts[this._font.name];\n        const scale = this._font.size / data.size;\n        const pos = new core.Point();\n        const chars = [];\n        const lineWidths = [];\n        const text = this.text.replace(/(?:\\r\\n|\\r)/g, '\\n');\n        const textLength = text.length;\n        const maxWidth = this._maxWidth * data.size / this._font.size;\n\n        let prevCharCode = null;\n        let lastLineWidth = 0;\n        let maxLineWidth = 0;\n        let line = 0;\n        let lastBreakPos = -1;\n        let lastBreakWidth = 0;\n        let spacesRemoved = 0;\n        let maxLineHeight = 0;\n\n        for (let i = 0; i < textLength; i++)\n        {\n            const charCode = text.charCodeAt(i);\n            const char = text.charAt(i);\n\n            if (/(?:\\s)/.test(char))\n            {\n                lastBreakPos = i;\n                lastBreakWidth = lastLineWidth;\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                lineWidths.push(lastLineWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n                ++line;\n                ++spacesRemoved;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                continue;\n            }\n\n            const charData = data.chars[charCode];\n\n            if (!charData)\n            {\n                continue;\n            }\n\n            if (prevCharCode && charData.kerning[prevCharCode])\n            {\n                pos.x += charData.kerning[prevCharCode];\n            }\n\n            chars.push({\n                texture: charData.texture,\n                line,\n                charCode,\n                position: new core.Point(pos.x + charData.xOffset + (this._letterSpacing / 2), pos.y + charData.yOffset),\n            });\n            pos.x += charData.xAdvance + this._letterSpacing;\n            lastLineWidth = pos.x;\n            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n            prevCharCode = charCode;\n\n            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth)\n            {\n                ++spacesRemoved;\n                core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n                i = lastBreakPos;\n                lastBreakPos = -1;\n\n                lineWidths.push(lastBreakWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n            }\n        }\n\n        const lastChar = text.charAt(text.length - 1);\n\n        if (lastChar !== '\\r' && lastChar !== '\\n')\n        {\n            if (/(?:\\s)/.test(lastChar))\n            {\n                lastLineWidth = lastBreakWidth;\n            }\n\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        }\n\n        const lineAlignOffsets = [];\n\n        for (let i = 0; i <= line; i++)\n        {\n            let alignOffset = 0;\n\n            if (this._font.align === 'right')\n            {\n                alignOffset = maxLineWidth - lineWidths[i];\n            }\n            else if (this._font.align === 'center')\n            {\n                alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            lineAlignOffsets.push(alignOffset);\n        }\n\n        const lenChars = chars.length;\n        const tint = this.tint;\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            let c = this._glyphs[i]; // get the next glyph sprite\n\n            if (c)\n            {\n                c.texture = chars[i].texture;\n            }\n            else\n            {\n                c = new core.Sprite(chars[i].texture);\n                this._glyphs.push(c);\n            }\n\n            c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n            c.position.y = chars[i].position.y * scale;\n            c.scale.x = c.scale.y = scale;\n            c.tint = tint;\n\n            if (!c.parent)\n            {\n                this.addChild(c);\n            }\n        }\n\n        // remove unnecessary children.\n        for (let i = lenChars; i < this._glyphs.length; ++i)\n        {\n            this.removeChild(this._glyphs[i]);\n        }\n\n        this._textWidth = maxLineWidth * scale;\n        this._textHeight = (pos.y + data.lineHeight) * scale;\n\n        // apply anchor\n        if (this.anchor.x !== 0 || this.anchor.y !== 0)\n        {\n            for (let i = 0; i < lenChars; i++)\n            {\n                this._glyphs[i].x -= this._textWidth * this.anchor.x;\n                this._glyphs[i].y -= this._textHeight * this.anchor.y;\n            }\n        }\n        this._maxLineHeight = maxLineHeight * scale;\n    }\n\n    /**\n     * Updates the transform of this object\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        this.validate();\n        this.containerUpdateTransform();\n    }\n\n    /**\n     * Validates text before calling parent's getLocalBounds\n     *\n     * @return {PIXI.Rectangle} The rectangular bounding area\n     */\n    getLocalBounds()\n    {\n        this.validate();\n\n        return super.getLocalBounds();\n    }\n\n    /**\n     * Updates text when needed\n     *\n     * @private\n     */\n    validate()\n    {\n        if (this.dirty)\n        {\n            this.updateText();\n            this.dirty = false;\n        }\n    }\n\n    /**\n     * The tint of the BitmapText object\n     *\n     * @member {number}\n     */\n    get tint()\n    {\n        return this._font.tint;\n    }\n\n    set tint(value) // eslint-disable-line require-jsdoc\n    {\n        this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;\n\n        this.dirty = true;\n    }\n\n    /**\n     * The alignment of the BitmapText object\n     *\n     * @member {string}\n     * @default 'left'\n     */\n    get align()\n    {\n        return this._font.align;\n    }\n\n    set align(value) // eslint-disable-line require-jsdoc\n    {\n        this._font.align = value || 'left';\n\n        this.dirty = true;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is 0,0 this means the text's origin is the top left\n     * Setting the anchor to 0.5,0.5 means the text's origin is centered\n     * Setting the anchor to 1,1 would mean the text's origin point will be the bottom right corner\n     *\n     * @member {PIXI.Point | number}\n     */\n    get anchor()\n    {\n        return this._anchor;\n    }\n\n    set anchor(value) // eslint-disable-line require-jsdoc\n    {\n        if (typeof value === 'number')\n        {\n            this._anchor.set(value);\n        }\n        else\n        {\n            this._anchor.copy(value);\n        }\n    }\n\n    /**\n     * The font descriptor of the BitmapText object\n     *\n     * @member {string|object}\n     */\n    get font()\n    {\n        return this._font;\n    }\n\n    set font(value) // eslint-disable-line require-jsdoc\n    {\n        if (!value)\n        {\n            return;\n        }\n\n        if (typeof value === 'string')\n        {\n            value = value.split(' ');\n\n            this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');\n            this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;\n        }\n        else\n        {\n            this._font.name = value.name;\n            this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);\n        }\n\n        this.dirty = true;\n    }\n\n    /**\n     * The text of the BitmapText object\n     *\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(value) // eslint-disable-line require-jsdoc\n    {\n        value = value.toString() || ' ';\n        if (this._text === value)\n        {\n            return;\n        }\n        this._text = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     *\n     * @member {number}\n     */\n    get maxWidth()\n    {\n        return this._maxWidth;\n    }\n\n    set maxWidth(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._maxWidth === value)\n        {\n            return;\n        }\n        this._maxWidth = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align.\n     *\n     * @member {number}\n     * @readonly\n     */\n    get maxLineHeight()\n    {\n        this.validate();\n\n        return this._maxLineHeight;\n    }\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n    get textWidth()\n    {\n        this.validate();\n\n        return this._textWidth;\n    }\n\n    /**\n     * Additional space between characters.\n     *\n     * @member {number}\n     */\n    get letterSpacing()\n    {\n        return this._letterSpacing;\n    }\n\n    set letterSpacing(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._letterSpacing !== value)\n        {\n            this._letterSpacing = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n    get textHeight()\n    {\n        this.validate();\n\n        return this._textHeight;\n    }\n\n    /**\n     * Register a bitmap font with data and a texture.\n     *\n     * @static\n     * @param {XMLDocument} xml - The XML document data.\n     * @param {Object.<string, PIXI.Texture>|PIXI.Texture|PIXI.Texture[]} textures - List of textures for each page.\n     *  If providing an object, the key is the `<page>` element's `file` attribute in the FNT file.\n     * @return {Object} Result font object with font, size, lineHeight and char fields.\n     */\n    static registerFont(xml, textures)\n    {\n        const data = {};\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const pages = xml.getElementsByTagName('page');\n        const res = getResolutionOfUrl(pages[0].getAttribute('file'), settings.RESOLUTION);\n        const pagesTextures = {};\n\n        data.font = info.getAttribute('face');\n        data.size = parseInt(info.getAttribute('size'), 10);\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) / res;\n        data.chars = {};\n\n        // Single texture, convert to list\n        if (textures instanceof core.Texture)\n        {\n            textures = [textures];\n        }\n\n        // Convert the input Texture, Textures or object\n        // into a page Texture lookup by \"id\"\n        for (let i = 0; i < pages.length; i++)\n        {\n            const id = pages[i].getAttribute('id');\n            const file = pages[i].getAttribute('file');\n\n            pagesTextures[id] = textures instanceof Array ? textures[i] : textures[file];\n        }\n\n        // parse letters\n        const letters = xml.getElementsByTagName('char');\n\n        for (let i = 0; i < letters.length; i++)\n        {\n            const letter = letters[i];\n            const charCode = parseInt(letter.getAttribute('id'), 10);\n            const page = letter.getAttribute('page') || 0;\n            const textureRect = new core.Rectangle(\n                (parseInt(letter.getAttribute('x'), 10) / res) + (pagesTextures[page].frame.x / res),\n                (parseInt(letter.getAttribute('y'), 10) / res) + (pagesTextures[page].frame.y / res),\n                parseInt(letter.getAttribute('width'), 10) / res,\n                parseInt(letter.getAttribute('height'), 10) / res\n            );\n\n            data.chars[charCode] = {\n                xOffset: parseInt(letter.getAttribute('xoffset'), 10) / res,\n                yOffset: parseInt(letter.getAttribute('yoffset'), 10) / res,\n                xAdvance: parseInt(letter.getAttribute('xadvance'), 10) / res,\n                kerning: {},\n                texture: new core.Texture(pagesTextures[page].baseTexture, textureRect),\n                page,\n            };\n        }\n\n        // parse kernings\n        const kernings = xml.getElementsByTagName('kerning');\n\n        for (let i = 0; i < kernings.length; i++)\n        {\n            const kerning = kernings[i];\n            const first = parseInt(kerning.getAttribute('first'), 10) / res;\n            const second = parseInt(kerning.getAttribute('second'), 10) / res;\n            const amount = parseInt(kerning.getAttribute('amount'), 10) / res;\n\n            if (data.chars[second])\n            {\n                data.chars[second].kerning[first] = amount;\n            }\n        }\n\n        // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3\n        // but it's very likely to change\n        BitmapText.fonts[data.font] = data;\n\n        return data;\n    }\n}\n\nBitmapText.fonts = {};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}