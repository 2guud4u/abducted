{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _Filter2 = require('../Filter');\nvar _Filter3 = _interopRequireDefault(_Filter2);\nvar _math = require('../../../../math');\nvar _path = require('path');\nvar _TextureMatrix = require('../../../../textures/TextureMatrix');\nvar _TextureMatrix2 = _interopRequireDefault(_TextureMatrix);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * The SpriteMaskFilter class\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI\n */\nvar SpriteMaskFilter = function (_Filter) {\n  _inherits(SpriteMaskFilter, _Filter);\n\n  /**\n   * @param {PIXI.Sprite} sprite - the target sprite\n   */\n  function SpriteMaskFilter(sprite) {\n    _classCallCheck(this, SpriteMaskFilter);\n    var maskMatrix = new _math.Matrix();\n    var _this = _possibleConstructorReturn(this, _Filter.call(this, 'attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 otherMatrix;\\n\\nvarying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\\n}\\n', 'varying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D mask;\\nuniform float alpha;\\nuniform vec4 maskClamp;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(maskClamp.x, vMaskCoord.x) +\\n        step(maskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, maskClamp.z) +\\n        step(vMaskCoord.y, maskClamp.w));\\n\\n    vec4 original = texture2D(uSampler, vTextureCoord);\\n    vec4 masky = texture2D(mask, vMaskCoord);\\n\\n    original *= (masky.r * masky.a * alpha * clip);\\n\\n    gl_FragColor = original;\\n}\\n'));\n    sprite.renderable = false;\n    _this.maskSprite = sprite;\n    _this.maskMatrix = maskMatrix;\n    return _this;\n  }\n\n  /**\n   * Applies the filter\n   *\n   * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from\n   * @param {PIXI.RenderTarget} input - The input render target.\n   * @param {PIXI.RenderTarget} output - The target to output to.\n   * @param {boolean} clear - Should the output be cleared before rendering to it\n   */\n\n  SpriteMaskFilter.prototype.apply = function apply(filterManager, input, output, clear) {\n    var maskSprite = this.maskSprite;\n    var tex = this.maskSprite.texture;\n    if (!tex.valid) {\n      return;\n    }\n    if (!tex.transform) {\n      // margin = 0.0, let it bleed a bit, shader code becomes easier\n      // assuming that atlas textures were made with 1-pixel padding\n      tex.transform = new _TextureMatrix2.default(tex, 0.0);\n    }\n    tex.transform.update();\n    this.uniforms.mask = tex;\n    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.transform.mapCoord);\n    this.uniforms.alpha = maskSprite.worldAlpha;\n    this.uniforms.maskClamp = tex.transform.uClampFrame;\n    filterManager.applyFilter(this, input, output, clear);\n  };\n  return SpriteMaskFilter;\n}(_Filter3.default);\nexports.default = SpriteMaskFilter;","map":{"version":3,"names":["_Filter2","require","_math","_path","_TextureMatrix","SpriteMaskFilter","sprite","_classCallCheck","maskMatrix","Matrix","_this","_possibleConstructorReturn","_Filter","call","renderable","maskSprite","apply","filterManager","input","output","clear","tex","texture","valid","transform","_TextureMatrix2","default","update","uniforms","mask","otherMatrix","calculateSpriteMatrix","prepend","mapCoord","alpha","worldAlpha","maskClamp","uClampFrame","applyFilter"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/renderers/webgl/filters/spriteMask/SpriteMaskFilter.js"],"sourcesContent":["import Filter from '../Filter';\nimport { Matrix } from '../../../../math';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\nimport { default as TextureMatrix } from '../../../../textures/TextureMatrix';\n\n/**\n * The SpriteMaskFilter class\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI\n */\nexport default class SpriteMaskFilter extends Filter\n{\n    /**\n     * @param {PIXI.Sprite} sprite - the target sprite\n     */\n    constructor(sprite)\n    {\n        const maskMatrix = new Matrix();\n\n        super(\n            readFileSync(join(__dirname, './spriteMaskFilter.vert'), 'utf8'),\n            readFileSync(join(__dirname, './spriteMaskFilter.frag'), 'utf8')\n        );\n\n        sprite.renderable = false;\n\n        this.maskSprite = sprite;\n        this.maskMatrix = maskMatrix;\n    }\n\n    /**\n     * Applies the filter\n     *\n     * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from\n     * @param {PIXI.RenderTarget} input - The input render target.\n     * @param {PIXI.RenderTarget} output - The target to output to.\n     * @param {boolean} clear - Should the output be cleared before rendering to it\n     */\n    apply(filterManager, input, output, clear)\n    {\n        const maskSprite = this.maskSprite;\n        const tex = this.maskSprite.texture;\n\n        if (!tex.valid)\n        {\n            return;\n        }\n        if (!tex.transform)\n        {\n            // margin = 0.0, let it bleed a bit, shader code becomes easier\n            // assuming that atlas textures were made with 1-pixel padding\n            tex.transform = new TextureMatrix(tex, 0.0);\n        }\n        tex.transform.update();\n\n        this.uniforms.mask = tex;\n        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite)\n            .prepend(tex.transform.mapCoord);\n        this.uniforms.alpha = maskSprite.worldAlpha;\n        this.uniforms.maskClamp = tex.transform.uClampFrame;\n\n        filterManager.applyFilter(this, input, output, clear);\n    }\n}\n"],"mappings":";;;AAAA,IAAAA,QAAA,GAAAC,OAAA;;AACA,IAAAC,KAAA,GAAAD,OAAA;AAEA,IAAAE,KAAA,GAAAF,OAAA;AACA,IAAAG,cAAA,GAAAH,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;IAOqBI,gB;;;EAEjB;;;EAGA,SAAAA,iBAAYC,MAAZ,EACA;IAAAC,eAAA,OAAAF,gBAAA;IACI,IAAMG,UAAA,GAAa,IAAAN,KAAA,CAAAO,MAAA,EAAnB;IADJ,IAAAC,KAAA,GAAAC,0BAAA,OAGIC,OAAA,CAAAC,IAAA,69BAHJ;IAQIP,MAAA,CAAOQ,UAAP,GAAoB,KAApB;IAEAJ,KAAA,CAAKK,UAAL,GAAkBT,MAAlB;IACAI,KAAA,CAAKF,UAAL,GAAkBA,UAAlB;IAXJ,OAAAE,KAAA;EAYC;;EAED;;;;;;;;;6BAQAM,K,kBAAMC,a,EAAeC,K,EAAOC,M,EAAQC,K,EACpC;IACI,IAAML,UAAA,GAAa,KAAKA,UAAxB;IACA,IAAMM,GAAA,GAAM,KAAKN,UAAL,CAAgBO,OAA5B;IAEA,IAAI,CAACD,GAAA,CAAIE,KAAT,EACA;MACI;IACH;IACD,IAAI,CAACF,GAAA,CAAIG,SAAT,EACA;MACI;MACA;MACAH,GAAA,CAAIG,SAAJ,GAAgB,IAAAC,eAAA,CAAAC,OAAA,CAAkBL,GAAlB,EAAuB,GAAvB,CAAhB;IACH;IACDA,GAAA,CAAIG,SAAJ,CAAcG,MAAd;IAEA,KAAKC,QAAL,CAAcC,IAAd,GAAqBR,GAArB;IACA,KAAKO,QAAL,CAAcE,WAAd,GAA4Bb,aAAA,CAAcc,qBAAd,CAAoC,KAAKvB,UAAzC,EAAqDO,UAArD,EACvBiB,OADuB,CACfX,GAAA,CAAIG,SAAJ,CAAcS,QADC,CAA5B;IAEA,KAAKL,QAAL,CAAcM,KAAd,GAAsBnB,UAAA,CAAWoB,UAAjC;IACA,KAAKP,QAAL,CAAcQ,SAAd,GAA0Bf,GAAA,CAAIG,SAAJ,CAAca,WAAxC;IAEApB,aAAA,CAAcqB,WAAd,CAA0B,IAA1B,EAAgCpB,KAAhC,EAAuCC,MAAvC,EAA+CC,KAA/C;EACH,C;;;kBApDgBf,gB"},"metadata":{},"sourceType":"script","externalDependencies":[]}