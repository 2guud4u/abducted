{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _Matrix = require('./Matrix');\nvar _Matrix2 = _interopRequireDefault(_Matrix);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]; // Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16\n\nvar uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nvar tempMatrices = [];\nvar mul = [];\nfunction signum(x) {\n  if (x < 0) {\n    return -1;\n  }\n  if (x > 0) {\n    return 1;\n  }\n  return 0;\n}\nfunction init() {\n  for (var i = 0; i < 16; i++) {\n    var row = [];\n    mul.push(row);\n    for (var j = 0; j < 16; j++) {\n      var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (var k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (var _i = 0; _i < 16; _i++) {\n    var mat = new _Matrix2.default();\n    mat.set(ux[_i], uy[_i], vx[_i], vy[_i], 0, 0);\n    tempMatrices.push(mat);\n  }\n}\ninit();\n\n/**\n * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html},\n * D8 is the same but with diagonals. Used for texture rotations.\n *\n * Vector xX(i), xY(i) is U-axis of sprite with rotation i\n * Vector yY(i), yY(i) is V-axis of sprite with rotation i\n * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)\n * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)\n * This is the small part of gameofbombs.com portal system. It works.\n *\n * @author Ivan @ivanpopelyshev\n * @class\n * @memberof PIXI\n */\nvar GroupD8 = {\n  E: 0,\n  SE: 1,\n  S: 2,\n  SW: 3,\n  W: 4,\n  NW: 5,\n  N: 6,\n  NE: 7,\n  MIRROR_VERTICAL: 8,\n  MIRROR_HORIZONTAL: 12,\n  uX: function uX(ind) {\n    return ux[ind];\n  },\n  uY: function uY(ind) {\n    return uy[ind];\n  },\n  vX: function vX(ind) {\n    return vx[ind];\n  },\n  vY: function vY(ind) {\n    return vy[ind];\n  },\n  inv: function inv(rotation) {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  add: function add(rotationSecond, rotationFirst) {\n    return mul[rotationSecond][rotationFirst];\n  },\n  sub: function sub(rotationSecond, rotationFirst) {\n    return mul[rotationSecond][GroupD8.inv(rotationFirst)];\n  },\n  /**\n   * Adds 180 degrees to rotation. Commutative operation.\n   *\n   * @memberof PIXI.GroupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} rotated number\n   */\n  rotate180: function rotate180(rotation) {\n    return rotation ^ 4;\n  },\n  /**\n   * Direction of main vector can be horizontal, vertical or diagonal.\n   * Some objects work with vertical directions different.\n   *\n   * @memberof PIXI.GroupD8\n   * @param {number} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: function isVertical(rotation) {\n    return (rotation & 3) === 2;\n  },\n  /**\n   * @memberof PIXI.GroupD8\n   * @param {number} dx - TODO\n   * @param {number} dy - TODO\n   *\n   * @return {number} TODO\n   */\n  byDirection: function byDirection(dx, dy) {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return GroupD8.S;\n      }\n      return GroupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return GroupD8.E;\n      }\n      return GroupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return GroupD8.SE;\n      }\n      return GroupD8.SW;\n    } else if (dx > 0) {\n      return GroupD8.NE;\n    }\n    return GroupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   *\n   * @memberof PIXI.GroupD8\n   * @param {PIXI.Matrix} matrix - sprite world matrix\n   * @param {number} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: function matrixAppendRotationInv(matrix, rotation) {\n    var tx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var ty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    // Packer used \"rotation\", we use \"inv(rotation)\"\n    var mat = tempMatrices[GroupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\nexports.default = GroupD8;","map":{"version":3,"names":["_Matrix","require","ux","uy","vx","vy","tempMatrices","mul","signum","x","init","i","row","push","j","_ux","_uy","_vx","_vy","k","_i","mat","_Matrix2","default","set","GroupD8","E","SE","S","SW","W","NW","N","NE","MIRROR_VERTICAL","MIRROR_HORIZONTAL","uX","ind","uY","vX","vY","inv","rotation","add","rotationSecond","rotationFirst","sub","rotate180","isVertical","byDirection","dx","dy","Math","abs","matrixAppendRotationInv","matrix","tx","arguments","length","undefined","ty","append"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/math/GroupD8.js"],"sourcesContent":["// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16\nimport Matrix from './Matrix';\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst tempMatrices = [];\n\nconst mul = [];\n\nfunction signum(x)\n{\n    if (x < 0)\n    {\n        return -1;\n    }\n    if (x > 0)\n    {\n        return 1;\n    }\n\n    return 0;\n}\n\nfunction init()\n{\n    for (let i = 0; i < 16; i++)\n    {\n        const row = [];\n\n        mul.push(row);\n\n        for (let j = 0; j < 16; j++)\n        {\n            const _ux = signum((ux[i] * ux[j]) + (vx[i] * uy[j]));\n            const _uy = signum((uy[i] * ux[j]) + (vy[i] * uy[j]));\n            const _vx = signum((ux[i] * vx[j]) + (vx[i] * vy[j]));\n            const _vy = signum((uy[i] * vx[j]) + (vy[i] * vy[j]));\n\n            for (let k = 0; k < 16; k++)\n            {\n                if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy)\n                {\n                    row.push(k);\n                    break;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < 16; i++)\n    {\n        const mat = new Matrix();\n\n        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n        tempMatrices.push(mat);\n    }\n}\n\ninit();\n\n/**\n * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html},\n * D8 is the same but with diagonals. Used for texture rotations.\n *\n * Vector xX(i), xY(i) is U-axis of sprite with rotation i\n * Vector yY(i), yY(i) is V-axis of sprite with rotation i\n * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)\n * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)\n * This is the small part of gameofbombs.com portal system. It works.\n *\n * @author Ivan @ivanpopelyshev\n * @class\n * @memberof PIXI\n */\nconst GroupD8 = {\n    E: 0,\n    SE: 1,\n    S: 2,\n    SW: 3,\n    W: 4,\n    NW: 5,\n    N: 6,\n    NE: 7,\n    MIRROR_VERTICAL: 8,\n    MIRROR_HORIZONTAL: 12,\n    uX: (ind) => ux[ind],\n    uY: (ind) => uy[ind],\n    vX: (ind) => vx[ind],\n    vY: (ind) => vy[ind],\n    inv: (rotation) =>\n    {\n        if (rotation & 8)\n        {\n            return rotation & 15;\n        }\n\n        return (-rotation) & 7;\n    },\n    add: (rotationSecond, rotationFirst) => mul[rotationSecond][rotationFirst],\n    sub: (rotationSecond, rotationFirst) => mul[rotationSecond][GroupD8.inv(rotationFirst)],\n\n    /**\n     * Adds 180 degrees to rotation. Commutative operation.\n     *\n     * @memberof PIXI.GroupD8\n     * @param {number} rotation - The number to rotate.\n     * @returns {number} rotated number\n     */\n    rotate180: (rotation) => rotation ^ 4,\n\n    /**\n     * Direction of main vector can be horizontal, vertical or diagonal.\n     * Some objects work with vertical directions different.\n     *\n     * @memberof PIXI.GroupD8\n     * @param {number} rotation - The number to check.\n     * @returns {boolean} Whether or not the direction is vertical\n     */\n    isVertical: (rotation) => (rotation & 3) === 2,\n\n    /**\n     * @memberof PIXI.GroupD8\n     * @param {number} dx - TODO\n     * @param {number} dy - TODO\n     *\n     * @return {number} TODO\n     */\n    byDirection: (dx, dy) =>\n    {\n        if (Math.abs(dx) * 2 <= Math.abs(dy))\n        {\n            if (dy >= 0)\n            {\n                return GroupD8.S;\n            }\n\n            return GroupD8.N;\n        }\n        else if (Math.abs(dy) * 2 <= Math.abs(dx))\n        {\n            if (dx > 0)\n            {\n                return GroupD8.E;\n            }\n\n            return GroupD8.W;\n        }\n        else if (dy > 0)\n        {\n            if (dx > 0)\n            {\n                return GroupD8.SE;\n            }\n\n            return GroupD8.SW;\n        }\n        else if (dx > 0)\n        {\n            return GroupD8.NE;\n        }\n\n        return GroupD8.NW;\n    },\n\n    /**\n     * Helps sprite to compensate texture packer rotation.\n     *\n     * @memberof PIXI.GroupD8\n     * @param {PIXI.Matrix} matrix - sprite world matrix\n     * @param {number} rotation - The rotation factor to use.\n     * @param {number} tx - sprite anchoring\n     * @param {number} ty - sprite anchoring\n     */\n    matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) =>\n    {\n        // Packer used \"rotation\", we use \"inv(rotation)\"\n        const mat = tempMatrices[GroupD8.inv(rotation)];\n\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    },\n};\n\nexport default GroupD8;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}