{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.Resource = undefined;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _parseUri = require('parse-uri');\nvar _parseUri2 = _interopRequireDefault(_parseUri);\nvar _miniSignals = require('mini-signals');\nvar _miniSignals2 = _interopRequireDefault(_miniSignals);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n// tests if CORS is supported in XHR, if not we need to use XDR\nvar useXdr = !!(window.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));\nvar tempAnchor = null;\n\n// some status constants\nvar STATUS_NONE = 0;\nvar STATUS_OK = 200;\nvar STATUS_EMPTY = 204;\nvar STATUS_IE_BUG_EMPTY = 1223;\nvar STATUS_TYPE_OK = 2;\n\n// noop\nfunction _noop() {} /* empty */\n\n/**\n * Manages the state and loading of a resource and all child resources.\n *\n * @class\n */\n\nvar Resource = exports.Resource = function () {\n  /**\n   * Sets the load type to be used for a specific extension.\n   *\n   * @static\n   * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n   * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n   */\n  Resource.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {\n    setExtMap(Resource._loadTypeMap, extname, loadType);\n  };\n\n  /**\n   * Sets the load type to be used for a specific extension.\n   *\n   * @static\n   * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n   * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n   */\n\n  Resource.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {\n    setExtMap(Resource._xhrTypeMap, extname, xhrType);\n  };\n\n  /**\n   * @param {string} name - The name of the resource to load.\n   * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n   *      an array of sources.\n   * @param {object} [options] - The options for the load.\n   * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n   *      determine automatically.\n   * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n   *      longer than this time it is cancelled and the load is considered a failure. If this value is\n   *      set to `0` then there is no explicit timeout.\n   * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n   *      be loaded?\n   * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n   *      should the data being loaded be interpreted when using XHR?\n   * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.\n   */\n\n  function Resource(name, url, options) {\n    _classCallCheck(this, Resource);\n    if (typeof name !== 'string' || typeof url !== 'string') {\n      throw new Error('Both name and url are required for constructing a resource.');\n    }\n    options = options || {};\n\n    /**\n     * The state flags of this resource.\n     *\n     * @private\n     * @member {number}\n     */\n    this._flags = 0;\n\n    // set data url flag, needs to be set early for some _determineX checks to work.\n    this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n\n    /**\n     * The name of this resource.\n     *\n     * @readonly\n     * @member {string}\n     */\n    this.name = name;\n\n    /**\n     * The url used to load this resource.\n     *\n     * @readonly\n     * @member {string}\n     */\n    this.url = url;\n\n    /**\n     * The extension used to load this resource.\n     *\n     * @readonly\n     * @member {string}\n     */\n    this.extension = this._getExtension();\n\n    /**\n     * The data that was loaded by the resource.\n     *\n     * @member {any}\n     */\n    this.data = null;\n\n    /**\n     * Is this request cross-origin? If unset, determined automatically.\n     *\n     * @member {string}\n     */\n    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n\n    /**\n     * A timeout in milliseconds for the load. If the load takes longer than this time\n     * it is cancelled and the load is considered a failure. If this value is set to `0`\n     * then there is no explicit timeout.\n     *\n     * @member {number}\n     */\n    this.timeout = options.timeout || 0;\n\n    /**\n     * The method of loading to use for this resource.\n     *\n     * @member {Resource.LOAD_TYPE}\n     */\n    this.loadType = options.loadType || this._determineLoadType();\n\n    /**\n     * The type used to load the resource via XHR. If unset, determined automatically.\n     *\n     * @member {string}\n     */\n    this.xhrType = options.xhrType;\n\n    /**\n     * Extra info for middleware, and controlling specifics about how the resource loads.\n     *\n     * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n     * Meaning it will modify it as it sees fit.\n     *\n     * @member {Resource.IMetadata}\n     */\n    this.metadata = options.metadata || {};\n\n    /**\n     * The error that occurred while loading (if any).\n     *\n     * @readonly\n     * @member {Error}\n     */\n    this.error = null;\n\n    /**\n     * The XHR object that was used to load this resource. This is only set\n     * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n     *\n     * @readonly\n     * @member {XMLHttpRequest}\n     */\n    this.xhr = null;\n\n    /**\n     * The child resources this resource owns.\n     *\n     * @readonly\n     * @member {Resource[]}\n     */\n    this.children = [];\n\n    /**\n     * The resource type.\n     *\n     * @readonly\n     * @member {Resource.TYPE}\n     */\n    this.type = Resource.TYPE.UNKNOWN;\n\n    /**\n     * The progress chunk owned by this resource.\n     *\n     * @readonly\n     * @member {number}\n     */\n    this.progressChunk = 0;\n\n    /**\n     * The `dequeue` method that will be used a storage place for the async queue dequeue method\n     * used privately by the loader.\n     *\n     * @private\n     * @member {function}\n     */\n    this._dequeue = _noop;\n\n    /**\n     * Used a storage place for the on load binding used privately by the loader.\n     *\n     * @private\n     * @member {function}\n     */\n    this._onLoadBinding = null;\n\n    /**\n     * The timer for element loads to check if they timeout.\n     *\n     * @private\n     * @member {number}\n     */\n    this._elementTimer = 0;\n\n    /**\n     * The `complete` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundComplete = this.complete.bind(this);\n\n    /**\n     * The `_onError` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundOnError = this._onError.bind(this);\n\n    /**\n     * The `_onProgress` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundOnProgress = this._onProgress.bind(this);\n\n    /**\n     * The `_onTimeout` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundOnTimeout = this._onTimeout.bind(this);\n\n    // xhr callbacks\n    this._boundXhrOnError = this._xhrOnError.bind(this);\n    this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n\n    /**\n     * Dispatched when the resource beings to load.\n     *\n     * The callback looks like {@link Resource.OnStartSignal}.\n     *\n     * @member {Signal<Resource.OnStartSignal>}\n     */\n    this.onStart = new _miniSignals2.default();\n\n    /**\n     * Dispatched each time progress of this resource load updates.\n     * Not all resources types and loader systems can support this event\n     * so sometimes it may not be available. If the resource\n     * is being loaded on a modern browser, using XHR, and the remote server\n     * properly sets Content-Length headers, then this will be available.\n     *\n     * The callback looks like {@link Resource.OnProgressSignal}.\n     *\n     * @member {Signal<Resource.OnProgressSignal>}\n     */\n    this.onProgress = new _miniSignals2.default();\n\n    /**\n     * Dispatched once this resource has loaded, if there was an error it will\n     * be in the `error` property.\n     *\n     * The callback looks like {@link Resource.OnCompleteSignal}.\n     *\n     * @member {Signal<Resource.OnCompleteSignal>}\n     */\n    this.onComplete = new _miniSignals2.default();\n\n    /**\n     * Dispatched after this resource has had all the *after* middleware run on it.\n     *\n     * The callback looks like {@link Resource.OnCompleteSignal}.\n     *\n     * @member {Signal<Resource.OnCompleteSignal>}\n     */\n    this.onAfterMiddleware = new _miniSignals2.default();\n  }\n\n  /**\n   * When the resource starts to load.\n   *\n   * @memberof Resource\n   * @callback OnStartSignal\n   * @param {Resource} resource - The resource that the event happened on.\n   */\n\n  /**\n   * When the resource reports loading progress.\n   *\n   * @memberof Resource\n   * @callback OnProgressSignal\n   * @param {Resource} resource - The resource that the event happened on.\n   * @param {number} percentage - The progress of the load in the range [0, 1].\n   */\n\n  /**\n   * When the resource finishes loading.\n   *\n   * @memberof Resource\n   * @callback OnCompleteSignal\n   * @param {Resource} resource - The resource that the event happened on.\n   */\n\n  /**\n   * @memberof Resource\n   * @typedef {object} IMetadata\n   * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n   *      element to use for loading, instead of creating one.\n   * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n   *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n   * @property {string|string[]} [mimeType] - The mime type to use for the source element\n   *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n   *      where each index is the mime type to use for the corresponding url index.\n   */\n\n  /**\n   * Stores whether or not this url is a data url.\n   *\n   * @readonly\n   * @member {boolean}\n   */\n\n  /**\n   * Marks the resource as complete.\n   *\n   */\n  Resource.prototype.complete = function complete() {\n    this._clearEvents();\n    this._finish();\n  };\n\n  /**\n   * Aborts the loading of this resource, with an optional message.\n   *\n   * @param {string} message - The message to use for the error\n   */\n\n  Resource.prototype.abort = function abort(message) {\n    // abort can be called multiple times, ignore subsequent calls.\n    if (this.error) {\n      return;\n    }\n\n    // store error\n    this.error = new Error(message);\n\n    // clear events before calling aborts\n    this._clearEvents();\n\n    // abort the actual loading\n    if (this.xhr) {\n      this.xhr.abort();\n    } else if (this.xdr) {\n      this.xdr.abort();\n    } else if (this.data) {\n      // single source\n      if (this.data.src) {\n        this.data.src = Resource.EMPTY_GIF;\n      }\n      // multi-source\n      else {\n        while (this.data.firstChild) {\n          this.data.removeChild(this.data.firstChild);\n        }\n      }\n    }\n\n    // done now.\n    this._finish();\n  };\n\n  /**\n   * Kicks off loading of this resource. This method is asynchronous.\n   *\n   * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n   */\n\n  Resource.prototype.load = function load(cb) {\n    var _this = this;\n    if (this.isLoading) {\n      return;\n    }\n    if (this.isComplete) {\n      if (cb) {\n        setTimeout(function () {\n          return cb(_this);\n        }, 1);\n      }\n      return;\n    } else if (cb) {\n      this.onComplete.once(cb);\n    }\n    this._setFlag(Resource.STATUS_FLAGS.LOADING, true);\n    this.onStart.dispatch(this);\n\n    // if unset, determine the value\n    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n      this.crossOrigin = this._determineCrossOrigin(this.url);\n    }\n    switch (this.loadType) {\n      case Resource.LOAD_TYPE.IMAGE:\n        this.type = Resource.TYPE.IMAGE;\n        this._loadElement('image');\n        break;\n      case Resource.LOAD_TYPE.AUDIO:\n        this.type = Resource.TYPE.AUDIO;\n        this._loadSourceElement('audio');\n        break;\n      case Resource.LOAD_TYPE.VIDEO:\n        this.type = Resource.TYPE.VIDEO;\n        this._loadSourceElement('video');\n        break;\n      case Resource.LOAD_TYPE.XHR:\n      /* falls through */\n      default:\n        if (useXdr && this.crossOrigin) {\n          this._loadXdr();\n        } else {\n          this._loadXhr();\n        }\n        break;\n    }\n  };\n\n  /**\n   * Checks if the flag is set.\n   *\n   * @private\n   * @param {number} flag - The flag to check.\n   * @return {boolean} True if the flag is set.\n   */\n\n  Resource.prototype._hasFlag = function _hasFlag(flag) {\n    return (this._flags & flag) !== 0;\n  };\n\n  /**\n   * (Un)Sets the flag.\n   *\n   * @private\n   * @param {number} flag - The flag to (un)set.\n   * @param {boolean} value - Whether to set or (un)set the flag.\n   */\n\n  Resource.prototype._setFlag = function _setFlag(flag, value) {\n    this._flags = value ? this._flags | flag : this._flags & ~flag;\n  };\n\n  /**\n   * Clears all the events from the underlying loading source.\n   *\n   * @private\n   */\n\n  Resource.prototype._clearEvents = function _clearEvents() {\n    clearTimeout(this._elementTimer);\n    if (this.data && this.data.removeEventListener) {\n      this.data.removeEventListener('error', this._boundOnError, false);\n      this.data.removeEventListener('load', this._boundComplete, false);\n      this.data.removeEventListener('progress', this._boundOnProgress, false);\n      this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n    }\n    if (this.xhr) {\n      if (this.xhr.removeEventListener) {\n        this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n        this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n        this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n        this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n        this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n      } else {\n        this.xhr.onerror = null;\n        this.xhr.ontimeout = null;\n        this.xhr.onprogress = null;\n        this.xhr.onload = null;\n      }\n    }\n  };\n\n  /**\n   * Finalizes the load.\n   *\n   * @private\n   */\n\n  Resource.prototype._finish = function _finish() {\n    if (this.isComplete) {\n      throw new Error('Complete called again for an already completed resource.');\n    }\n    this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);\n    this._setFlag(Resource.STATUS_FLAGS.LOADING, false);\n    this.onComplete.dispatch(this);\n  };\n\n  /**\n   * Loads this resources using an element that has a single source,\n   * like an HTMLImageElement.\n   *\n   * @private\n   * @param {string} type - The type of element to use.\n   */\n\n  Resource.prototype._loadElement = function _loadElement(type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === 'image' && typeof window.Image !== 'undefined') {\n      this.data = new Image();\n    } else {\n      this.data = document.createElement(type);\n    }\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n    if (!this.metadata.skipSource) {\n      this.data.src = this.url;\n    }\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  };\n\n  /**\n   * Loads this resources using an element that has multiple sources,\n   * like an HTMLAudioElement or HTMLVideoElement.\n   *\n   * @private\n   * @param {string} type - The type of element to use.\n   */\n\n  Resource.prototype._loadSourceElement = function _loadSourceElement(type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n      this.data = new Audio();\n    } else {\n      this.data = document.createElement(type);\n    }\n    if (this.data === null) {\n      this.abort('Unsupported element: ' + type);\n      return;\n    }\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n    if (!this.metadata.skipSource) {\n      // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n      if (navigator.isCocoonJS) {\n        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n      } else if (Array.isArray(this.url)) {\n        var mimeTypes = this.metadata.mimeType;\n        for (var i = 0; i < this.url.length; ++i) {\n          this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));\n        }\n      } else {\n        var _mimeTypes = this.metadata.mimeType;\n        this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));\n      }\n    }\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n    this.data.addEventListener('canplaythrough', this._boundComplete, false);\n    this.data.load();\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  };\n\n  /**\n   * Loads this resources using an XMLHttpRequest.\n   *\n   * @private\n   */\n\n  Resource.prototype._loadXhr = function _loadXhr() {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n      this.xhrType = this._determineXhrType();\n    }\n    var xhr = this.xhr = new XMLHttpRequest();\n\n    // set the request type and url\n    xhr.open('GET', this.url, true);\n    xhr.timeout = this.timeout;\n\n    // load json as text and parse it ourselves. We do this because some browsers\n    // *cough* safari *cough* can't deal with it.\n    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n      xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n    } else {\n      xhr.responseType = this.xhrType;\n    }\n    xhr.addEventListener('error', this._boundXhrOnError, false);\n    xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n    xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n    xhr.addEventListener('progress', this._boundOnProgress, false);\n    xhr.addEventListener('load', this._boundXhrOnLoad, false);\n    xhr.send();\n  };\n\n  /**\n   * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n   *\n   * @private\n   */\n\n  Resource.prototype._loadXdr = function _loadXdr() {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n      this.xhrType = this._determineXhrType();\n    }\n    var xdr = this.xhr = new XDomainRequest(); // eslint-disable-line no-undef\n\n    // XDomainRequest has a few quirks. Occasionally it will abort requests\n    // A way to avoid this is to make sure ALL callbacks are set even if not used\n    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n    xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n\n    xdr.onerror = this._boundXhrOnError;\n    xdr.ontimeout = this._boundXhrOnTimeout;\n    xdr.onprogress = this._boundOnProgress;\n    xdr.onload = this._boundXhrOnLoad;\n    xdr.open('GET', this.url, true);\n\n    // Note: The xdr.send() call is wrapped in a timeout to prevent an\n    // issue with the interface where some requests are lost if multiple\n    // XDomainRequests are being sent at the same time.\n    // Some info here: https://github.com/photonstorm/phaser/issues/1248\n    setTimeout(function () {\n      return xdr.send();\n    }, 1);\n  };\n\n  /**\n   * Creates a source used in loading via an element.\n   *\n   * @private\n   * @param {string} type - The element type (video or audio).\n   * @param {string} url - The source URL to load from.\n   * @param {string} [mime] - The mime type of the video\n   * @return {HTMLSourceElement} The source element.\n   */\n\n  Resource.prototype._createSource = function _createSource(type, url, mime) {\n    if (!mime) {\n      mime = type + '/' + this._getExtension(url);\n    }\n    var source = document.createElement('source');\n    source.src = url;\n    source.type = mime;\n    return source;\n  };\n\n  /**\n   * Called if a load errors out.\n   *\n   * @param {Event} event - The error event from the element that emits it.\n   * @private\n   */\n\n  Resource.prototype._onError = function _onError(event) {\n    this.abort('Failed to load element using: ' + event.target.nodeName);\n  };\n\n  /**\n   * Called if a load progress event fires for an element or xhr/xdr.\n   *\n   * @private\n   * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n   */\n\n  Resource.prototype._onProgress = function _onProgress(event) {\n    if (event && event.lengthComputable) {\n      this.onProgress.dispatch(this, event.loaded / event.total);\n    }\n  };\n\n  /**\n   * Called if a timeout event fires for an element.\n   *\n   * @private\n   */\n\n  Resource.prototype._onTimeout = function _onTimeout() {\n    this.abort('Load timed out.');\n  };\n\n  /**\n   * Called if an error event fires for xhr/xdr.\n   *\n   * @private\n   */\n\n  Resource.prototype._xhrOnError = function _xhrOnError() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: \"' + xhr.statusText + '\"');\n  };\n\n  /**\n   * Called if an error event fires for xhr/xdr.\n   *\n   * @private\n   */\n\n  Resource.prototype._xhrOnTimeout = function _xhrOnTimeout() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + ' Request timed out.');\n  };\n\n  /**\n   * Called if an abort event fires for xhr/xdr.\n   *\n   * @private\n   */\n\n  Resource.prototype._xhrOnAbort = function _xhrOnAbort() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + ' Request was aborted by the user.');\n  };\n\n  /**\n   * Called when data successfully loads from an xhr/xdr request.\n   *\n   * @private\n   * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n   */\n\n  Resource.prototype._xhrOnLoad = function _xhrOnLoad() {\n    var xhr = this.xhr;\n    var text = '';\n    var status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n\n    // responseText is accessible only if responseType is '' or 'text' and on older browsers\n    if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {\n      text = xhr.responseText;\n    }\n\n    // status can be 0 when using the `file://` protocol so we also check if a response is set.\n    // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n    if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER)) {\n      status = STATUS_OK;\n    }\n    // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n    else if (status === STATUS_IE_BUG_EMPTY) {\n      status = STATUS_EMPTY;\n    }\n    var statusType = status / 100 | 0;\n    if (statusType === STATUS_TYPE_OK) {\n      // if text, just return it\n      if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n        this.data = text;\n        this.type = Resource.TYPE.TEXT;\n      }\n      // if json, parse into json object\n      else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n        try {\n          this.data = JSON.parse(text);\n          this.type = Resource.TYPE.JSON;\n        } catch (e) {\n          this.abort('Error trying to parse loaded json: ' + e);\n          return;\n        }\n      }\n      // if xml, parse into an xml document or div element\n      else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n        try {\n          if (window.DOMParser) {\n            var domparser = new DOMParser();\n            this.data = domparser.parseFromString(text, 'text/xml');\n          } else {\n            var div = document.createElement('div');\n            div.innerHTML = text;\n            this.data = div;\n          }\n          this.type = Resource.TYPE.XML;\n        } catch (e) {\n          this.abort('Error trying to parse loaded xml: ' + e);\n          return;\n        }\n      }\n      // other types just return the response\n      else {\n        this.data = xhr.response || text;\n      }\n    } else {\n      this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL);\n      return;\n    }\n    this.complete();\n  };\n\n  /**\n   * Sets the `crossOrigin` property for this resource based on if the url\n   * for this resource is cross-origin. If crossOrigin was manually set, this\n   * function does nothing.\n   *\n   * @private\n   * @param {string} url - The url to test.\n   * @param {object} [loc=window.location] - The location object to test against.\n   * @return {string} The crossOrigin value to use (or empty string for none).\n   */\n\n  Resource.prototype._determineCrossOrigin = function _determineCrossOrigin(url, loc) {\n    // data: and javascript: urls are considered same-origin\n    if (url.indexOf('data:') === 0) {\n      return '';\n    }\n\n    // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n    // origin designed not to match window.location.origin, and will always require\n    // crossOrigin requests regardless of whether the location matches.\n    if (window.origin !== window.location.origin) {\n      return 'anonymous';\n    }\n\n    // default is window.location\n    loc = loc || window.location;\n    if (!tempAnchor) {\n      tempAnchor = document.createElement('a');\n    }\n\n    // let the browser determine the full href for the url of this resource and then\n    // parse with the node url lib, we can't use the properties of the anchor element\n    // because they don't work in IE9 :(\n    tempAnchor.href = url;\n    url = (0, _parseUri2.default)(tempAnchor.href, {\n      strictMode: true\n    });\n    var samePort = !url.port && loc.port === '' || url.port === loc.port;\n    var protocol = url.protocol ? url.protocol + ':' : '';\n\n    // if cross origin\n    if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n      return 'anonymous';\n    }\n    return '';\n  };\n\n  /**\n   * Determines the responseType of an XHR request based on the extension of the\n   * resource being loaded.\n   *\n   * @private\n   * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n   */\n\n  Resource.prototype._determineXhrType = function _determineXhrType() {\n    return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;\n  };\n\n  /**\n   * Determines the loadType of a resource based on the extension of the\n   * resource being loaded.\n   *\n   * @private\n   * @return {Resource.LOAD_TYPE} The loadType to use.\n   */\n\n  Resource.prototype._determineLoadType = function _determineLoadType() {\n    return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;\n  };\n\n  /**\n   * Extracts the extension (sans '.') of the file being loaded by the resource.\n   *\n   * @private\n   * @return {string} The extension.\n   */\n\n  Resource.prototype._getExtension = function _getExtension() {\n    var url = this.url;\n    var ext = '';\n    if (this.isDataUrl) {\n      var slashIndex = url.indexOf('/');\n      ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n    } else {\n      var queryStart = url.indexOf('?');\n      var hashStart = url.indexOf('#');\n      var index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);\n      url = url.substring(0, index);\n      ext = url.substring(url.lastIndexOf('.') + 1);\n    }\n    return ext.toLowerCase();\n  };\n\n  /**\n   * Determines the mime type of an XHR request based on the responseType of\n   * resource being loaded.\n   *\n   * @private\n   * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n   * @return {string} The mime type to use.\n   */\n\n  Resource.prototype._getMimeFromXhrType = function _getMimeFromXhrType(type) {\n    switch (type) {\n      case Resource.XHR_RESPONSE_TYPE.BUFFER:\n        return 'application/octet-binary';\n      case Resource.XHR_RESPONSE_TYPE.BLOB:\n        return 'application/blob';\n      case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n        return 'application/xml';\n      case Resource.XHR_RESPONSE_TYPE.JSON:\n        return 'application/json';\n      case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n      case Resource.XHR_RESPONSE_TYPE.TEXT:\n      /* falls through */\n      default:\n        return 'text/plain';\n    }\n  };\n  _createClass(Resource, [{\n    key: 'isDataUrl',\n    get: function get() {\n      return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);\n    }\n\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n  }, {\n    key: 'isComplete',\n    get: function get() {\n      return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);\n    }\n\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n  }, {\n    key: 'isLoading',\n    get: function get() {\n      return this._hasFlag(Resource.STATUS_FLAGS.LOADING);\n    }\n  }]);\n  return Resource;\n}();\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\n\nResource.STATUS_FLAGS = {\n  NONE: 0,\n  DATA_URL: 1 << 0,\n  COMPLETE: 1 << 1,\n  LOADING: 1 << 2\n};\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.TYPE = {\n  UNKNOWN: 0,\n  JSON: 1,\n  XML: 2,\n  IMAGE: 3,\n  AUDIO: 4,\n  VIDEO: 5,\n  TEXT: 6\n};\n\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.LOAD_TYPE = {\n  /** Uses XMLHttpRequest to load the resource. */\n  XHR: 1,\n  /** Uses an `Image` object to load the resource. */\n  IMAGE: 2,\n  /** Uses an `Audio` object to load the resource. */\n  AUDIO: 3,\n  /** Uses a `Video` object to load the resource. */\n  VIDEO: 4\n};\n\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\nResource.XHR_RESPONSE_TYPE = {\n  /** string */\n  DEFAULT: 'text',\n  /** ArrayBuffer */\n  BUFFER: 'arraybuffer',\n  /** Blob */\n  BLOB: 'blob',\n  /** Document */\n  DOCUMENT: 'document',\n  /** Object */\n  JSON: 'json',\n  /** String */\n  TEXT: 'text'\n};\nResource._loadTypeMap = {\n  // images\n  gif: Resource.LOAD_TYPE.IMAGE,\n  png: Resource.LOAD_TYPE.IMAGE,\n  bmp: Resource.LOAD_TYPE.IMAGE,\n  jpg: Resource.LOAD_TYPE.IMAGE,\n  jpeg: Resource.LOAD_TYPE.IMAGE,\n  tif: Resource.LOAD_TYPE.IMAGE,\n  tiff: Resource.LOAD_TYPE.IMAGE,\n  webp: Resource.LOAD_TYPE.IMAGE,\n  tga: Resource.LOAD_TYPE.IMAGE,\n  svg: Resource.LOAD_TYPE.IMAGE,\n  'svg+xml': Resource.LOAD_TYPE.IMAGE,\n  // for SVG data urls\n\n  // audio\n  mp3: Resource.LOAD_TYPE.AUDIO,\n  ogg: Resource.LOAD_TYPE.AUDIO,\n  wav: Resource.LOAD_TYPE.AUDIO,\n  // videos\n  mp4: Resource.LOAD_TYPE.VIDEO,\n  webm: Resource.LOAD_TYPE.VIDEO\n};\nResource._xhrTypeMap = {\n  // xml\n  xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n  // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n  // this should probably be fine.\n  tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  // images\n  gif: Resource.XHR_RESPONSE_TYPE.BLOB,\n  png: Resource.XHR_RESPONSE_TYPE.BLOB,\n  bmp: Resource.XHR_RESPONSE_TYPE.BLOB,\n  jpg: Resource.XHR_RESPONSE_TYPE.BLOB,\n  jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tif: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tiff: Resource.XHR_RESPONSE_TYPE.BLOB,\n  webp: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tga: Resource.XHR_RESPONSE_TYPE.BLOB,\n  // json\n  json: Resource.XHR_RESPONSE_TYPE.JSON,\n  // text\n  text: Resource.XHR_RESPONSE_TYPE.TEXT,\n  txt: Resource.XHR_RESPONSE_TYPE.TEXT,\n  // fonts\n  ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,\n  otf: Resource.XHR_RESPONSE_TYPE.BUFFER\n};\n\n// We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\nResource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n\n/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n *\n * @ignore\n * @param {object} map - The map to set on.\n * @param {string} extname - The extension (or key) to set.\n * @param {number} val - The value to set.\n */\nfunction setExtMap(map, extname, val) {\n  if (extname && extname.indexOf('.') === 0) {\n    extname = extname.substring(1);\n  }\n  if (!extname) {\n    return;\n  }\n  map[extname] = val;\n}\n\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\nfunction reqType(xhr) {\n  return xhr.toString().replace('object ', '');\n}\n\n// Backwards compat\nif (typeof module !== 'undefined') {\n  module.exports.default = Resource; // eslint-disable-line no-undef\n}","map":{"version":3,"names":["_parseUri","require","_miniSignals","useXdr","window","XDomainRequest","XMLHttpRequest","tempAnchor","STATUS_NONE","STATUS_OK","STATUS_EMPTY","STATUS_IE_BUG_EMPTY","STATUS_TYPE_OK","_noop","Resource","setExtensionLoadType","extname","loadType","setExtMap","_loadTypeMap","setExtensionXhrType","xhrType","_xhrTypeMap","name","url","options","_classCallCheck","Error","_flags","_setFlag","STATUS_FLAGS","DATA_URL","indexOf","extension","_getExtension","data","crossOrigin","timeout","_determineLoadType","metadata","error","xhr","children","type","TYPE","UNKNOWN","progressChunk","_dequeue","_onLoadBinding","_elementTimer","_boundComplete","complete","bind","_boundOnError","_onError","_boundOnProgress","_onProgress","_boundOnTimeout","_onTimeout","_boundXhrOnError","_xhrOnError","_boundXhrOnTimeout","_xhrOnTimeout","_boundXhrOnAbort","_xhrOnAbort","_boundXhrOnLoad","_xhrOnLoad","onStart","_miniSignals2","default","onProgress","onComplete","onAfterMiddleware","_clearEvents","_finish","abort","message","xdr","src","EMPTY_GIF","firstChild","removeChild","load","cb","_this","isLoading","isComplete","setTimeout","once","LOADING","dispatch","_determineCrossOrigin","LOAD_TYPE","IMAGE","_loadElement","AUDIO","_loadSourceElement","VIDEO","XHR","_loadXdr","_loadXhr","_hasFlag","flag","value","clearTimeout","removeEventListener","onerror","ontimeout","onprogress","onload","COMPLETE","loadElement","Image","document","createElement","skipSource","addEventListener","Audio","navigator","isCocoonJS","Array","isArray","mimeTypes","mimeType","i","length","appendChild","_createSource","_mimeTypes","_determineXhrType","open","XHR_RESPONSE_TYPE","JSON","DOCUMENT","responseType","TEXT","send","mime","source","event","target","nodeName","lengthComputable","loaded","total","reqType","status","statusText","text","responseText","BUFFER","statusType","parse","e","DOMParser","domparser","parseFromString","div","innerHTML","XML","response","responseURL","loc","origin","location","href","_parseUri2","strictMode","samePort","port","protocol","host","hostname","ext","isDataUrl","slashIndex","substring","queryStart","hashStart","index","Math","min","lastIndexOf","toLowerCase","_getMimeFromXhrType","BLOB","DEFAULT","NONE","gif","png","bmp","jpg","jpeg","tif","tiff","webp","tga","svg","mp3","ogg","wav","mp4","webm","xhtml","html","htm","xml","tmx","tsx","json","txt","ttf","otf","map","val","toString","replace","module","exports"],"sources":["/Users/jiahuajiang/node_modules/resource-loader/src/Resource.js"],"sourcesContent":["import parseUri from 'parse-uri';\nimport Signal from 'mini-signals';\n\n// tests if CORS is supported in XHR, if not we need to use XDR\nconst useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest())));\nlet tempAnchor = null;\n\n// some status constants\nconst STATUS_NONE = 0;\nconst STATUS_OK = 200;\nconst STATUS_EMPTY = 204;\nconst STATUS_IE_BUG_EMPTY = 1223;\nconst STATUS_TYPE_OK = 2;\n\n// noop\nfunction _noop() { /* empty */ }\n\n/**\n * Manages the state and loading of a resource and all child resources.\n *\n * @class\n */\nexport class Resource {\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n     */\n    static setExtensionLoadType(extname, loadType) {\n        setExtMap(Resource._loadTypeMap, extname, loadType);\n    }\n\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n     */\n    static setExtensionXhrType(extname, xhrType) {\n        setExtMap(Resource._xhrTypeMap, extname, xhrType);\n    }\n\n    /**\n     * @param {string} name - The name of the resource to load.\n     * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n     *      an array of sources.\n     * @param {object} [options] - The options for the load.\n     * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n     *      determine automatically.\n     * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n     *      longer than this time it is cancelled and the load is considered a failure. If this value is\n     *      set to `0` then there is no explicit timeout.\n     * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n     *      be loaded?\n     * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n     *      should the data being loaded be interpreted when using XHR?\n     * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.\n     */\n    constructor(name, url, options) {\n        if (typeof name !== 'string' || typeof url !== 'string') {\n            throw new Error('Both name and url are required for constructing a resource.');\n        }\n\n        options = options || {};\n\n        /**\n         * The state flags of this resource.\n         *\n         * @private\n         * @member {number}\n         */\n        this._flags = 0;\n\n        // set data url flag, needs to be set early for some _determineX checks to work.\n        this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n\n        /**\n         * The name of this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.name = name;\n\n        /**\n         * The url used to load this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.url = url;\n\n        /**\n         * The extension used to load this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.extension = this._getExtension();\n\n        /**\n         * The data that was loaded by the resource.\n         *\n         * @member {any}\n         */\n        this.data = null;\n\n        /**\n         * Is this request cross-origin? If unset, determined automatically.\n         *\n         * @member {string}\n         */\n        this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n\n        /**\n         * A timeout in milliseconds for the load. If the load takes longer than this time\n         * it is cancelled and the load is considered a failure. If this value is set to `0`\n         * then there is no explicit timeout.\n         *\n         * @member {number}\n         */\n        this.timeout = options.timeout || 0;\n\n        /**\n         * The method of loading to use for this resource.\n         *\n         * @member {Resource.LOAD_TYPE}\n         */\n        this.loadType = options.loadType || this._determineLoadType();\n\n        /**\n         * The type used to load the resource via XHR. If unset, determined automatically.\n         *\n         * @member {string}\n         */\n        this.xhrType = options.xhrType;\n\n        /**\n         * Extra info for middleware, and controlling specifics about how the resource loads.\n         *\n         * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n         * Meaning it will modify it as it sees fit.\n         *\n         * @member {Resource.IMetadata}\n         */\n        this.metadata = options.metadata || {};\n\n        /**\n         * The error that occurred while loading (if any).\n         *\n         * @readonly\n         * @member {Error}\n         */\n        this.error = null;\n\n        /**\n         * The XHR object that was used to load this resource. This is only set\n         * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n         *\n         * @readonly\n         * @member {XMLHttpRequest}\n         */\n        this.xhr = null;\n\n        /**\n         * The child resources this resource owns.\n         *\n         * @readonly\n         * @member {Resource[]}\n         */\n        this.children = [];\n\n        /**\n         * The resource type.\n         *\n         * @readonly\n         * @member {Resource.TYPE}\n         */\n        this.type = Resource.TYPE.UNKNOWN;\n\n        /**\n         * The progress chunk owned by this resource.\n         *\n         * @readonly\n         * @member {number}\n         */\n        this.progressChunk = 0;\n\n        /**\n         * The `dequeue` method that will be used a storage place for the async queue dequeue method\n         * used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */\n        this._dequeue = _noop;\n\n        /**\n         * Used a storage place for the on load binding used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */\n        this._onLoadBinding = null;\n\n        /**\n         * The timer for element loads to check if they timeout.\n         *\n         * @private\n         * @member {number}\n         */\n        this._elementTimer = 0;\n\n        /**\n         * The `complete` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundComplete = this.complete.bind(this);\n\n        /**\n         * The `_onError` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnError = this._onError.bind(this);\n\n        /**\n         * The `_onProgress` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnProgress = this._onProgress.bind(this);\n\n        /**\n         * The `_onTimeout` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnTimeout = this._onTimeout.bind(this);\n\n        // xhr callbacks\n        this._boundXhrOnError = this._xhrOnError.bind(this);\n        this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n\n        /**\n         * Dispatched when the resource beings to load.\n         *\n         * The callback looks like {@link Resource.OnStartSignal}.\n         *\n         * @member {Signal<Resource.OnStartSignal>}\n         */\n        this.onStart = new Signal();\n\n        /**\n         * Dispatched each time progress of this resource load updates.\n         * Not all resources types and loader systems can support this event\n         * so sometimes it may not be available. If the resource\n         * is being loaded on a modern browser, using XHR, and the remote server\n         * properly sets Content-Length headers, then this will be available.\n         *\n         * The callback looks like {@link Resource.OnProgressSignal}.\n         *\n         * @member {Signal<Resource.OnProgressSignal>}\n         */\n        this.onProgress = new Signal();\n\n        /**\n         * Dispatched once this resource has loaded, if there was an error it will\n         * be in the `error` property.\n         *\n         * The callback looks like {@link Resource.OnCompleteSignal}.\n         *\n         * @member {Signal<Resource.OnCompleteSignal>}\n         */\n        this.onComplete = new Signal();\n\n        /**\n         * Dispatched after this resource has had all the *after* middleware run on it.\n         *\n         * The callback looks like {@link Resource.OnCompleteSignal}.\n         *\n         * @member {Signal<Resource.OnCompleteSignal>}\n         */\n        this.onAfterMiddleware = new Signal();\n    }\n\n    /**\n     * When the resource starts to load.\n     *\n     * @memberof Resource\n     * @callback OnStartSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * When the resource reports loading progress.\n     *\n     * @memberof Resource\n     * @callback OnProgressSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     * @param {number} percentage - The progress of the load in the range [0, 1].\n     */\n\n    /**\n     * When the resource finishes loading.\n     *\n     * @memberof Resource\n     * @callback OnCompleteSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * @memberof Resource\n     * @typedef {object} IMetadata\n     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n     *      element to use for loading, instead of creating one.\n     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n     *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n     * @property {string|string[]} [mimeType] - The mime type to use for the source element\n     *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n     *      where each index is the mime type to use for the corresponding url index.\n     */\n\n    /**\n     * Stores whether or not this url is a data url.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isDataUrl() {\n        return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);\n    }\n\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isComplete() {\n        return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);\n    }\n\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isLoading() {\n        return this._hasFlag(Resource.STATUS_FLAGS.LOADING);\n    }\n\n    /**\n     * Marks the resource as complete.\n     *\n     */\n    complete() {\n        this._clearEvents();\n        this._finish();\n    }\n\n    /**\n     * Aborts the loading of this resource, with an optional message.\n     *\n     * @param {string} message - The message to use for the error\n     */\n    abort(message) {\n        // abort can be called multiple times, ignore subsequent calls.\n        if (this.error) {\n            return;\n        }\n\n        // store error\n        this.error = new Error(message);\n\n        // clear events before calling aborts\n        this._clearEvents();\n\n        // abort the actual loading\n        if (this.xhr) {\n            this.xhr.abort();\n        }\n        else if (this.xdr) {\n            this.xdr.abort();\n        }\n        else if (this.data) {\n            // single source\n            if (this.data.src) {\n                this.data.src = Resource.EMPTY_GIF;\n            }\n            // multi-source\n            else {\n                while (this.data.firstChild) {\n                    this.data.removeChild(this.data.firstChild);\n                }\n            }\n        }\n\n        // done now.\n        this._finish();\n    }\n\n    /**\n     * Kicks off loading of this resource. This method is asynchronous.\n     *\n     * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n     */\n    load(cb) {\n        if (this.isLoading) {\n            return;\n        }\n\n        if (this.isComplete) {\n            if (cb) {\n                setTimeout(() => cb(this), 1);\n            }\n\n            return;\n        }\n        else if (cb) {\n            this.onComplete.once(cb);\n        }\n\n        this._setFlag(Resource.STATUS_FLAGS.LOADING, true);\n\n        this.onStart.dispatch(this);\n\n        // if unset, determine the value\n        if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n            this.crossOrigin = this._determineCrossOrigin(this.url);\n        }\n\n        switch (this.loadType) {\n            case Resource.LOAD_TYPE.IMAGE:\n                this.type = Resource.TYPE.IMAGE;\n                this._loadElement('image');\n                break;\n\n            case Resource.LOAD_TYPE.AUDIO:\n                this.type = Resource.TYPE.AUDIO;\n                this._loadSourceElement('audio');\n                break;\n\n            case Resource.LOAD_TYPE.VIDEO:\n                this.type = Resource.TYPE.VIDEO;\n                this._loadSourceElement('video');\n                break;\n\n            case Resource.LOAD_TYPE.XHR:\n                /* falls through */\n            default:\n                if (useXdr && this.crossOrigin) {\n                    this._loadXdr();\n                }\n                else {\n                    this._loadXhr();\n                }\n                break;\n        }\n    }\n\n    /**\n     * Checks if the flag is set.\n     *\n     * @private\n     * @param {number} flag - The flag to check.\n     * @return {boolean} True if the flag is set.\n     */\n    _hasFlag(flag) {\n        return (this._flags & flag) !== 0;\n    }\n\n    /**\n     * (Un)Sets the flag.\n     *\n     * @private\n     * @param {number} flag - The flag to (un)set.\n     * @param {boolean} value - Whether to set or (un)set the flag.\n     */\n    _setFlag(flag, value) {\n        this._flags = value ? (this._flags | flag) : (this._flags & ~flag);\n    }\n\n    /**\n     * Clears all the events from the underlying loading source.\n     *\n     * @private\n     */\n    _clearEvents() {\n        clearTimeout(this._elementTimer);\n\n        if (this.data && this.data.removeEventListener) {\n            this.data.removeEventListener('error', this._boundOnError, false);\n            this.data.removeEventListener('load', this._boundComplete, false);\n            this.data.removeEventListener('progress', this._boundOnProgress, false);\n            this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n        }\n\n        if (this.xhr) {\n            if (this.xhr.removeEventListener) {\n                this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n                this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n                this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n                this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n                this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n            }\n            else {\n                this.xhr.onerror = null;\n                this.xhr.ontimeout = null;\n                this.xhr.onprogress = null;\n                this.xhr.onload = null;\n            }\n        }\n    }\n\n    /**\n     * Finalizes the load.\n     *\n     * @private\n     */\n    _finish() {\n        if (this.isComplete) {\n            throw new Error('Complete called again for an already completed resource.');\n        }\n\n        this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);\n        this._setFlag(Resource.STATUS_FLAGS.LOADING, false);\n\n        this.onComplete.dispatch(this);\n    }\n\n    /**\n     * Loads this resources using an element that has a single source,\n     * like an HTMLImageElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n    _loadElement(type) {\n        if (this.metadata.loadElement) {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'image' && typeof window.Image !== 'undefined') {\n            this.data = new Image();\n        }\n        else {\n            this.data = document.createElement(type);\n        }\n\n        if (this.crossOrigin) {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource) {\n            this.data.src = this.url;\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n\n        if (this.timeout) {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n        }\n    }\n\n    /**\n     * Loads this resources using an element that has multiple sources,\n     * like an HTMLAudioElement or HTMLVideoElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n    _loadSourceElement(type) {\n        if (this.metadata.loadElement) {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n            this.data = new Audio();\n        }\n        else {\n            this.data = document.createElement(type);\n        }\n\n        if (this.data === null) {\n            this.abort(`Unsupported element: ${type}`);\n\n            return;\n        }\n\n        if (this.crossOrigin) {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource) {\n            // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n            if (navigator.isCocoonJS) {\n                this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n            }\n            else if (Array.isArray(this.url)) {\n                const mimeTypes = this.metadata.mimeType;\n\n                for (let i = 0; i < this.url.length; ++i) {\n                    this.data.appendChild(\n                        this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes)\n                    );\n                }\n            }\n            else {\n                const mimeTypes = this.metadata.mimeType;\n\n                this.data.appendChild(\n                    this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes)\n                );\n            }\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n        this.data.addEventListener('canplaythrough', this._boundComplete, false);\n\n        this.data.load();\n\n        if (this.timeout) {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n        }\n    }\n\n    /**\n     * Loads this resources using an XMLHttpRequest.\n     *\n     * @private\n     */\n    _loadXhr() {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string') {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xhr = this.xhr = new XMLHttpRequest();\n\n        // set the request type and url\n        xhr.open('GET', this.url, true);\n\n        xhr.timeout = this.timeout;\n\n        // load json as text and parse it ourselves. We do this because some browsers\n        // *cough* safari *cough* can't deal with it.\n        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n            xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n        }\n        else {\n            xhr.responseType = this.xhrType;\n        }\n\n        xhr.addEventListener('error', this._boundXhrOnError, false);\n        xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n        xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n        xhr.addEventListener('progress', this._boundOnProgress, false);\n        xhr.addEventListener('load', this._boundXhrOnLoad, false);\n\n        xhr.send();\n    }\n\n    /**\n     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n     *\n     * @private\n     */\n    _loadXdr() {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string') {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xdr = this.xhr = new XDomainRequest(); // eslint-disable-line no-undef\n\n        // XDomainRequest has a few quirks. Occasionally it will abort requests\n        // A way to avoid this is to make sure ALL callbacks are set even if not used\n        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n        xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n\n        xdr.onerror = this._boundXhrOnError;\n        xdr.ontimeout = this._boundXhrOnTimeout;\n        xdr.onprogress = this._boundOnProgress;\n        xdr.onload = this._boundXhrOnLoad;\n\n        xdr.open('GET', this.url, true);\n\n        // Note: The xdr.send() call is wrapped in a timeout to prevent an\n        // issue with the interface where some requests are lost if multiple\n        // XDomainRequests are being sent at the same time.\n        // Some info here: https://github.com/photonstorm/phaser/issues/1248\n        setTimeout(() => xdr.send(), 1);\n    }\n\n    /**\n     * Creates a source used in loading via an element.\n     *\n     * @private\n     * @param {string} type - The element type (video or audio).\n     * @param {string} url - The source URL to load from.\n     * @param {string} [mime] - The mime type of the video\n     * @return {HTMLSourceElement} The source element.\n     */\n    _createSource(type, url, mime) {\n        if (!mime) {\n            mime = `${type}/${this._getExtension(url)}`;\n        }\n\n        const source = document.createElement('source');\n\n        source.src = url;\n        source.type = mime;\n\n        return source;\n    }\n\n    /**\n     * Called if a load errors out.\n     *\n     * @param {Event} event - The error event from the element that emits it.\n     * @private\n     */\n    _onError(event) {\n        this.abort(`Failed to load element using: ${event.target.nodeName}`);\n    }\n\n    /**\n     * Called if a load progress event fires for an element or xhr/xdr.\n     *\n     * @private\n     * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n     */\n    _onProgress(event) {\n        if (event && event.lengthComputable) {\n            this.onProgress.dispatch(this, event.loaded / event.total);\n        }\n    }\n\n    /**\n     * Called if a timeout event fires for an element.\n     *\n     * @private\n     */\n    _onTimeout() {\n        this.abort(`Load timed out.`);\n    }\n\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnError() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request failed. Status: ${xhr.status}, text: \"${xhr.statusText}\"`);\n    }\n\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnTimeout() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request timed out.`);\n    }\n\n    /**\n     * Called if an abort event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnAbort() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request was aborted by the user.`);\n    }\n\n    /**\n     * Called when data successfully loads from an xhr/xdr request.\n     *\n     * @private\n     * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n     */\n    _xhrOnLoad() {\n        const xhr = this.xhr;\n        let text = '';\n        let status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n\n        // responseText is accessible only if responseType is '' or 'text' and on older browsers\n        if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {\n            text = xhr.responseText;\n        }\n\n        // status can be 0 when using the `file://` protocol so we also check if a response is set.\n        // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n        if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER)) {\n            status = STATUS_OK;\n        }\n        // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n        else if (status === STATUS_IE_BUG_EMPTY) {\n            status = STATUS_EMPTY;\n        }\n\n        const statusType = (status / 100) | 0;\n\n        if (statusType === STATUS_TYPE_OK) {\n            // if text, just return it\n            if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n                this.data = text;\n                this.type = Resource.TYPE.TEXT;\n            }\n            // if json, parse into json object\n            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n                try {\n                    this.data = JSON.parse(text);\n                    this.type = Resource.TYPE.JSON;\n                }\n                catch (e) {\n                    this.abort(`Error trying to parse loaded json: ${e}`);\n\n                    return;\n                }\n            }\n            // if xml, parse into an xml document or div element\n            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n                try {\n                    if (window.DOMParser) {\n                        const domparser = new DOMParser();\n\n                        this.data = domparser.parseFromString(text, 'text/xml');\n                    }\n                    else {\n                        const div = document.createElement('div');\n\n                        div.innerHTML = text;\n\n                        this.data = div;\n                    }\n\n                    this.type = Resource.TYPE.XML;\n                }\n                catch (e) {\n                    this.abort(`Error trying to parse loaded xml: ${e}`);\n\n                    return;\n                }\n            }\n            // other types just return the response\n            else {\n                this.data = xhr.response || text;\n            }\n        }\n        else {\n            this.abort(`[${xhr.status}] ${xhr.statusText}: ${xhr.responseURL}`);\n\n            return;\n        }\n\n        this.complete();\n    }\n\n    /**\n     * Sets the `crossOrigin` property for this resource based on if the url\n     * for this resource is cross-origin. If crossOrigin was manually set, this\n     * function does nothing.\n     *\n     * @private\n     * @param {string} url - The url to test.\n     * @param {object} [loc=window.location] - The location object to test against.\n     * @return {string} The crossOrigin value to use (or empty string for none).\n     */\n    _determineCrossOrigin(url, loc) {\n        // data: and javascript: urls are considered same-origin\n        if (url.indexOf('data:') === 0) {\n            return '';\n        }\n\n        // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n        // origin designed not to match window.location.origin, and will always require\n        // crossOrigin requests regardless of whether the location matches.\n        if (window.origin !== window.location.origin) {\n            return 'anonymous';\n        }\n\n        // default is window.location\n        loc = loc || window.location;\n\n        if (!tempAnchor) {\n            tempAnchor = document.createElement('a');\n        }\n\n        // let the browser determine the full href for the url of this resource and then\n        // parse with the node url lib, we can't use the properties of the anchor element\n        // because they don't work in IE9 :(\n        tempAnchor.href = url;\n        url = parseUri(tempAnchor.href, { strictMode: true });\n\n        const samePort = (!url.port && loc.port === '') || (url.port === loc.port);\n        const protocol = url.protocol ? `${url.protocol}:` : '';\n\n        // if cross origin\n        if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n            return 'anonymous';\n        }\n\n        return '';\n    }\n\n    /**\n     * Determines the responseType of an XHR request based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n     */\n    _determineXhrType() {\n        return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;\n    }\n\n    /**\n     * Determines the loadType of a resource based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.LOAD_TYPE} The loadType to use.\n     */\n    _determineLoadType() {\n        return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;\n    }\n\n    /**\n     * Extracts the extension (sans '.') of the file being loaded by the resource.\n     *\n     * @private\n     * @return {string} The extension.\n     */\n    _getExtension() {\n        let url = this.url;\n        let ext = '';\n\n        if (this.isDataUrl) {\n            const slashIndex = url.indexOf('/');\n\n            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n        }\n        else {\n            const queryStart = url.indexOf('?');\n            const hashStart = url.indexOf('#');\n            const index = Math.min(\n                queryStart > -1 ? queryStart : url.length,\n                hashStart > -1 ? hashStart : url.length\n            );\n\n            url = url.substring(0, index);\n            ext = url.substring(url.lastIndexOf('.') + 1);\n        }\n\n        return ext.toLowerCase();\n    }\n\n    /**\n     * Determines the mime type of an XHR request based on the responseType of\n     * resource being loaded.\n     *\n     * @private\n     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n     * @return {string} The mime type to use.\n     */\n    _getMimeFromXhrType(type) {\n        switch (type) {\n            case Resource.XHR_RESPONSE_TYPE.BUFFER:\n                return 'application/octet-binary';\n\n            case Resource.XHR_RESPONSE_TYPE.BLOB:\n                return 'application/blob';\n\n            case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n                return 'application/xml';\n\n            case Resource.XHR_RESPONSE_TYPE.JSON:\n                return 'application/json';\n\n            case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n            case Resource.XHR_RESPONSE_TYPE.TEXT:\n                /* falls through */\n            default:\n                return 'text/plain';\n        }\n    }\n}\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.STATUS_FLAGS = {\n    NONE:       0,\n    DATA_URL:   (1 << 0),\n    COMPLETE:   (1 << 1),\n    LOADING:    (1 << 2),\n};\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.TYPE = {\n    UNKNOWN:    0,\n    JSON:       1,\n    XML:        2,\n    IMAGE:      3,\n    AUDIO:      4,\n    VIDEO:      5,\n    TEXT:       6,\n};\n\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.LOAD_TYPE = {\n    /** Uses XMLHttpRequest to load the resource. */\n    XHR:    1,\n    /** Uses an `Image` object to load the resource. */\n    IMAGE:  2,\n    /** Uses an `Audio` object to load the resource. */\n    AUDIO:  3,\n    /** Uses a `Video` object to load the resource. */\n    VIDEO:  4,\n};\n\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\nResource.XHR_RESPONSE_TYPE = {\n    /** string */\n    DEFAULT:    'text',\n    /** ArrayBuffer */\n    BUFFER:     'arraybuffer',\n    /** Blob */\n    BLOB:       'blob',\n    /** Document */\n    DOCUMENT:   'document',\n    /** Object */\n    JSON:       'json',\n    /** String */\n    TEXT:       'text',\n};\n\nResource._loadTypeMap = {\n    // images\n    gif:        Resource.LOAD_TYPE.IMAGE,\n    png:        Resource.LOAD_TYPE.IMAGE,\n    bmp:        Resource.LOAD_TYPE.IMAGE,\n    jpg:        Resource.LOAD_TYPE.IMAGE,\n    jpeg:       Resource.LOAD_TYPE.IMAGE,\n    tif:        Resource.LOAD_TYPE.IMAGE,\n    tiff:       Resource.LOAD_TYPE.IMAGE,\n    webp:       Resource.LOAD_TYPE.IMAGE,\n    tga:        Resource.LOAD_TYPE.IMAGE,\n    svg:        Resource.LOAD_TYPE.IMAGE,\n    'svg+xml':  Resource.LOAD_TYPE.IMAGE, // for SVG data urls\n\n    // audio\n    mp3:        Resource.LOAD_TYPE.AUDIO,\n    ogg:        Resource.LOAD_TYPE.AUDIO,\n    wav:        Resource.LOAD_TYPE.AUDIO,\n\n    // videos\n    mp4:        Resource.LOAD_TYPE.VIDEO,\n    webm:       Resource.LOAD_TYPE.VIDEO,\n};\n\nResource._xhrTypeMap = {\n    // xml\n    xhtml:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    html:       Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n    // this should probably be fine.\n    tsx:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // images\n    gif:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    png:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    bmp:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpg:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpeg:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    tif:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    tiff:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    webp:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    tga:        Resource.XHR_RESPONSE_TYPE.BLOB,\n\n    // json\n    json:       Resource.XHR_RESPONSE_TYPE.JSON,\n\n    // text\n    text:       Resource.XHR_RESPONSE_TYPE.TEXT,\n    txt:        Resource.XHR_RESPONSE_TYPE.TEXT,\n\n    // fonts\n    ttf:        Resource.XHR_RESPONSE_TYPE.BUFFER,\n    otf:        Resource.XHR_RESPONSE_TYPE.BUFFER,\n};\n\n// We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\nResource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n\n/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n *\n * @ignore\n * @param {object} map - The map to set on.\n * @param {string} extname - The extension (or key) to set.\n * @param {number} val - The value to set.\n */\nfunction setExtMap(map, extname, val) {\n    if (extname && extname.indexOf('.') === 0) {\n        extname = extname.substring(1);\n    }\n\n    if (!extname) {\n        return;\n    }\n\n    map[extname] = val;\n}\n\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\nfunction reqType(xhr) {\n    return xhr.toString().replace('object ', '');\n}\n\n// Backwards compat\nif (typeof module !== 'undefined') {\n    module.exports.default = Resource; // eslint-disable-line no-undef\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}