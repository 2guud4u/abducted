{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _core = require('../../core');\nvar core = _interopRequireWildcard(_core);\nvar _pixiGlCore = require('pixi-gl-core');\nvar _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);\nvar _Mesh = require('../Mesh');\nvar _Mesh2 = _interopRequireDefault(_Mesh);\nvar _path = require('path');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar matrixIdentity = core.Matrix.IDENTITY;\n\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\n\nvar MeshRenderer = function (_core$ObjectRenderer) {\n  _inherits(MeshRenderer, _core$ObjectRenderer);\n\n  /**\n   * constructor for renderer\n   *\n   * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.\n   */\n  function MeshRenderer(renderer) {\n    _classCallCheck(this, MeshRenderer);\n    var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));\n    _this.shader = null;\n    return _this;\n  }\n\n  /**\n   * Sets up the renderer context and necessary buffers.\n   *\n   * @private\n   */\n\n  MeshRenderer.prototype.onContextChange = function onContextChange() {\n    var gl = this.renderer.gl;\n    this.shader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n', 'varying vec2 vTextureCoord;\\nuniform vec4 uColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\\n}\\n');\n  };\n\n  /**\n   * renders mesh\n   *\n   * @param {PIXI.mesh.Mesh} mesh mesh instance\n   */\n\n  MeshRenderer.prototype.render = function render(mesh) {\n    var renderer = this.renderer;\n    var gl = renderer.gl;\n    var texture = mesh._texture;\n    if (!texture.valid) {\n      return;\n    }\n    var glData = mesh._glDatas[renderer.CONTEXT_UID];\n    if (!glData) {\n      renderer.bindVao(null);\n      glData = {\n        shader: this.shader,\n        vertexBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),\n        uvBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.uvs, gl.STREAM_DRAW),\n        indexBuffer: _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),\n        // build the vao object that will render..\n        vao: null,\n        dirty: mesh.dirty,\n        indexDirty: mesh.indexDirty,\n        vertexDirty: mesh.vertexDirty\n      };\n\n      // build the vao object that will render..\n      glData.vao = new _pixiGlCore2.default.VertexArrayObject(gl).addIndex(glData.indexBuffer).addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0).addAttribute(glData.uvBuffer, glData.shader.attributes.aTextureCoord, gl.FLOAT, false, 2 * 4, 0);\n      mesh._glDatas[renderer.CONTEXT_UID] = glData;\n    }\n    renderer.bindVao(glData.vao);\n    if (mesh.dirty !== glData.dirty) {\n      glData.dirty = mesh.dirty;\n      glData.uvBuffer.upload(mesh.uvs);\n    }\n    if (mesh.indexDirty !== glData.indexDirty) {\n      glData.indexDirty = mesh.indexDirty;\n      glData.indexBuffer.upload(mesh.indices);\n    }\n    if (mesh.vertexDirty !== glData.vertexDirty) {\n      glData.vertexDirty = mesh.vertexDirty;\n      glData.vertexBuffer.upload(mesh.vertices);\n    }\n    renderer.bindShader(glData.shader);\n    glData.shader.uniforms.uSampler = renderer.bindTexture(texture);\n    renderer.state.setBlendMode(core.utils.correctBlendMode(mesh.blendMode, texture.baseTexture.premultipliedAlpha));\n    if (glData.shader.uniforms.uTransform) {\n      if (mesh.uploadUvTransform) {\n        glData.shader.uniforms.uTransform = mesh._uvTransform.mapCoord.toArray(true);\n      } else {\n        glData.shader.uniforms.uTransform = matrixIdentity.toArray(true);\n      }\n    }\n    glData.shader.uniforms.translationMatrix = mesh.worldTransform.toArray(true);\n    glData.shader.uniforms.uColor = core.utils.premultiplyRgba(mesh.tintRgb, mesh.worldAlpha, glData.shader.uniforms.uColor, texture.baseTexture.premultipliedAlpha);\n    var drawMode = mesh.drawMode === _Mesh2.default.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;\n    glData.vao.draw(drawMode, mesh.indices.length, 0);\n  };\n  return MeshRenderer;\n}(core.ObjectRenderer);\nexports.default = MeshRenderer;\ncore.WebGLRenderer.registerPlugin('mesh', MeshRenderer);","map":{"version":3,"names":["_core","require","core","_pixiGlCore","_Mesh","_path","matrixIdentity","Matrix","IDENTITY","MeshRenderer","renderer","_classCallCheck","_this","_possibleConstructorReturn","_core$ObjectRenderer","call","shader","onContextChange","gl","Shader","render","mesh","texture","_texture","valid","glData","_glDatas","CONTEXT_UID","bindVao","vertexBuffer","_pixiGlCore2","default","GLBuffer","createVertexBuffer","vertices","STREAM_DRAW","uvBuffer","uvs","indexBuffer","createIndexBuffer","indices","STATIC_DRAW","vao","dirty","indexDirty","vertexDirty","VertexArrayObject","addIndex","addAttribute","attributes","aVertexPosition","FLOAT","aTextureCoord","upload","bindShader","uniforms","uSampler","bindTexture","state","setBlendMode","utils","correctBlendMode","blendMode","baseTexture","premultipliedAlpha","uTransform","uploadUvTransform","_uvTransform","mapCoord","toArray","translationMatrix","worldTransform","uColor","premultiplyRgba","tintRgb","worldAlpha","drawMode","_Mesh2","DRAW_MODES","TRIANGLE_MESH","TRIANGLE_STRIP","TRIANGLES","draw","length","ObjectRenderer","WebGLRenderer","registerPlugin"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/mesh/webgl/MeshRenderer.js"],"sourcesContent":["import * as core from '../../core';\nimport glCore from 'pixi-gl-core';\nimport { default as Mesh } from '../Mesh';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\n\nconst matrixIdentity = core.Matrix.IDENTITY;\n\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport default class MeshRenderer extends core.ObjectRenderer\n{\n\n    /**\n     * constructor for renderer\n     *\n     * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.shader = null;\n    }\n\n    /**\n     * Sets up the renderer context and necessary buffers.\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        this.shader = new core.Shader(gl,\n            readFileSync(join(__dirname, './mesh.vert'), 'utf8'),\n            readFileSync(join(__dirname, './mesh.frag'), 'utf8'));\n    }\n\n    /**\n     * renders mesh\n     *\n     * @param {PIXI.mesh.Mesh} mesh mesh instance\n     */\n    render(mesh)\n    {\n        const renderer = this.renderer;\n        const gl = renderer.gl;\n        const texture = mesh._texture;\n\n        if (!texture.valid)\n        {\n            return;\n        }\n\n        let glData = mesh._glDatas[renderer.CONTEXT_UID];\n\n        if (!glData)\n        {\n            renderer.bindVao(null);\n\n            glData = {\n                shader: this.shader,\n                vertexBuffer: glCore.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),\n                uvBuffer: glCore.GLBuffer.createVertexBuffer(gl, mesh.uvs, gl.STREAM_DRAW),\n                indexBuffer: glCore.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),\n                // build the vao object that will render..\n                vao: null,\n                dirty: mesh.dirty,\n                indexDirty: mesh.indexDirty,\n                vertexDirty: mesh.vertexDirty,\n            };\n\n            // build the vao object that will render..\n            glData.vao = new glCore.VertexArrayObject(gl)\n                .addIndex(glData.indexBuffer)\n                .addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0)\n                .addAttribute(glData.uvBuffer, glData.shader.attributes.aTextureCoord, gl.FLOAT, false, 2 * 4, 0);\n\n            mesh._glDatas[renderer.CONTEXT_UID] = glData;\n        }\n\n        renderer.bindVao(glData.vao);\n\n        if (mesh.dirty !== glData.dirty)\n        {\n            glData.dirty = mesh.dirty;\n            glData.uvBuffer.upload(mesh.uvs);\n        }\n\n        if (mesh.indexDirty !== glData.indexDirty)\n        {\n            glData.indexDirty = mesh.indexDirty;\n            glData.indexBuffer.upload(mesh.indices);\n        }\n\n        if (mesh.vertexDirty !== glData.vertexDirty)\n        {\n            glData.vertexDirty = mesh.vertexDirty;\n            glData.vertexBuffer.upload(mesh.vertices);\n        }\n\n        renderer.bindShader(glData.shader);\n\n        glData.shader.uniforms.uSampler = renderer.bindTexture(texture);\n\n        renderer.state.setBlendMode(core.utils.correctBlendMode(mesh.blendMode, texture.baseTexture.premultipliedAlpha));\n\n        if (glData.shader.uniforms.uTransform)\n        {\n            if (mesh.uploadUvTransform)\n            {\n                glData.shader.uniforms.uTransform = mesh._uvTransform.mapCoord.toArray(true);\n            }\n            else\n            {\n                glData.shader.uniforms.uTransform = matrixIdentity.toArray(true);\n            }\n        }\n        glData.shader.uniforms.translationMatrix = mesh.worldTransform.toArray(true);\n\n        glData.shader.uniforms.uColor = core.utils.premultiplyRgba(mesh.tintRgb,\n            mesh.worldAlpha, glData.shader.uniforms.uColor, texture.baseTexture.premultipliedAlpha);\n\n        const drawMode = mesh.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;\n\n        glData.vao.draw(drawMode, mesh.indices.length, 0);\n    }\n}\n\ncore.WebGLRenderer.registerPlugin('mesh', MeshRenderer);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}