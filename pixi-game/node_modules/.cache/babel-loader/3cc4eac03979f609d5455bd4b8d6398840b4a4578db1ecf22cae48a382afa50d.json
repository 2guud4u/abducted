{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nconst buildCircle = {\n  build(graphicsData) {\n    const points = graphicsData.points;\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (graphicsData.type === core.SHAPES.CIRC) {\n      const circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (graphicsData.type === core.SHAPES.ELIP) {\n      const ellipse = graphicsData.shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.width;\n      ry = ellipse.height;\n      dx = dy = 0;\n    } else {\n      const roundedRect = graphicsData.shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      points.length = 0;\n      return;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    points.length = m;\n    if (m === 0) {\n      return;\n    }\n    if (n === 0) {\n      points.length = 8;\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    {\n      const x0 = dx + rx;\n      const y0 = dy;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      if (dy) {\n        const y2 = y - y0;\n        points[j3++] = x2;\n        points[j3++] = y2;\n        points[--j4] = y2;\n        points[--j4] = x1;\n      }\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x0 = dx + Math.cos(a) * rx;\n      const y0 = dy + Math.sin(a) * ry;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      const y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      points[j3++] = x2;\n      points[j3++] = y2;\n      points[--j4] = y2;\n      points[--j4] = x1;\n    }\n    {\n      const x0 = dx;\n      const y0 = dy + ry;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      const y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x1;\n      if (dx) {\n        points[j1++] = x2;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x2;\n      }\n    }\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    const points = graphicsData.points;\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    if (points.length === 0) {\n      return;\n    }\n    let vertPos = verts.length / 2;\n    const center = vertPos;\n    let x;\n    let y;\n    if (graphicsData.type !== core.SHAPES.RREC) {\n      const circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n    } else {\n      const roundedRect = graphicsData.shape;\n      x = roundedRect.x + roundedRect.width / 2;\n      y = roundedRect.y + roundedRect.height / 2;\n    }\n    const matrix = graphicsData.matrix;\n    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);\n    vertPos++;\n    verts.push(points[0], points[1]);\n    for (let i = 2; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]);\n      indices.push(vertPos++, center, vertPos);\n    }\n    indices.push(center + 1, center, vertPos);\n  }\n};\nexports.buildCircle = buildCircle;","map":{"version":3,"names":["buildCircle","build","graphicsData","points","x","y","dx","dy","rx","ry","type","core","SHAPES","CIRC","circle","shape","radius","ELIP","ellipse","width","height","roundedRect","halfWidth","halfHeight","Math","max","min","length","n","ceil","sqrt","m","j1","j2","j3","j4","x0","y0","x1","x2","y1","y2","i","a","PI","cos","sin","triangulate","graphicsGeometry","verts","indices","vertPos","center","RREC","matrix","push","c","tx","b","d","ty"],"sources":["/Users/jiahuajiang/Desktop/code/projects/abducted/pixi-game/node_modules/@pixi/graphics/src/utils/buildCircle.ts"],"sourcesContent":["// for type only\nimport { SHAPES } from '@pixi/core';\n\nimport type { Circle, Ellipse, RoundedRectangle } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const points = graphicsData.points;\n\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n        else if (graphicsData.type === SHAPES.ELIP)\n        {\n            const ellipse = graphicsData.shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.width;\n            ry = ellipse.height;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            points.length = 0;\n\n            return;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        points.length = m;\n\n        if (m === 0)\n        {\n            return;\n        }\n\n        if (n === 0)\n        {\n            points.length = 8;\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        {\n            const x0 = dx + rx;\n            const y0 = dy;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n\n            if (dy)\n            {\n                const y2 = y - y0;\n\n                points[j3++] = x2;\n                points[j3++] = y2;\n                points[--j4] = y2;\n                points[--j4] = x1;\n            }\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        {\n            const x0 = dx;\n            const y0 = dy + ry;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x1;\n\n            if (dx)\n            {\n                points[j1++] = x2;\n                points[j1++] = y1;\n                points[--j4] = y2;\n                points[--j4] = x2;\n            }\n        }\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        let x;\n        let y;\n\n        if (graphicsData.type !== SHAPES.RREC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n\n            x = roundedRect.x + (roundedRect.width / 2);\n            y = roundedRect.y + (roundedRect.height / 2);\n        }\n\n        const matrix = graphicsData.matrix;\n\n        // Push center (special point)\n        verts.push(\n            graphicsData.matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x,\n            graphicsData.matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y);\n\n        vertPos++;\n\n        verts.push(points[0], points[1]);\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n\n        indices.push(center + 1, center, vertPos);\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}