{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _const = require('../../../const');\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * A set of functions used to handle masking.\n *\n * @class\n * @memberof PIXI\n */\nvar CanvasMaskManager = function () {\n  /**\n   * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n   */\n  function CanvasMaskManager(renderer) {\n    _classCallCheck(this, CanvasMaskManager);\n    this.renderer = renderer;\n  }\n\n  /**\n   * This method adds it to the current stack of masks.\n   *\n   * @param {object} maskData - the maskData that will be pushed\n   */\n\n  CanvasMaskManager.prototype.pushMask = function pushMask(maskData) {\n    var renderer = this.renderer;\n    renderer.context.save();\n    var cacheAlpha = maskData.alpha;\n    var transform = maskData.transform.worldTransform;\n    var resolution = renderer.resolution;\n    renderer.context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);\n\n    // TODO suport sprite alpha masks??\n    // lots of effort required. If demand is great enough..\n    if (!maskData._texture) {\n      this.renderGraphicsShape(maskData);\n      renderer.context.clip();\n    }\n    maskData.worldAlpha = cacheAlpha;\n  };\n\n  /**\n   * Renders a PIXI.Graphics shape.\n   *\n   * @param {PIXI.Graphics} graphics - The object to render.\n   */\n\n  CanvasMaskManager.prototype.renderGraphicsShape = function renderGraphicsShape(graphics) {\n    var context = this.renderer.context;\n    var len = graphics.graphicsData.length;\n    if (len === 0) {\n      return;\n    }\n    context.beginPath();\n    for (var i = 0; i < len; i++) {\n      var data = graphics.graphicsData[i];\n      var shape = data.shape;\n      if (data.type === _const.SHAPES.POLY) {\n        var points = shape.points;\n        var holes = data.holes;\n        var outerArea = void 0;\n        var innerArea = void 0;\n        context.moveTo(points[0], points[1]);\n        for (var j = 2; j < points.length; j += 2) {\n          context.lineTo(points[j], points[j + 1]);\n        }\n\n        // if the first and last point are the same close the path - much neater :)\n        if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {\n          context.closePath();\n        }\n        if (holes.length > 0) {\n          outerArea = 0;\n          for (var _j = 0; _j < points.length; _j += 2) {\n            outerArea += points[_j] * points[_j + 3] - points[_j + 1] * points[_j + 2];\n          }\n          for (var k = 0; k < holes.length; k++) {\n            points = holes[k].points;\n            innerArea = 0;\n            for (var _j2 = 0; _j2 < points.length; _j2 += 2) {\n              innerArea += points[_j2] * points[_j2 + 3] - points[_j2 + 1] * points[_j2 + 2];\n            }\n            context.moveTo(points[0], points[1]);\n            if (innerArea * outerArea < 0) {\n              for (var _j3 = 2; _j3 < points.length; _j3 += 2) {\n                context.lineTo(points[_j3], points[_j3 + 1]);\n              }\n            } else {\n              for (var _j4 = points.length - 2; _j4 >= 2; _j4 -= 2) {\n                context.lineTo(points[_j4], points[_j4 + 1]);\n              }\n            }\n          }\n        }\n      } else if (data.type === _const.SHAPES.RECT) {\n        context.rect(shape.x, shape.y, shape.width, shape.height);\n        context.closePath();\n      } else if (data.type === _const.SHAPES.CIRC) {\n        // TODO - need to be Undefined!\n        context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n        context.closePath();\n      } else if (data.type === _const.SHAPES.ELIP) {\n        // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n        var w = shape.width * 2;\n        var h = shape.height * 2;\n        var x = shape.x - w / 2;\n        var y = shape.y - h / 2;\n        var kappa = 0.5522848;\n        var ox = w / 2 * kappa; // control point offset horizontal\n        var oy = h / 2 * kappa; // control point offset vertical\n        var xe = x + w; // x-end\n        var ye = y + h; // y-end\n        var xm = x + w / 2; // x-middle\n        var ym = y + h / 2; // y-middle\n\n        context.moveTo(x, ym);\n        context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n        context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n        context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n        context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n        context.closePath();\n      } else if (data.type === _const.SHAPES.RREC) {\n        var rx = shape.x;\n        var ry = shape.y;\n        var width = shape.width;\n        var height = shape.height;\n        var radius = shape.radius;\n        var maxRadius = Math.min(width, height) / 2 | 0;\n        radius = radius > maxRadius ? maxRadius : radius;\n        context.moveTo(rx, ry + radius);\n        context.lineTo(rx, ry + height - radius);\n        context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n        context.lineTo(rx + width - radius, ry + height);\n        context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n        context.lineTo(rx + width, ry + radius);\n        context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n        context.lineTo(rx + radius, ry);\n        context.quadraticCurveTo(rx, ry, rx, ry + radius);\n        context.closePath();\n      }\n    }\n  };\n\n  /**\n   * Restores the current drawing context to the state it was before the mask was applied.\n   *\n   * @param {PIXI.CanvasRenderer} renderer - The renderer context to use.\n   */\n\n  CanvasMaskManager.prototype.popMask = function popMask(renderer) {\n    renderer.context.restore();\n    renderer.invalidateBlendMode();\n  };\n\n  /**\n   * Destroys this canvas mask manager.\n   *\n   */\n\n  CanvasMaskManager.prototype.destroy = function destroy() {\n    /* empty */\n  };\n  return CanvasMaskManager;\n}();\nexports.default = CanvasMaskManager;","map":{"version":3,"names":["_const","require","CanvasMaskManager","renderer","_classCallCheck","pushMask","maskData","context","save","cacheAlpha","alpha","transform","worldTransform","resolution","setTransform","a","b","c","d","tx","ty","_texture","renderGraphicsShape","clip","worldAlpha","graphics","len","graphicsData","length","beginPath","i","data","shape","type","SHAPES","POLY","points","holes","outerArea","innerArea","moveTo","j","lineTo","closePath","_j","k","_j2","_j3","_j4","RECT","rect","x","y","width","height","CIRC","arc","radius","Math","PI","ELIP","w","h","kappa","ox","oy","xe","ye","xm","ym","bezierCurveTo","RREC","rx","ry","maxRadius","min","quadraticCurveTo","popMask","restore","invalidateBlendMode","destroy"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasMaskManager.js"],"sourcesContent":["import { SHAPES } from '../../../const';\n\n/**\n * A set of functions used to handle masking.\n *\n * @class\n * @memberof PIXI\n */\nexport default class CanvasMaskManager\n{\n    /**\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * This method adds it to the current stack of masks.\n     *\n     * @param {object} maskData - the maskData that will be pushed\n     */\n    pushMask(maskData)\n    {\n        const renderer = this.renderer;\n\n        renderer.context.save();\n\n        const cacheAlpha = maskData.alpha;\n        const transform = maskData.transform.worldTransform;\n        const resolution = renderer.resolution;\n\n        renderer.context.setTransform(\n            transform.a * resolution,\n            transform.b * resolution,\n            transform.c * resolution,\n            transform.d * resolution,\n            transform.tx * resolution,\n            transform.ty * resolution\n        );\n\n        // TODO suport sprite alpha masks??\n        // lots of effort required. If demand is great enough..\n        if (!maskData._texture)\n        {\n            this.renderGraphicsShape(maskData);\n            renderer.context.clip();\n        }\n\n        maskData.worldAlpha = cacheAlpha;\n    }\n\n    /**\n     * Renders a PIXI.Graphics shape.\n     *\n     * @param {PIXI.Graphics} graphics - The object to render.\n     */\n    renderGraphicsShape(graphics)\n    {\n        const context = this.renderer.context;\n        const len = graphics.graphicsData.length;\n\n        if (len === 0)\n        {\n            return;\n        }\n\n        context.beginPath();\n\n        for (let i = 0; i < len; i++)\n        {\n            const data = graphics.graphicsData[i];\n            const shape = data.shape;\n\n            if (data.type === SHAPES.POLY)\n            {\n                let points = shape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 2; j < points.length; j += 2)\n                {\n                    context.lineTo(points[j], points[j + 1]);\n                }\n\n                // if the first and last point are the same close the path - much neater :)\n                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1])\n                {\n                    context.closePath();\n                }\n\n                if (holes.length > 0)\n                {\n                    outerArea = 0;\n                    for (let j = 0; j < points.length; j += 2)\n                    {\n                        outerArea += (points[j] * points[j + 3]) - (points[j + 1] * points[j + 2]);\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = holes[k].points;\n\n                        innerArea = 0;\n                        for (let j = 0; j < points.length; j += 2)\n                        {\n                            innerArea += (points[j] * points[j + 3]) - (points[j + 1] * points[j + 2]);\n                        }\n\n                        context.moveTo(points[0], points[1]);\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            for (let j = points.length - 2; j >= 2; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (data.type === SHAPES.RECT)\n            {\n                context.rect(shape.x, shape.y, shape.width, shape.height);\n                context.closePath();\n            }\n            else if (data.type === SHAPES.CIRC)\n            {\n                // TODO - need to be Undefined!\n                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n                context.closePath();\n            }\n            else if (data.type === SHAPES.ELIP)\n            {\n                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n                const w = shape.width * 2;\n                const h = shape.height * 2;\n\n                const x = shape.x - (w / 2);\n                const y = shape.y - (h / 2);\n\n                const kappa = 0.5522848;\n                const ox = (w / 2) * kappa; // control point offset horizontal\n                const oy = (h / 2) * kappa; // control point offset vertical\n                const xe = x + w;           // x-end\n                const ye = y + h;           // y-end\n                const xm = x + (w / 2);       // x-middle\n                const ym = y + (h / 2);       // y-middle\n\n                context.moveTo(x, ym);\n                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n                context.closePath();\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                const rx = shape.x;\n                const ry = shape.y;\n                const width = shape.width;\n                const height = shape.height;\n                let radius = shape.radius;\n\n                const maxRadius = Math.min(width, height) / 2 | 0;\n\n                radius = radius > maxRadius ? maxRadius : radius;\n\n                context.moveTo(rx, ry + radius);\n                context.lineTo(rx, ry + height - radius);\n                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n                context.lineTo(rx + width - radius, ry + height);\n                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n                context.lineTo(rx + width, ry + radius);\n                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n                context.lineTo(rx + radius, ry);\n                context.quadraticCurveTo(rx, ry, rx, ry + radius);\n                context.closePath();\n            }\n        }\n    }\n\n    /**\n     * Restores the current drawing context to the state it was before the mask was applied.\n     *\n     * @param {PIXI.CanvasRenderer} renderer - The renderer context to use.\n     */\n    popMask(renderer)\n    {\n        renderer.context.restore();\n        renderer.invalidateBlendMode();\n    }\n\n    /**\n     * Destroys this canvas mask manager.\n     *\n     */\n    destroy()\n    {\n        /* empty */\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}