{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _Container2 = require('../display/Container');\nvar _Container3 = _interopRequireDefault(_Container2);\nvar _RenderTexture = require('../textures/RenderTexture');\nvar _RenderTexture2 = _interopRequireDefault(_RenderTexture);\nvar _Texture = require('../textures/Texture');\nvar _Texture2 = _interopRequireDefault(_Texture);\nvar _GraphicsData = require('./GraphicsData');\nvar _GraphicsData2 = _interopRequireDefault(_GraphicsData);\nvar _Sprite = require('../sprites/Sprite');\nvar _Sprite2 = _interopRequireDefault(_Sprite);\nvar _math = require('../math');\nvar _utils = require('../utils');\nvar _const = require('../const');\nvar _Bounds = require('../display/Bounds');\nvar _Bounds2 = _interopRequireDefault(_Bounds);\nvar _bezierCurveTo2 = require('./utils/bezierCurveTo');\nvar _bezierCurveTo3 = _interopRequireDefault(_bezierCurveTo2);\nvar _CanvasRenderer = require('../renderers/canvas/CanvasRenderer');\nvar _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar canvasRenderer = void 0;\nvar tempMatrix = new _math.Matrix();\nvar tempPoint = new _math.Point();\nvar tempColor1 = new Float32Array(4);\nvar tempColor2 = new Float32Array(4);\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\n\nvar Graphics = function (_Container) {\n  _inherits(Graphics, _Container);\n\n  /**\n   *\n   * @param {boolean} [nativeLines=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   */\n  function Graphics() {\n    var nativeLines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    _classCallCheck(this, Graphics);\n\n    /**\n     * The alpha value used when filling the Graphics object.\n     *\n     * @member {number}\n     * @default 1\n     */\n    var _this = _possibleConstructorReturn(this, _Container.call(this));\n    _this.fillAlpha = 1;\n\n    /**\n     * The width (thickness) of any lines drawn.\n     *\n     * @member {number}\n     * @default 0\n     */\n    _this.lineWidth = 0;\n\n    /**\n     * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     *\n     * @member {boolean}\n     */\n    _this.nativeLines = nativeLines;\n\n    /**\n     * The color of any lines drawn.\n     *\n     * @member {string}\n     * @default 0\n     */\n    _this.lineColor = 0;\n\n    /**\n     * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).\n     *\n     * @member {number}\n     * @default 0.5\n     */\n    _this.lineAlignment = 0.5;\n\n    /**\n     * Graphics data\n     *\n     * @member {PIXI.GraphicsData[]}\n     * @private\n     */\n    _this.graphicsData = [];\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to\n     * reset the tint.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    _this.tint = 0xFFFFFF;\n\n    /**\n     * The previous tint applied to the graphic shape. Used to compare to the current tint and\n     * check if theres change.\n     *\n     * @member {number}\n     * @private\n     * @default 0xFFFFFF\n     */\n    _this._prevTint = 0xFFFFFF;\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL;\n     * @see PIXI.BLEND_MODES\n     */\n    _this.blendMode = _const.BLEND_MODES.NORMAL;\n\n    /**\n     * Current path\n     *\n     * @member {PIXI.GraphicsData}\n     * @private\n     */\n    _this.currentPath = null;\n\n    /**\n     * Array containing some WebGL-related properties used by the WebGL renderer.\n     *\n     * @member {object<number, object>}\n     * @private\n     */\n    // TODO - _webgl should use a prototype object, not a random undocumented object...\n    _this._webGL = {};\n\n    /**\n     * Whether this shape is being used as a mask.\n     *\n     * @member {boolean}\n     */\n    _this.isMask = false;\n\n    /**\n     * The bounds' padding used for bounds calculation.\n     *\n     * @member {number}\n     */\n    _this.boundsPadding = 0;\n\n    /**\n     * A cache of the local bounds to prevent recalculation.\n     *\n     * @member {PIXI.Rectangle}\n     * @private\n     */\n    _this._localBounds = new _Bounds2.default();\n\n    /**\n     * Used to detect if the graphics object has changed. If this is set to true then the graphics\n     * object will be recalculated.\n     *\n     * @member {boolean}\n     * @private\n     */\n    _this.dirty = 0;\n\n    /**\n     * Used to detect if we need to do a fast rect check using the id compare method\n     * @type {Number}\n     */\n    _this.fastRectDirty = -1;\n\n    /**\n     * Used to detect if we clear the graphics webGL data\n     * @type {Number}\n     */\n    _this.clearDirty = 0;\n\n    /**\n     * Used to detect if we we need to recalculate local bounds\n     * @type {Number}\n     */\n    _this.boundsDirty = -1;\n\n    /**\n     * Used to detect if the cached sprite object needs to be updated.\n     *\n     * @member {boolean}\n     * @private\n     */\n    _this.cachedSpriteDirty = false;\n    _this._spriteRect = null;\n    _this._fastRect = false;\n    _this._prevRectTint = null;\n    _this._prevRectFillColor = null;\n\n    /**\n     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n     * This is useful if your graphics element does not change often, as it will speed up the rendering\n     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n     * you are constantly redrawing the graphics element.\n     *\n     * @name cacheAsBitmap\n     * @member {boolean}\n     * @memberof PIXI.Graphics#\n     * @default false\n     */\n    return _this;\n  }\n\n  /**\n   * Creates a new Graphics object with the same values as this one.\n   * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n   *\n   * @return {PIXI.Graphics} A clone of the graphics object\n   */\n\n  Graphics.prototype.clone = function clone() {\n    var clone = new Graphics();\n    clone.renderable = this.renderable;\n    clone.fillAlpha = this.fillAlpha;\n    clone.lineWidth = this.lineWidth;\n    clone.lineColor = this.lineColor;\n    clone.lineAlignment = this.lineAlignment;\n    clone.tint = this.tint;\n    clone.blendMode = this.blendMode;\n    clone.isMask = this.isMask;\n    clone.boundsPadding = this.boundsPadding;\n    clone.dirty = 0;\n    clone.cachedSpriteDirty = this.cachedSpriteDirty;\n\n    // copy graphics data\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n      clone.graphicsData.push(this.graphicsData[i].clone());\n    }\n    clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];\n    clone.updateLocalBounds();\n    return clone;\n  };\n\n  /**\n   * Calculate length of quadratic curve\n   * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n   * for the detailed explanation of math behind this.\n   *\n   * @private\n   * @param {number} fromX - x-coordinate of curve start point\n   * @param {number} fromY - y-coordinate of curve start point\n   * @param {number} cpX - x-coordinate of curve control point\n   * @param {number} cpY - y-coordinate of curve control point\n   * @param {number} toX - x-coordinate of curve end point\n   * @param {number} toY - y-coordinate of curve end point\n   * @return {number} Length of quadratic curve\n   */\n\n  Graphics.prototype._quadraticCurveLength = function _quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY) {\n    var ax = fromX - 2.0 * cpX + toX;\n    var ay = fromY - 2.0 * cpY + toY;\n    var bx = 2.0 * cpX - 2.0 * fromX;\n    var by = 2.0 * cpY - 2.0 * fromY;\n    var a = 4.0 * (ax * ax + ay * ay);\n    var b = 4.0 * (ax * bx + ay * by);\n    var c = bx * bx + by * by;\n    var s = 2.0 * Math.sqrt(a + b + c);\n    var a2 = Math.sqrt(a);\n    var a32 = 2.0 * a * a2;\n    var c2 = 2.0 * Math.sqrt(c);\n    var ba = b / a2;\n    return (a32 * s + a2 * b * (s - c2) + (4.0 * c * a - b * b) * Math.log((2.0 * a2 + ba + s) / (ba + c2))) / (4.0 * a32);\n  };\n\n  /**\n   * Calculate length of bezier curve.\n   * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n   * Therefore numerical solution is used.\n   *\n   * @private\n   * @param {number} fromX - Starting point x\n   * @param {number} fromY - Starting point y\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} cpX2 - Second Control point x\n   * @param {number} cpY2 - Second Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @return {number} Length of bezier curve\n   */\n\n  Graphics.prototype._bezierCurveLength = function _bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    var n = 10;\n    var result = 0.0;\n    var t = 0.0;\n    var t2 = 0.0;\n    var t3 = 0.0;\n    var nt = 0.0;\n    var nt2 = 0.0;\n    var nt3 = 0.0;\n    var x = 0.0;\n    var y = 0.0;\n    var dx = 0.0;\n    var dy = 0.0;\n    var prevX = fromX;\n    var prevY = fromY;\n    for (var i = 1; i <= n; ++i) {\n      t = i / n;\n      t2 = t * t;\n      t3 = t2 * t;\n      nt = 1.0 - t;\n      nt2 = nt * nt;\n      nt3 = nt2 * nt;\n      x = nt3 * fromX + 3.0 * nt2 * t * cpX + 3.0 * nt * t2 * cpX2 + t3 * toX;\n      y = nt3 * fromY + 3.0 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n      dx = prevX - x;\n      dy = prevY - y;\n      prevX = x;\n      prevY = y;\n      result += Math.sqrt(dx * dx + dy * dy);\n    }\n    return result;\n  };\n\n  /**\n   * Calculate number of segments for the curve based on its length to ensure its smoothness.\n   *\n   * @private\n   * @param {number} length - length of curve\n   * @return {number} Number of segments\n   */\n\n  Graphics.prototype._segmentsCount = function _segmentsCount(length) {\n    var result = Math.ceil(length / Graphics.CURVES.maxLength);\n    if (result < Graphics.CURVES.minSegments) {\n      result = Graphics.CURVES.minSegments;\n    } else if (result > Graphics.CURVES.maxSegments) {\n      result = Graphics.CURVES.maxSegments;\n    }\n    return result;\n  };\n\n  /**\n   * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n   * method or the drawCircle() method.\n   *\n   * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style\n   * @param {number} [color=0] - color of the line to draw, will update the objects stored style\n   * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.lineStyle = function lineStyle() {\n    var lineWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var alignment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\n    this.lineWidth = lineWidth;\n    this.lineColor = color;\n    this.lineAlpha = alpha;\n    this.lineAlignment = alignment;\n    if (this.currentPath) {\n      if (this.currentPath.shape.points.length) {\n        // halfway through a line? start a new one!\n        var shape = new _math.Polygon(this.currentPath.shape.points.slice(-2));\n        shape.closed = false;\n        this.drawShape(shape);\n      } else {\n        // otherwise its empty so lets just set the line properties\n        this.currentPath.lineWidth = this.lineWidth;\n        this.currentPath.lineColor = this.lineColor;\n        this.currentPath.lineAlpha = this.lineAlpha;\n        this.currentPath.lineAlignment = this.lineAlignment;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Moves the current drawing position to x, y.\n   *\n   * @param {number} x - the X coordinate to move to\n   * @param {number} y - the Y coordinate to move to\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.moveTo = function moveTo(x, y) {\n    var shape = new _math.Polygon([x, y]);\n    shape.closed = false;\n    this.drawShape(shape);\n    return this;\n  };\n\n  /**\n   * Draws a line using the current line style from the current drawing position to (x, y);\n   * The current drawing position is then set to (x, y).\n   *\n   * @param {number} x - the X coordinate to draw to\n   * @param {number} y - the Y coordinate to draw to\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.lineTo = function lineTo(x, y) {\n    var points = this.currentPath.shape.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n      this.dirty++;\n    }\n    return this;\n  };\n\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   *\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.quadraticCurveTo = function quadraticCurveTo(cpX, cpY, toX, toY) {\n    if (this.currentPath) {\n      if (this.currentPath.shape.points.length === 0) {\n        this.currentPath.shape.points = [0, 0];\n      }\n    } else {\n      this.moveTo(0, 0);\n    }\n    var points = this.currentPath.shape.points;\n    var xa = 0;\n    var ya = 0;\n    if (points.length === 0) {\n      this.moveTo(0, 0);\n    }\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var n = Graphics.CURVES.adaptive ? this._segmentsCount(this._quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY)) : 20;\n    for (var i = 1; i <= n; ++i) {\n      var j = i / n;\n      xa = fromX + (cpX - fromX) * j;\n      ya = fromY + (cpY - fromY) * j;\n      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n    }\n    this.dirty++;\n    return this;\n  };\n\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} cpX2 - Second Control point x\n   * @param {number} cpY2 - Second Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.bezierCurveTo = function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n    if (this.currentPath) {\n      if (this.currentPath.shape.points.length === 0) {\n        this.currentPath.shape.points = [0, 0];\n      }\n    } else {\n      this.moveTo(0, 0);\n    }\n    var points = this.currentPath.shape.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    points.length -= 2;\n    var n = Graphics.CURVES.adaptive ? this._segmentsCount(this._bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)) : 20;\n    (0, _bezierCurveTo3.default)(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n, points);\n    this.dirty++;\n    return this;\n  };\n\n  /**\n   * The arcTo() method creates an arc/curve between two tangents on the canvas.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   *\n   * @param {number} x1 - The x-coordinate of the beginning of the arc\n   * @param {number} y1 - The y-coordinate of the beginning of the arc\n   * @param {number} x2 - The x-coordinate of the end of the arc\n   * @param {number} y2 - The y-coordinate of the end of the arc\n   * @param {number} radius - The radius of the arc\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.arcTo = function arcTo(x1, y1, x2, y2, radius) {\n    if (this.currentPath) {\n      if (this.currentPath.shape.points.length === 0) {\n        this.currentPath.shape.points.push(x1, y1);\n      }\n    } else {\n      this.moveTo(x1, y1);\n    }\n    var points = this.currentPath.shape.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var a1 = fromY - y1;\n    var b1 = fromX - x1;\n    var a2 = y2 - y1;\n    var b2 = x2 - x1;\n    var mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1.0e-8 || radius === 0) {\n      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n        points.push(x1, y1);\n      }\n    } else {\n      var dd = a1 * a1 + b1 * b1;\n      var cc = a2 * a2 + b2 * b2;\n      var tt = a1 * a2 + b1 * b2;\n      var k1 = radius * Math.sqrt(dd) / mm;\n      var k2 = radius * Math.sqrt(cc) / mm;\n      var j1 = k1 * tt / dd;\n      var j2 = k2 * tt / cc;\n      var cx = k1 * b2 + k2 * b1;\n      var cy = k1 * a2 + k2 * a1;\n      var px = b1 * (k2 + j1);\n      var py = a1 * (k2 + j1);\n      var qx = b2 * (k1 + j2);\n      var qy = a2 * (k1 + j2);\n      var startAngle = Math.atan2(py - cy, px - cx);\n      var endAngle = Math.atan2(qy - cy, qx - cx);\n      this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n    }\n    this.dirty++;\n    return this;\n  };\n\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   *\n   * @param {number} cx - The x-coordinate of the center of the circle\n   * @param {number} cy - The y-coordinate of the center of the circle\n   * @param {number} radius - The radius of the circle\n   * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param {number} endAngle - The ending angle, in radians\n   * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.arc = function arc(cx, cy, radius, startAngle, endAngle) {\n    var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    if (startAngle === endAngle) {\n      return this;\n    }\n    if (!anticlockwise && endAngle <= startAngle) {\n      endAngle += _const.PI_2;\n    } else if (anticlockwise && startAngle <= endAngle) {\n      startAngle += _const.PI_2;\n    }\n    var sweep = endAngle - startAngle;\n    var segs = Graphics.CURVES.adaptive ? this._segmentsCount(Math.abs(sweep) * radius) : Math.ceil(Math.abs(sweep) / _const.PI_2) * 40;\n    if (sweep === 0) {\n      return this;\n    }\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n\n    // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n    var points = this.currentPath ? this.currentPath.shape.points : null;\n    if (points) {\n      // We check how far our start is from the last existing point\n      var xDiff = Math.abs(points[points.length - 2] - startX);\n      var yDiff = Math.abs(points[points.length - 1] - startY);\n      if (xDiff < 0.001 && yDiff < 0.001) {\n        // If the point is very close, we don't add it, since this would lead to artifacts\n        // during tesselation due to floating point imprecision.\n      } else {\n        points.push(startX, startY);\n      }\n    } else {\n      this.moveTo(startX, startY);\n      points = this.currentPath.shape.points;\n    }\n    var theta = sweep / (segs * 2);\n    var theta2 = theta * 2;\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n    var segMinus = segs - 1;\n    var remainder = segMinus % 1 / segMinus;\n    for (var i = 0; i <= segMinus; ++i) {\n      var real = i + remainder * i;\n      var angle = theta + startAngle + theta2 * real;\n      var c = Math.cos(angle);\n      var s = -Math.sin(angle);\n      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n    }\n    this.dirty++;\n    return this;\n  };\n\n  /**\n   * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n   * (such as lineTo() or drawCircle()) use when drawing.\n   *\n   * @param {number} [color=0] - the color of the fill\n   * @param {number} [alpha=1] - the alpha of the fill\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.beginFill = function beginFill() {\n    var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this.filling = true;\n    this.fillColor = color;\n    this.fillAlpha = alpha;\n    if (this.currentPath) {\n      if (this.currentPath.shape.points.length <= 2) {\n        this.currentPath.fill = this.filling;\n        this.currentPath.fillColor = this.fillColor;\n        this.currentPath.fillAlpha = this.fillAlpha;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n   *\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.endFill = function endFill() {\n    this.filling = false;\n    this.fillColor = null;\n    this.fillAlpha = 1;\n    return this;\n  };\n\n  /**\n   *\n   * @param {number} x - The X coord of the top-left of the rectangle\n   * @param {number} y - The Y coord of the top-left of the rectangle\n   * @param {number} width - The width of the rectangle\n   * @param {number} height - The height of the rectangle\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.drawRect = function drawRect(x, y, width, height) {\n    this.drawShape(new _math.Rectangle(x, y, width, height));\n    return this;\n  };\n\n  /**\n   *\n   * @param {number} x - The X coord of the top-left of the rectangle\n   * @param {number} y - The Y coord of the top-left of the rectangle\n   * @param {number} width - The width of the rectangle\n   * @param {number} height - The height of the rectangle\n   * @param {number} radius - Radius of the rectangle corners\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.drawRoundedRect = function drawRoundedRect(x, y, width, height, radius) {\n    this.drawShape(new _math.RoundedRectangle(x, y, width, height, radius));\n    return this;\n  };\n\n  /**\n   * Draws a circle.\n   *\n   * @param {number} x - The X coordinate of the center of the circle\n   * @param {number} y - The Y coordinate of the center of the circle\n   * @param {number} radius - The radius of the circle\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.drawCircle = function drawCircle(x, y, radius) {\n    this.drawShape(new _math.Circle(x, y, radius));\n    return this;\n  };\n\n  /**\n   * Draws an ellipse.\n   *\n   * @param {number} x - The X coordinate of the center of the ellipse\n   * @param {number} y - The Y coordinate of the center of the ellipse\n   * @param {number} width - The half width of the ellipse\n   * @param {number} height - The half height of the ellipse\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.drawEllipse = function drawEllipse(x, y, width, height) {\n    this.drawShape(new _math.Ellipse(x, y, width, height));\n    return this;\n  };\n\n  /**\n   * Draws a polygon using the given path.\n   *\n   * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.drawPolygon = function drawPolygon(path) {\n    // prevents an argument assignment deopt\n    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    var points = path;\n    var closed = true;\n    if (points instanceof _math.Polygon) {\n      closed = points.closed;\n      points = points.points;\n    }\n    if (!Array.isArray(points)) {\n      // prevents an argument leak deopt\n      // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n      points = new Array(arguments.length);\n      for (var i = 0; i < points.length; ++i) {\n        points[i] = arguments[i]; // eslint-disable-line prefer-rest-params\n      }\n    }\n\n    var shape = new _math.Polygon(points);\n    shape.closed = closed;\n    this.drawShape(shape);\n    return this;\n  };\n\n  /**\n   * Draw a star shape with an abitrary number of points.\n   *\n   * @param {number} x - Center X position of the star\n   * @param {number} y - Center Y position of the star\n   * @param {number} points - The number of points of the star, must be > 1\n   * @param {number} radius - The outer radius of the star\n   * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n   * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.drawStar = function drawStar(x, y, points, radius, innerRadius) {\n    var rotation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    innerRadius = innerRadius || radius / 2;\n    var startAngle = -1 * Math.PI / 2 + rotation;\n    var len = points * 2;\n    var delta = _const.PI_2 / len;\n    var polygon = [];\n    for (var i = 0; i < len; i++) {\n      var r = i % 2 ? innerRadius : radius;\n      var angle = i * delta + startAngle;\n      polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));\n    }\n    return this.drawPolygon(polygon);\n  };\n\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   *\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n  Graphics.prototype.clear = function clear() {\n    if (this.lineWidth || this.filling || this.graphicsData.length > 0) {\n      this.lineWidth = 0;\n      this.lineAlignment = 0.5;\n      this.filling = false;\n      this.boundsDirty = -1;\n      this.canvasTintDirty = -1;\n      this.dirty++;\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n    this.currentPath = null;\n    this._spriteRect = null;\n    return this;\n  };\n\n  /**\n   * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n   * masked with gl.scissor.\n   *\n   * @returns {boolean} True if only 1 rect.\n   */\n\n  Graphics.prototype.isFastRect = function isFastRect() {\n    return this.graphicsData.length === 1 && this.graphicsData[0].shape.type === _const.SHAPES.RECT && !this.graphicsData[0].lineWidth;\n  };\n\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n  Graphics.prototype._renderWebGL = function _renderWebGL(renderer) {\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if (this.dirty !== this.fastRectDirty) {\n      this.fastRectDirty = this.dirty;\n      this._fastRect = this.isFastRect();\n    }\n\n    // TODO this check can be moved to dirty?\n    if (this._fastRect) {\n      this._renderSpriteRect(renderer);\n    } else {\n      renderer.setObjectRenderer(renderer.plugins.graphics);\n      renderer.plugins.graphics.render(this);\n    }\n  };\n\n  /**\n   * Renders a sprite rectangle.\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n  Graphics.prototype._renderSpriteRect = function _renderSpriteRect(renderer) {\n    var rect = this.graphicsData[0].shape;\n    if (!this._spriteRect) {\n      this._spriteRect = new _Sprite2.default(new _Texture2.default(_Texture2.default.WHITE));\n    }\n    var sprite = this._spriteRect;\n    var fillColor = this.graphicsData[0].fillColor;\n    if (this.tint === 0xffffff) {\n      sprite.tint = fillColor;\n    } else if (this.tint !== this._prevRectTint || fillColor !== this._prevRectFillColor) {\n      var t1 = tempColor1;\n      var t2 = tempColor2;\n      (0, _utils.hex2rgb)(fillColor, t1);\n      (0, _utils.hex2rgb)(this.tint, t2);\n      t1[0] *= t2[0];\n      t1[1] *= t2[1];\n      t1[2] *= t2[2];\n      sprite.tint = (0, _utils.rgb2hex)(t1);\n      this._prevRectTint = this.tint;\n      this._prevRectFillColor = fillColor;\n    }\n    sprite.alpha = this.graphicsData[0].fillAlpha;\n    sprite.worldAlpha = this.worldAlpha * sprite.alpha;\n    sprite.blendMode = this.blendMode;\n    sprite._texture._frame.width = rect.width;\n    sprite._texture._frame.height = rect.height;\n    sprite.transform.worldTransform = this.transform.worldTransform;\n    sprite.anchor.set(-rect.x / rect.width, -rect.y / rect.height);\n    sprite._onAnchorUpdate();\n    sprite._renderWebGL(renderer);\n  };\n\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */\n\n  Graphics.prototype._renderCanvas = function _renderCanvas(renderer) {\n    if (this.isMask === true) {\n      return;\n    }\n    renderer.plugins.graphics.render(this);\n  };\n\n  /**\n   * Retrieves the bounds of the graphic shape as a rectangle object\n   *\n   * @private\n   */\n\n  Graphics.prototype._calculateBounds = function _calculateBounds() {\n    if (this.boundsDirty !== this.dirty) {\n      this.boundsDirty = this.dirty;\n      this.updateLocalBounds();\n      this.cachedSpriteDirty = true;\n    }\n    var lb = this._localBounds;\n    this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);\n  };\n\n  /**\n   * Tests if a point is inside this graphics object\n   *\n   * @param {PIXI.Point} point - the point to test\n   * @return {boolean} the result of the test\n   */\n\n  Graphics.prototype.containsPoint = function containsPoint(point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    var graphicsData = this.graphicsData;\n    for (var i = 0; i < graphicsData.length; ++i) {\n      var data = graphicsData[i];\n      if (!data.fill) {\n        continue;\n      }\n\n      // only deal with fills..\n      if (data.shape) {\n        if (data.shape.contains(tempPoint.x, tempPoint.y)) {\n          var hitHole = false;\n          if (data.holes) {\n            for (var _i = 0; _i < data.holes.length; _i++) {\n              var hole = data.holes[_i];\n              if (hole.contains(tempPoint.x, tempPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Update the bounds of the object\n   *\n   */\n\n  Graphics.prototype.updateLocalBounds = function updateLocalBounds() {\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    if (this.graphicsData.length) {\n      var shape = 0;\n      var x = 0;\n      var y = 0;\n      var w = 0;\n      var h = 0;\n      for (var i = 0; i < this.graphicsData.length; i++) {\n        var data = this.graphicsData[i];\n        var type = data.type;\n        var lineWidth = data.lineWidth;\n        var lineAlignment = data.lineAlignment;\n        var lineOffset = lineWidth * lineAlignment;\n        shape = data.shape;\n        if (type === _const.SHAPES.RECT || type === _const.SHAPES.RREC) {\n          x = shape.x - lineOffset;\n          y = shape.y - lineOffset;\n          w = shape.width + lineOffset * 2;\n          h = shape.height + lineOffset * 2;\n          minX = x < minX ? x : minX;\n          maxX = x + w > maxX ? x + w : maxX;\n          minY = y < minY ? y : minY;\n          maxY = y + h > maxY ? y + h : maxY;\n        } else if (type === _const.SHAPES.CIRC) {\n          x = shape.x;\n          y = shape.y;\n          w = shape.radius + lineOffset;\n          h = shape.radius + lineOffset;\n          minX = x - w < minX ? x - w : minX;\n          maxX = x + w > maxX ? x + w : maxX;\n          minY = y - h < minY ? y - h : minY;\n          maxY = y + h > maxY ? y + h : maxY;\n        } else if (type === _const.SHAPES.ELIP) {\n          x = shape.x;\n          y = shape.y;\n          w = shape.width + lineOffset;\n          h = shape.height + lineOffset;\n          minX = x - w < minX ? x - w : minX;\n          maxX = x + w > maxX ? x + w : maxX;\n          minY = y - h < minY ? y - h : minY;\n          maxY = y + h > maxY ? y + h : maxY;\n        } else {\n          // POLY\n          var points = shape.points;\n          var x2 = 0;\n          var y2 = 0;\n          var dx = 0;\n          var dy = 0;\n          var rw = 0;\n          var rh = 0;\n          var cx = 0;\n          var cy = 0;\n          for (var j = 0; j + 2 < points.length; j += 2) {\n            x = points[j];\n            y = points[j + 1];\n            x2 = points[j + 2];\n            y2 = points[j + 3];\n            dx = Math.abs(x2 - x);\n            dy = Math.abs(y2 - y);\n            h = lineOffset * 2;\n            w = Math.sqrt(dx * dx + dy * dy);\n            if (w < 1e-9) {\n              continue;\n            }\n            rw = (h / w * dy + dx) / 2;\n            rh = (h / w * dx + dy) / 2;\n            cx = (x2 + x) / 2;\n            cy = (y2 + y) / 2;\n            minX = cx - rw < minX ? cx - rw : minX;\n            maxX = cx + rw > maxX ? cx + rw : maxX;\n            minY = cy - rh < minY ? cy - rh : minY;\n            maxY = cy + rh > maxY ? cy + rh : maxY;\n          }\n        }\n      }\n    } else {\n      minX = 0;\n      maxX = 0;\n      minY = 0;\n      maxY = 0;\n    }\n    var padding = this.boundsPadding;\n    this._localBounds.minX = minX - padding;\n    this._localBounds.maxX = maxX + padding;\n    this._localBounds.minY = minY - padding;\n    this._localBounds.maxY = maxY + padding;\n  };\n\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @return {PIXI.GraphicsData} The generated GraphicsData object.\n   */\n\n  Graphics.prototype.drawShape = function drawShape(shape) {\n    if (this.currentPath) {\n      // check current path!\n      if (this.currentPath.shape.points.length <= 2) {\n        this.graphicsData.pop();\n      }\n    }\n    this.currentPath = null;\n    var data = new _GraphicsData2.default(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, this.nativeLines, shape, this.lineAlignment);\n    this.graphicsData.push(data);\n    if (data.type === _const.SHAPES.POLY) {\n      data.shape.closed = data.shape.closed;\n      this.currentPath = data;\n    }\n    this.dirty++;\n    return data;\n  };\n\n  /**\n   * Generates a canvas texture.\n   *\n   * @param {number} scaleMode - The scale mode of the texture.\n   * @param {number} resolution - The resolution of the texture.\n   * @return {PIXI.Texture} The new texture.\n   */\n\n  Graphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode) {\n    var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var bounds = this.getLocalBounds();\n    var canvasBuffer = _RenderTexture2.default.create(bounds.width, bounds.height, scaleMode, resolution);\n    if (!canvasRenderer) {\n      canvasRenderer = new _CanvasRenderer2.default();\n    }\n    this.transform.updateLocalTransform();\n    this.transform.localTransform.copy(tempMatrix);\n    tempMatrix.invert();\n    tempMatrix.tx -= bounds.x;\n    tempMatrix.ty -= bounds.y;\n    canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n    var texture = _Texture2.default.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode, 'graphics');\n    texture.baseTexture.resolution = resolution;\n    texture.baseTexture.update();\n    return texture;\n  };\n\n  /**\n   * Closes the current path.\n   *\n   * @return {PIXI.Graphics} Returns itself.\n   */\n\n  Graphics.prototype.closePath = function closePath() {\n    // ok so close path assumes next one is a hole!\n    var currentPath = this.currentPath;\n    if (currentPath && currentPath.shape) {\n      currentPath.shape.close();\n    }\n    return this;\n  };\n\n  /**\n   * Adds a hole in the current path.\n   *\n   * @return {PIXI.Graphics} Returns itself.\n   */\n\n  Graphics.prototype.addHole = function addHole() {\n    // this is a hole!\n    var hole = this.graphicsData.pop();\n    this.currentPath = this.graphicsData[this.graphicsData.length - 1];\n    this.currentPath.addHole(hole.shape);\n    this.currentPath = null;\n    return this;\n  };\n\n  /**\n   * Destroys the Graphics object.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n  Graphics.prototype.destroy = function destroy(options) {\n    _Container.prototype.destroy.call(this, options);\n\n    // destroy each of the GraphicsData objects\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n      this.graphicsData[i].destroy();\n    }\n\n    // for each webgl data entry, destroy the WebGLGraphicsData\n    for (var id in this._webGL) {\n      for (var j = 0; j < this._webGL[id].data.length; ++j) {\n        this._webGL[id].data[j].destroy();\n      }\n    }\n    if (this._spriteRect) {\n      this._spriteRect.destroy();\n    }\n    this.graphicsData = null;\n    this.currentPath = null;\n    this._webGL = null;\n    this._localBounds = null;\n  };\n  return Graphics;\n}(_Container3.default);\nexports.default = Graphics;\nGraphics._SPRITE_TEXTURE = null;\n\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI.Graphics\n * @name CURVES\n * @type {object}\n * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nGraphics.CURVES = {\n  adaptive: false,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048\n};","map":{"version":3,"names":["_Container2","require","_RenderTexture","_Texture","_GraphicsData","_Sprite","_math","_utils","_const","_Bounds","_bezierCurveTo2","_CanvasRenderer","canvasRenderer","tempMatrix","Matrix","tempPoint","Point","tempColor1","Float32Array","tempColor2","Graphics","nativeLines","arguments","length","undefined","_classCallCheck","_this","_possibleConstructorReturn","_Container","call","fillAlpha","lineWidth","lineColor","lineAlignment","graphicsData","tint","_prevTint","blendMode","BLEND_MODES","NORMAL","currentPath","_webGL","isMask","boundsPadding","_localBounds","_Bounds2","default","dirty","fastRectDirty","clearDirty","boundsDirty","cachedSpriteDirty","_spriteRect","_fastRect","_prevRectTint","_prevRectFillColor","clone","renderable","i","push","updateLocalBounds","_quadraticCurveLength","fromX","fromY","cpX","cpY","toX","toY","ax","ay","bx","by","a","b","c","s","Math","sqrt","a2","a32","c2","ba","log","_bezierCurveLength","cpX2","cpY2","n","result","t","t2","t3","nt","nt2","nt3","x","y","dx","dy","prevX","prevY","_segmentsCount","ceil","CURVES","maxLength","minSegments","maxSegments","lineStyle","color","alpha","alignment","lineAlpha","shape","points","Polygon","slice","closed","drawShape","moveTo","lineTo","quadraticCurveTo","xa","ya","adaptive","j","bezierCurveTo","_bezierCurveTo3","arcTo","x1","y1","x2","y2","radius","a1","b1","b2","mm","abs","dd","cc","tt","k1","k2","j1","j2","cx","cy","px","py","qx","qy","startAngle","atan2","endAngle","arc","anticlockwise","PI_2","sweep","segs","startX","cos","startY","sin","xDiff","yDiff","theta","theta2","cTheta","sTheta","segMinus","remainder","real","angle","beginFill","filling","fillColor","fill","endFill","drawRect","width","height","Rectangle","drawRoundedRect","RoundedRectangle","drawCircle","Circle","drawEllipse","Ellipse","drawPolygon","path","Array","isArray","drawStar","innerRadius","rotation","PI","len","delta","polygon","r","clear","canvasTintDirty","isFastRect","type","SHAPES","RECT","_renderWebGL","renderer","_renderSpriteRect","setObjectRenderer","plugins","graphics","render","rect","_Sprite2","_Texture2","WHITE","sprite","t1","hex2rgb","rgb2hex","worldAlpha","_texture","_frame","transform","worldTransform","anchor","set","_onAnchorUpdate","_renderCanvas","_calculateBounds","lb","_bounds","addFrame","minX","minY","maxX","maxY","containsPoint","point","applyInverse","data","contains","hitHole","holes","_i","hole","Infinity","w","h","lineOffset","RREC","CIRC","ELIP","rw","rh","padding","pop","_GraphicsData2","POLY","generateCanvasTexture","scaleMode","resolution","bounds","getLocalBounds","canvasBuffer","_RenderTexture2","create","_CanvasRenderer2","updateLocalTransform","localTransform","copy","invert","tx","ty","texture","fromCanvas","baseTexture","_canvasRenderTarget","canvas","update","closePath","close","addHole","destroy","options","prototype","id","_SPRITE_TEXTURE"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/graphics/Graphics.js"],"sourcesContent":["import Container from '../display/Container';\nimport RenderTexture from '../textures/RenderTexture';\nimport Texture from '../textures/Texture';\nimport GraphicsData from './GraphicsData';\nimport Sprite from '../sprites/Sprite';\nimport { Matrix, Point, Rectangle, RoundedRectangle, Ellipse, Polygon, Circle } from '../math';\nimport { hex2rgb, rgb2hex } from '../utils';\nimport { SHAPES, BLEND_MODES, PI_2 } from '../const';\nimport Bounds from '../display/Bounds';\nimport bezierCurveTo from './utils/bezierCurveTo';\nimport CanvasRenderer from '../renderers/canvas/CanvasRenderer';\n\nlet canvasRenderer;\nconst tempMatrix = new Matrix();\nconst tempPoint = new Point();\nconst tempColor1 = new Float32Array(4);\nconst tempColor2 = new Float32Array(4);\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nexport default class Graphics extends Container\n{\n    /**\n     *\n     * @param {boolean} [nativeLines=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     */\n    constructor(nativeLines = false)\n    {\n        super();\n\n        /**\n         * The alpha value used when filling the Graphics object.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.fillAlpha = 1;\n\n        /**\n         * The width (thickness) of any lines drawn.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.lineWidth = 0;\n\n        /**\n         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n         *\n         * @member {boolean}\n         */\n        this.nativeLines = nativeLines;\n\n        /**\n         * The color of any lines drawn.\n         *\n         * @member {string}\n         * @default 0\n         */\n        this.lineColor = 0;\n\n        /**\n         * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).\n         *\n         * @member {number}\n         * @default 0.5\n         */\n        this.lineAlignment = 0.5;\n\n        /**\n         * Graphics data\n         *\n         * @member {PIXI.GraphicsData[]}\n         * @private\n         */\n        this.graphicsData = [];\n\n        /**\n         * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to\n         * reset the tint.\n         *\n         * @member {number}\n         * @default 0xFFFFFF\n         */\n        this.tint = 0xFFFFFF;\n\n        /**\n         * The previous tint applied to the graphic shape. Used to compare to the current tint and\n         * check if theres change.\n         *\n         * @member {number}\n         * @private\n         * @default 0xFFFFFF\n         */\n        this._prevTint = 0xFFFFFF;\n\n        /**\n         * The blend mode to be applied to the graphic shape. Apply a value of\n         * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL;\n         * @see PIXI.BLEND_MODES\n         */\n        this.blendMode = BLEND_MODES.NORMAL;\n\n        /**\n         * Current path\n         *\n         * @member {PIXI.GraphicsData}\n         * @private\n         */\n        this.currentPath = null;\n\n        /**\n         * Array containing some WebGL-related properties used by the WebGL renderer.\n         *\n         * @member {object<number, object>}\n         * @private\n         */\n        // TODO - _webgl should use a prototype object, not a random undocumented object...\n        this._webGL = {};\n\n        /**\n         * Whether this shape is being used as a mask.\n         *\n         * @member {boolean}\n         */\n        this.isMask = false;\n\n        /**\n         * The bounds' padding used for bounds calculation.\n         *\n         * @member {number}\n         */\n        this.boundsPadding = 0;\n\n        /**\n         * A cache of the local bounds to prevent recalculation.\n         *\n         * @member {PIXI.Rectangle}\n         * @private\n         */\n        this._localBounds = new Bounds();\n\n        /**\n         * Used to detect if the graphics object has changed. If this is set to true then the graphics\n         * object will be recalculated.\n         *\n         * @member {boolean}\n         * @private\n         */\n        this.dirty = 0;\n\n        /**\n         * Used to detect if we need to do a fast rect check using the id compare method\n         * @type {Number}\n         */\n        this.fastRectDirty = -1;\n\n        /**\n         * Used to detect if we clear the graphics webGL data\n         * @type {Number}\n         */\n        this.clearDirty = 0;\n\n        /**\n         * Used to detect if we we need to recalculate local bounds\n         * @type {Number}\n         */\n        this.boundsDirty = -1;\n\n        /**\n         * Used to detect if the cached sprite object needs to be updated.\n         *\n         * @member {boolean}\n         * @private\n         */\n        this.cachedSpriteDirty = false;\n\n        this._spriteRect = null;\n        this._fastRect = false;\n\n        this._prevRectTint = null;\n        this._prevRectFillColor = null;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         *\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n     *\n     * @return {PIXI.Graphics} A clone of the graphics object\n     */\n    clone()\n    {\n        const clone = new Graphics();\n\n        clone.renderable = this.renderable;\n        clone.fillAlpha = this.fillAlpha;\n        clone.lineWidth = this.lineWidth;\n        clone.lineColor = this.lineColor;\n        clone.lineAlignment = this.lineAlignment;\n        clone.tint = this.tint;\n        clone.blendMode = this.blendMode;\n        clone.isMask = this.isMask;\n        clone.boundsPadding = this.boundsPadding;\n        clone.dirty = 0;\n        clone.cachedSpriteDirty = this.cachedSpriteDirty;\n\n        // copy graphics data\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            clone.graphicsData.push(this.graphicsData[i].clone());\n        }\n\n        clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];\n\n        clone.updateLocalBounds();\n\n        return clone;\n    }\n\n    /**\n     * Calculate length of quadratic curve\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n     * for the detailed explanation of math behind this.\n     *\n     * @private\n     * @param {number} fromX - x-coordinate of curve start point\n     * @param {number} fromY - y-coordinate of curve start point\n     * @param {number} cpX - x-coordinate of curve control point\n     * @param {number} cpY - y-coordinate of curve control point\n     * @param {number} toX - x-coordinate of curve end point\n     * @param {number} toY - y-coordinate of curve end point\n     * @return {number} Length of quadratic curve\n     */\n    _quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY)\n    {\n        const ax = fromX - (2.0 * cpX) + toX;\n        const ay = fromY - (2.0 * cpY) + toY;\n        const bx = (2.0 * cpX) - (2.0 * fromX);\n        const by = (2.0 * cpY) - (2.0 * fromY);\n        const a = 4.0 * ((ax * ax) + (ay * ay));\n        const b = 4.0 * ((ax * bx) + (ay * by));\n        const c = (bx * bx) + (by * by);\n\n        const s = 2.0 * Math.sqrt(a + b + c);\n        const a2 = Math.sqrt(a);\n        const a32 = 2.0 * a * a2;\n        const c2 = 2.0 * Math.sqrt(c);\n        const ba = b / a2;\n\n        return (\n                (a32 * s)\n                + (a2 * b * (s - c2))\n                + (\n                   ((4.0 * c * a) - (b * b))\n                   * Math.log(((2.0 * a2) + ba + s) / (ba + c2))\n                  )\n               )\n               / (4.0 * a32);\n    }\n\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     *\n     * @private\n     * @param {number} fromX - Starting point x\n     * @param {number} fromY - Starting point y\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {number} Length of bezier curve\n     */\n    _bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate number of segments for the curve based on its length to ensure its smoothness.\n     *\n     * @private\n     * @param {number} length - length of curve\n     * @return {number} Number of segments\n     */\n    _segmentsCount(length)\n    {\n        let result = Math.ceil(length / Graphics.CURVES.maxLength);\n\n        if (result < Graphics.CURVES.minSegments)\n        {\n            result = Graphics.CURVES.minSegments;\n        }\n        else if (result > Graphics.CURVES.maxSegments)\n        {\n            result = Graphics.CURVES.maxSegments;\n        }\n\n        return result;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [color=0] - color of the line to draw, will update the objects stored style\n     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineStyle(lineWidth = 0, color = 0, alpha = 1, alignment = 0.5)\n    {\n        this.lineWidth = lineWidth;\n        this.lineColor = color;\n        this.lineAlpha = alpha;\n        this.lineAlignment = alignment;\n\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length)\n            {\n                // halfway through a line? start a new one!\n                const shape = new Polygon(this.currentPath.shape.points.slice(-2));\n\n                shape.closed = false;\n\n                this.drawShape(shape);\n            }\n            else\n            {\n                // otherwise its empty so lets just set the line properties\n                this.currentPath.lineWidth = this.lineWidth;\n                this.currentPath.lineColor = this.lineColor;\n                this.currentPath.lineAlpha = this.lineAlpha;\n                this.currentPath.lineAlignment = this.lineAlignment;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     *\n     * @param {number} x - the X coordinate to move to\n     * @param {number} y - the Y coordinate to move to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    moveTo(x, y)\n    {\n        const shape = new Polygon([x, y]);\n\n        shape.closed = false;\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     *\n     * @param {number} x - the X coordinate to draw to\n     * @param {number} y - the Y coordinate to draw to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineTo(x, y)\n    {\n        const points = this.currentPath.shape.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n            this.dirty++;\n        }\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    quadraticCurveTo(cpX, cpY, toX, toY)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length === 0)\n            {\n                this.currentPath.shape.points = [0, 0];\n            }\n        }\n        else\n        {\n            this.moveTo(0, 0);\n        }\n\n        const points = this.currentPath.shape.points;\n        let xa = 0;\n        let ya = 0;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n        const n = Graphics.CURVES.adaptive\n                  ? this._segmentsCount(this._quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY))\n                  : 20;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length === 0)\n            {\n                this.currentPath.shape.points = [0, 0];\n            }\n        }\n        else\n        {\n            this.moveTo(0, 0);\n        }\n\n        const points = this.currentPath.shape.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = Graphics.CURVES.adaptive\n                  ? this._segmentsCount(this._bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY))\n                  : 20;\n\n        bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n, points);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @param {number} x1 - The x-coordinate of the beginning of the arc\n     * @param {number} y1 - The y-coordinate of the beginning of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arcTo(x1, y1, x2, y2, radius)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length === 0)\n            {\n                this.currentPath.shape.points.push(x1, y1);\n            }\n        }\n        else\n        {\n            this.moveTo(x1, y1);\n        }\n\n        const points = this.currentPath.shape.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n        }\n        else\n        {\n            const dd = (a1 * a1) + (b1 * b1);\n            const cc = (a2 * a2) + (b2 * b2);\n            const tt = (a1 * a2) + (b1 * b2);\n            const k1 = radius * Math.sqrt(dd) / mm;\n            const k2 = radius * Math.sqrt(cc) / mm;\n            const j1 = k1 * tt / dd;\n            const j2 = k2 * tt / cc;\n            const cx = (k1 * b2) + (k2 * b1);\n            const cy = (k1 * a2) + (k2 * a1);\n            const px = b1 * (k2 + j1);\n            const py = a1 * (k2 + j1);\n            const qx = b2 * (k1 + j2);\n            const qy = a2 * (k1 + j2);\n            const startAngle = Math.atan2(py - cy, px - cx);\n            const endAngle = Math.atan2(qy - cy, qx - cx);\n\n            this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n        }\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false)\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n        const segs = Graphics.CURVES.adaptive\n                     ? this._segmentsCount(Math.abs(sweep) * radius)\n                     : Math.ceil(Math.abs(sweep) / PI_2) * 40;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.shape.points : null;\n\n        if (points)\n        {\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < 0.001 && yDiff < 0.001)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tesselation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.shape.points;\n        }\n\n        const theta = sweep / (segs * 2);\n        const theta2 = theta * 2;\n\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n\n        const segMinus = segs - 1;\n\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n\n            const angle = ((theta) + startAngle + (theta2 * real));\n\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     *\n     * @param {number} [color=0] - the color of the fill\n     * @param {number} [alpha=1] - the alpha of the fill\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginFill(color = 0, alpha = 1)\n    {\n        this.filling = true;\n        this.fillColor = color;\n        this.fillAlpha = alpha;\n\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length <= 2)\n            {\n                this.currentPath.fill = this.filling;\n                this.currentPath.fillColor = this.fillColor;\n                this.currentPath.fillAlpha = this.fillAlpha;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    endFill()\n    {\n        this.filling = false;\n        this.fillColor = null;\n        this.fillAlpha = 1;\n\n        return this;\n    }\n\n    /**\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRect(x, y, width, height)\n    {\n        this.drawShape(new Rectangle(x, y, width, height));\n\n        return this;\n    }\n\n    /**\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @param {number} radius - Radius of the rectangle corners\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRoundedRect(x, y, width, height, radius)\n    {\n        this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n\n        return this;\n    }\n\n    /**\n     * Draws a circle.\n     *\n     * @param {number} x - The X coordinate of the center of the circle\n     * @param {number} y - The Y coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawCircle(x, y, radius)\n    {\n        this.drawShape(new Circle(x, y, radius));\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse.\n     *\n     * @param {number} x - The X coordinate of the center of the ellipse\n     * @param {number} y - The Y coordinate of the center of the ellipse\n     * @param {number} width - The half width of the ellipse\n     * @param {number} height - The half height of the ellipse\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawEllipse(x, y, width, height)\n    {\n        this.drawShape(new Ellipse(x, y, width, height));\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon using the given path.\n     *\n     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawPolygon(path)\n    {\n        // prevents an argument assignment deopt\n        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        let points = path;\n\n        let closed = true;\n\n        if (points instanceof Polygon)\n        {\n            closed = points.closed;\n            points = points.points;\n        }\n\n        if (!Array.isArray(points))\n        {\n            // prevents an argument leak deopt\n            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n            points = new Array(arguments.length);\n\n            for (let i = 0; i < points.length; ++i)\n            {\n                points[i] = arguments[i]; // eslint-disable-line prefer-rest-params\n            }\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closed = closed;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draw a star shape with an abitrary number of points.\n     *\n     * @param {number} x - Center X position of the star\n     * @param {number} y - Center Y position of the star\n     * @param {number} points - The number of points of the star, must be > 1\n     * @param {number} radius - The outer radius of the star\n     * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawStar(x, y, points, radius, innerRadius, rotation = 0)\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = PI_2 / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        return this.drawPolygon(polygon);\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    clear()\n    {\n        if (this.lineWidth || this.filling || this.graphicsData.length > 0)\n        {\n            this.lineWidth = 0;\n            this.lineAlignment = 0.5;\n\n            this.filling = false;\n\n            this.boundsDirty = -1;\n            this.canvasTintDirty = -1;\n            this.dirty++;\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        this.currentPath = null;\n        this._spriteRect = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     *\n     * @returns {boolean} True if only 1 rect.\n     */\n    isFastRect()\n    {\n        return this.graphicsData.length === 1\n            && this.graphicsData[0].shape.type === SHAPES.RECT\n            && !this.graphicsData[0].lineWidth;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer)\n    {\n        // if the sprite is not visible or the alpha is 0 then no need to render this element\n        if (this.dirty !== this.fastRectDirty)\n        {\n            this.fastRectDirty = this.dirty;\n            this._fastRect = this.isFastRect();\n        }\n\n        // TODO this check can be moved to dirty?\n        if (this._fastRect)\n        {\n            this._renderSpriteRect(renderer);\n        }\n        else\n        {\n            renderer.setObjectRenderer(renderer.plugins.graphics);\n            renderer.plugins.graphics.render(this);\n        }\n    }\n\n    /**\n     * Renders a sprite rectangle.\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderSpriteRect(renderer)\n    {\n        const rect = this.graphicsData[0].shape;\n\n        if (!this._spriteRect)\n        {\n            this._spriteRect = new Sprite(new Texture(Texture.WHITE));\n        }\n\n        const sprite = this._spriteRect;\n        const fillColor = this.graphicsData[0].fillColor;\n\n        if (this.tint === 0xffffff)\n        {\n            sprite.tint = fillColor;\n        }\n        else if (this.tint !== this._prevRectTint || fillColor !== this._prevRectFillColor)\n        {\n            const t1 = tempColor1;\n            const t2 = tempColor2;\n\n            hex2rgb(fillColor, t1);\n            hex2rgb(this.tint, t2);\n\n            t1[0] *= t2[0];\n            t1[1] *= t2[1];\n            t1[2] *= t2[2];\n\n            sprite.tint = rgb2hex(t1);\n\n            this._prevRectTint = this.tint;\n            this._prevRectFillColor = fillColor;\n        }\n\n        sprite.alpha = this.graphicsData[0].fillAlpha;\n        sprite.worldAlpha = this.worldAlpha * sprite.alpha;\n        sprite.blendMode = this.blendMode;\n\n        sprite._texture._frame.width = rect.width;\n        sprite._texture._frame.height = rect.height;\n\n        sprite.transform.worldTransform = this.transform.worldTransform;\n\n        sprite.anchor.set(-rect.x / rect.width, -rect.y / rect.height);\n        sprite._onAnchorUpdate();\n\n        sprite._renderWebGL(renderer);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer)\n    {\n        if (this.isMask === true)\n        {\n            return;\n        }\n\n        renderer.plugins.graphics.render(this);\n    }\n\n    /**\n     * Retrieves the bounds of the graphic shape as a rectangle object\n     *\n     * @private\n     */\n    _calculateBounds()\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.updateLocalBounds();\n\n            this.cachedSpriteDirty = true;\n        }\n\n        const lb = this._localBounds;\n\n        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fill)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.shape.contains(tempPoint.x, tempPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.contains(tempPoint.x, tempPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Update the bounds of the object\n     *\n     */\n    updateLocalBounds()\n    {\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        if (this.graphicsData.length)\n        {\n            let shape = 0;\n            let x = 0;\n            let y = 0;\n            let w = 0;\n            let h = 0;\n\n            for (let i = 0; i < this.graphicsData.length; i++)\n            {\n                const data = this.graphicsData[i];\n                const type = data.type;\n                const lineWidth = data.lineWidth;\n                const lineAlignment = data.lineAlignment;\n\n                const lineOffset = lineWidth * lineAlignment;\n\n                shape = data.shape;\n\n                if (type === SHAPES.RECT || type === SHAPES.RREC)\n                {\n                    x = shape.x - lineOffset;\n                    y = shape.y - lineOffset;\n                    w = shape.width + (lineOffset * 2);\n                    h = shape.height + (lineOffset * 2);\n\n                    minX = x < minX ? x : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y < minY ? y : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else if (type === SHAPES.CIRC)\n                {\n                    x = shape.x;\n                    y = shape.y;\n                    w = shape.radius + lineOffset;\n                    h = shape.radius + lineOffset;\n\n                    minX = x - w < minX ? x - w : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y - h < minY ? y - h : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else if (type === SHAPES.ELIP)\n                {\n                    x = shape.x;\n                    y = shape.y;\n                    w = shape.width + lineOffset;\n                    h = shape.height + lineOffset;\n\n                    minX = x - w < minX ? x - w : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y - h < minY ? y - h : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else\n                {\n                    // POLY\n                    const points = shape.points;\n                    let x2 = 0;\n                    let y2 = 0;\n                    let dx = 0;\n                    let dy = 0;\n                    let rw = 0;\n                    let rh = 0;\n                    let cx = 0;\n                    let cy = 0;\n\n                    for (let j = 0; j + 2 < points.length; j += 2)\n                    {\n                        x = points[j];\n                        y = points[j + 1];\n                        x2 = points[j + 2];\n                        y2 = points[j + 3];\n                        dx = Math.abs(x2 - x);\n                        dy = Math.abs(y2 - y);\n                        h = lineOffset * 2;\n                        w = Math.sqrt((dx * dx) + (dy * dy));\n\n                        if (w < 1e-9)\n                        {\n                            continue;\n                        }\n\n                        rw = ((h / w * dy) + dx) / 2;\n                        rh = ((h / w * dx) + dy) / 2;\n                        cx = (x2 + x) / 2;\n                        cy = (y2 + y) / 2;\n\n                        minX = cx - rw < minX ? cx - rw : minX;\n                        maxX = cx + rw > maxX ? cx + rw : maxX;\n\n                        minY = cy - rh < minY ? cy - rh : minY;\n                        maxY = cy + rh > maxY ? cy + rh : maxY;\n                    }\n                }\n            }\n        }\n        else\n        {\n            minX = 0;\n            maxX = 0;\n            minY = 0;\n            maxY = 0;\n        }\n\n        const padding = this.boundsPadding;\n\n        this._localBounds.minX = minX - padding;\n        this._localBounds.maxX = maxX + padding;\n\n        this._localBounds.minY = minY - padding;\n        this._localBounds.maxY = maxY + padding;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @return {PIXI.GraphicsData} The generated GraphicsData object.\n     */\n    drawShape(shape)\n    {\n        if (this.currentPath)\n        {\n            // check current path!\n            if (this.currentPath.shape.points.length <= 2)\n            {\n                this.graphicsData.pop();\n            }\n        }\n\n        this.currentPath = null;\n\n        const data = new GraphicsData(\n            this.lineWidth,\n            this.lineColor,\n            this.lineAlpha,\n            this.fillColor,\n            this.fillAlpha,\n            this.filling,\n            this.nativeLines,\n            shape,\n            this.lineAlignment\n        );\n\n        this.graphicsData.push(data);\n\n        if (data.type === SHAPES.POLY)\n        {\n            data.shape.closed = data.shape.closed;\n            this.currentPath = data;\n        }\n\n        this.dirty++;\n\n        return data;\n    }\n\n    /**\n     * Generates a canvas texture.\n     *\n     * @param {number} scaleMode - The scale mode of the texture.\n     * @param {number} resolution - The resolution of the texture.\n     * @return {PIXI.Texture} The new texture.\n     */\n    generateCanvasTexture(scaleMode, resolution = 1)\n    {\n        const bounds = this.getLocalBounds();\n\n        const canvasBuffer = RenderTexture.create(bounds.width, bounds.height, scaleMode, resolution);\n\n        if (!canvasRenderer)\n        {\n            canvasRenderer = new CanvasRenderer();\n        }\n\n        this.transform.updateLocalTransform();\n        this.transform.localTransform.copy(tempMatrix);\n\n        tempMatrix.invert();\n\n        tempMatrix.tx -= bounds.x;\n        tempMatrix.ty -= bounds.y;\n\n        canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n\n        const texture = Texture.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode, 'graphics');\n\n        texture.baseTexture.resolution = resolution;\n        texture.baseTexture.update();\n\n        return texture;\n    }\n\n    /**\n     * Closes the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    closePath()\n    {\n        // ok so close path assumes next one is a hole!\n        const currentPath = this.currentPath;\n\n        if (currentPath && currentPath.shape)\n        {\n            currentPath.shape.close();\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a hole in the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    addHole()\n    {\n        // this is a hole!\n        const hole = this.graphicsData.pop();\n\n        this.currentPath = this.graphicsData[this.graphicsData.length - 1];\n\n        this.currentPath.addHole(hole.shape);\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        // for each webgl data entry, destroy the WebGLGraphicsData\n        for (const id in this._webGL)\n        {\n            for (let j = 0; j < this._webGL[id].data.length; ++j)\n            {\n                this._webGL[id].data[j].destroy();\n            }\n        }\n\n        if (this._spriteRect)\n        {\n            this._spriteRect.destroy();\n        }\n\n        this.graphicsData = null;\n\n        this.currentPath = null;\n        this._webGL = null;\n        this._localBounds = null;\n    }\n\n}\n\nGraphics._SPRITE_TEXTURE = null;\n\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI.Graphics\n * @name CURVES\n * @type {object}\n * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nGraphics.CURVES = {\n    adaptive: false,\n    maxLength: 10,\n    minSegments: 8,\n    maxSegments: 2048,\n};\n"],"mappings":";;;AAAA,IAAAA,WAAA,GAAAC,OAAA;;AACA,IAAAC,cAAA,GAAAD,OAAA;;AACA,IAAAE,QAAA,GAAAF,OAAA;;AACA,IAAAG,aAAA,GAAAH,OAAA;;AACA,IAAAI,OAAA,GAAAJ,OAAA;;AACA,IAAAK,KAAA,GAAAL,OAAA;AACA,IAAAM,MAAA,GAAAN,OAAA;AACA,IAAAO,MAAA,GAAAP,OAAA;AACA,IAAAQ,OAAA,GAAAR,OAAA;;AACA,IAAAS,eAAA,GAAAT,OAAA;;AACA,IAAAU,eAAA,GAAAV,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAIW,cAAA,SAAJ;AACA,IAAMC,UAAA,GAAa,IAAAP,KAAA,CAAAQ,MAAA,EAAnB;AACA,IAAMC,SAAA,GAAY,IAAAT,KAAA,CAAAU,KAAA,EAAlB;AACA,IAAMC,UAAA,GAAa,IAAIC,YAAJ,CAAiB,CAAjB,CAAnB;AACA,IAAMC,UAAA,GAAa,IAAID,YAAJ,CAAiB,CAAjB,CAAnB;;AAEA;;;;;;;;;IAQqBE,Q;;;EAEjB;;;;EAIA,SAAAA,SAAA,EACA;IAAA,IADYC,WACZ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAD0B,KAC1B;IAAAG,eAAA,OAAAL,QAAA;;IAGI;;;;;;IAHJ,IAAAM,KAAA,GAAAC,0BAAA,OACIC,UAAA,CAAAC,IAAA,MADJ;IASIH,KAAA,CAAKI,SAAL,GAAiB,CAAjB;;IAEA;;;;;;IAMAJ,KAAA,CAAKK,SAAL,GAAiB,CAAjB;;IAEA;;;;;IAKAL,KAAA,CAAKL,WAAL,GAAmBA,WAAnB;;IAEA;;;;;;IAMAK,KAAA,CAAKM,SAAL,GAAiB,CAAjB;;IAEA;;;;;;IAMAN,KAAA,CAAKO,aAAL,GAAqB,GAArB;;IAEA;;;;;;IAMAP,KAAA,CAAKQ,YAAL,GAAoB,EAApB;;IAEA;;;;;;;IAOAR,KAAA,CAAKS,IAAL,GAAY,QAAZ;;IAEA;;;;;;;;IAQAT,KAAA,CAAKU,SAAL,GAAiB,QAAjB;;IAEA;;;;;;;;IAQAV,KAAA,CAAKW,SAAL,GAAiB7B,MAAA,CAAA8B,WAAA,CAAYC,MAA7B;;IAEA;;;;;;IAMAb,KAAA,CAAKc,WAAL,GAAmB,IAAnB;;IAEA;;;;;;IAMA;IACAd,KAAA,CAAKe,MAAL,GAAc,EAAd;;IAEA;;;;;IAKAf,KAAA,CAAKgB,MAAL,GAAc,KAAd;;IAEA;;;;;IAKAhB,KAAA,CAAKiB,aAAL,GAAqB,CAArB;;IAEA;;;;;;IAMAjB,KAAA,CAAKkB,YAAL,GAAoB,IAAAC,QAAA,CAAAC,OAAA,EAApB;;IAEA;;;;;;;IAOApB,KAAA,CAAKqB,KAAL,GAAa,CAAb;;IAEA;;;;IAIArB,KAAA,CAAKsB,aAAL,GAAqB,CAAC,CAAtB;;IAEA;;;;IAIAtB,KAAA,CAAKuB,UAAL,GAAkB,CAAlB;;IAEA;;;;IAIAvB,KAAA,CAAKwB,WAAL,GAAmB,CAAC,CAApB;;IAEA;;;;;;IAMAxB,KAAA,CAAKyB,iBAAL,GAAyB,KAAzB;IAEAzB,KAAA,CAAK0B,WAAL,GAAmB,IAAnB;IACA1B,KAAA,CAAK2B,SAAL,GAAiB,KAAjB;IAEA3B,KAAA,CAAK4B,aAAL,GAAqB,IAArB;IACA5B,KAAA,CAAK6B,kBAAL,GAA0B,IAA1B;;IAEA;;;;;;;;;;;;IA/JJ,OAAA7B,KAAA;EA2KC;;EAED;;;;;;;qBAMA8B,K,oBACA;IACI,IAAMA,KAAA,GAAQ,IAAIpC,QAAJ,EAAd;IAEAoC,KAAA,CAAMC,UAAN,GAAmB,KAAKA,UAAxB;IACAD,KAAA,CAAM1B,SAAN,GAAkB,KAAKA,SAAvB;IACA0B,KAAA,CAAMzB,SAAN,GAAkB,KAAKA,SAAvB;IACAyB,KAAA,CAAMxB,SAAN,GAAkB,KAAKA,SAAvB;IACAwB,KAAA,CAAMvB,aAAN,GAAsB,KAAKA,aAA3B;IACAuB,KAAA,CAAMrB,IAAN,GAAa,KAAKA,IAAlB;IACAqB,KAAA,CAAMnB,SAAN,GAAkB,KAAKA,SAAvB;IACAmB,KAAA,CAAMd,MAAN,GAAe,KAAKA,MAApB;IACAc,KAAA,CAAMb,aAAN,GAAsB,KAAKA,aAA3B;IACAa,KAAA,CAAMT,KAAN,GAAc,CAAd;IACAS,KAAA,CAAML,iBAAN,GAA0B,KAAKA,iBAA/B;;IAEA;IACA,KAAK,IAAIO,CAAA,GAAI,CAAb,EAAgBA,CAAA,GAAI,KAAKxB,YAAL,CAAkBX,MAAtC,EAA8C,EAAEmC,CAAhD,EACA;MACIF,KAAA,CAAMtB,YAAN,CAAmByB,IAAnB,CAAwB,KAAKzB,YAAL,CAAkBwB,CAAlB,EAAqBF,KAArB,EAAxB;IACH;IAEDA,KAAA,CAAMhB,WAAN,GAAoBgB,KAAA,CAAMtB,YAAN,CAAmBsB,KAAA,CAAMtB,YAAN,CAAmBX,MAAnB,GAA4B,CAA/C,CAApB;IAEAiC,KAAA,CAAMI,iBAAN;IAEA,OAAOJ,KAAP;EACH,C;;EAED;;;;;;;;;;;;;;;qBAcAK,qB,kCAAsBC,K,EAAOC,K,EAAOC,G,EAAKC,G,EAAKC,G,EAAKC,G,EACnD;IACI,IAAMC,EAAA,GAAKN,KAAA,GAAS,MAAME,GAAf,GAAsBE,GAAjC;IACA,IAAMG,EAAA,GAAKN,KAAA,GAAS,MAAME,GAAf,GAAsBE,GAAjC;IACA,IAAMG,EAAA,GAAM,MAAMN,GAAP,GAAe,MAAMF,KAAhC;IACA,IAAMS,EAAA,GAAM,MAAMN,GAAP,GAAe,MAAMF,KAAhC;IACA,IAAMS,CAAA,GAAI,OAAQJ,EAAA,GAAKA,EAAN,GAAaC,EAAA,GAAKA,EAAzB,CAAV;IACA,IAAMI,CAAA,GAAI,OAAQL,EAAA,GAAKE,EAAN,GAAaD,EAAA,GAAKE,EAAzB,CAAV;IACA,IAAMG,CAAA,GAAKJ,EAAA,GAAKA,EAAN,GAAaC,EAAA,GAAKA,EAA5B;IAEA,IAAMI,CAAA,GAAI,MAAMC,IAAA,CAAKC,IAAL,CAAUL,CAAA,GAAIC,CAAJ,GAAQC,CAAlB,CAAhB;IACA,IAAMI,EAAA,GAAKF,IAAA,CAAKC,IAAL,CAAUL,CAAV,CAAX;IACA,IAAMO,GAAA,GAAM,MAAMP,CAAN,GAAUM,EAAtB;IACA,IAAME,EAAA,GAAK,MAAMJ,IAAA,CAAKC,IAAL,CAAUH,CAAV,CAAjB;IACA,IAAMO,EAAA,GAAKR,CAAA,GAAIK,EAAf;IAEA,OAAO,CACEC,GAAA,GAAMJ,CAAP,GACGG,EAAA,GAAKL,CAAL,IAAUE,CAAA,GAAIK,EAAd,CADH,GAGG,CAAE,MAAMN,CAAN,GAAUF,CAAX,GAAiBC,CAAA,GAAIA,CAAtB,IACEG,IAAA,CAAKM,GAAL,CAAS,CAAE,MAAMJ,EAAP,GAAaG,EAAb,GAAkBN,CAAnB,KAAyBM,EAAA,GAAKD,EAA9B,CAAT,CALN,KAQG,MAAMD,GART,CAAP;EASH,C;;EAED;;;;;;;;;;;;;;;;;qBAgBAI,kB,+BAAmBrB,K,EAAOC,K,EAAOC,G,EAAKC,G,EAAKmB,I,EAAMC,I,EAAMnB,G,EAAKC,G,EAC5D;IACI,IAAMmB,CAAA,GAAI,EAAV;IACA,IAAIC,MAAA,GAAS,GAAb;IACA,IAAIC,CAAA,GAAI,GAAR;IACA,IAAIC,EAAA,GAAK,GAAT;IACA,IAAIC,EAAA,GAAK,GAAT;IACA,IAAIC,EAAA,GAAK,GAAT;IACA,IAAIC,GAAA,GAAM,GAAV;IACA,IAAIC,GAAA,GAAM,GAAV;IACA,IAAIC,CAAA,GAAI,GAAR;IACA,IAAIC,CAAA,GAAI,GAAR;IACA,IAAIC,EAAA,GAAK,GAAT;IACA,IAAIC,EAAA,GAAK,GAAT;IACA,IAAIC,KAAA,GAAQpC,KAAZ;IACA,IAAIqC,KAAA,GAAQpC,KAAZ;IAEA,KAAK,IAAIL,CAAA,GAAI,CAAb,EAAgBA,CAAA,IAAK4B,CAArB,EAAwB,EAAE5B,CAA1B,EACA;MACI8B,CAAA,GAAI9B,CAAA,GAAI4B,CAAR;MACAG,EAAA,GAAKD,CAAA,GAAIA,CAAT;MACAE,EAAA,GAAKD,EAAA,GAAKD,CAAV;MACAG,EAAA,GAAM,MAAMH,CAAZ;MACAI,GAAA,GAAMD,EAAA,GAAKA,EAAX;MACAE,GAAA,GAAMD,GAAA,GAAMD,EAAZ;MAEAG,CAAA,GAAKD,GAAA,GAAM/B,KAAP,GAAiB,MAAM8B,GAAN,GAAYJ,CAAZ,GAAgBxB,GAAjC,GAAyC,MAAM2B,EAAN,GAAWF,EAAX,GAAgBL,IAAzD,GAAkEM,EAAA,GAAKxB,GAA3E;MACA6B,CAAA,GAAKF,GAAA,GAAM9B,KAAP,GAAiB,MAAM6B,GAAN,GAAYJ,CAAZ,GAAgBvB,GAAjC,GAAyC,IAAI0B,EAAJ,GAASF,EAAT,GAAcJ,IAAvD,GAAgEK,EAAA,GAAKvB,GAAzE;MACA6B,EAAA,GAAKE,KAAA,GAAQJ,CAAb;MACAG,EAAA,GAAKE,KAAA,GAAQJ,CAAb;MACAG,KAAA,GAAQJ,CAAR;MACAK,KAAA,GAAQJ,CAAR;MAEAR,MAAA,IAAUX,IAAA,CAAKC,IAAL,CAAWmB,EAAA,GAAKA,EAAN,GAAaC,EAAA,GAAKA,EAA5B,CAAV;IACH;IAED,OAAOV,MAAP;EACH,C;;EAED;;;;;;;;qBAOAa,c,2BAAe7E,M,EACf;IACI,IAAIgE,MAAA,GAASX,IAAA,CAAKyB,IAAL,CAAU9E,MAAA,GAASH,QAAA,CAASkF,MAAT,CAAgBC,SAAnC,CAAb;IAEA,IAAIhB,MAAA,GAASnE,QAAA,CAASkF,MAAT,CAAgBE,WAA7B,EACA;MACIjB,MAAA,GAASnE,QAAA,CAASkF,MAAT,CAAgBE,WAAzB;IACH,CAHD,MAIK,IAAIjB,MAAA,GAASnE,QAAA,CAASkF,MAAT,CAAgBG,WAA7B,EACL;MACIlB,MAAA,GAASnE,QAAA,CAASkF,MAAT,CAAgBG,WAAzB;IACH;IAED,OAAOlB,MAAP;EACH,C;;EAED;;;;;;;;;;;qBAUAmB,S,wBACA;IAAA,IADU3E,SACV,GAAAT,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MADsB,CACtB;IAAA,IADyBqF,KACzB,GAAArF,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MADiC,CACjC;IAAA,IADoCsF,KACpC,GAAAtF,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAD4C,CAC5C;IAAA,IAD+CuF,SAC/C,GAAAvF,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAD2D,GAC3D;IACI,KAAKS,SAAL,GAAiBA,SAAjB;IACA,KAAKC,SAAL,GAAiB2E,KAAjB;IACA,KAAKG,SAAL,GAAiBF,KAAjB;IACA,KAAK3E,aAAL,GAAqB4E,SAArB;IAEA,IAAI,KAAKrE,WAAT,EACA;MACI,IAAI,KAAKA,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAvB,CAA8BzF,MAAlC,EACA;QACI;QACA,IAAMwF,KAAA,GAAQ,IAAAzG,KAAA,CAAA2G,OAAA,CAAY,KAAKzE,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAvB,CAA8BE,KAA9B,CAAoC,CAAC,CAArC,CAAZ,CAAd;QAEAH,KAAA,CAAMI,MAAN,GAAe,KAAf;QAEA,KAAKC,SAAL,CAAeL,KAAf;MACH,CARD,MAUA;QACI;QACA,KAAKvE,WAAL,CAAiBT,SAAjB,GAA6B,KAAKA,SAAlC;QACA,KAAKS,WAAL,CAAiBR,SAAjB,GAA6B,KAAKA,SAAlC;QACA,KAAKQ,WAAL,CAAiBsE,SAAjB,GAA6B,KAAKA,SAAlC;QACA,KAAKtE,WAAL,CAAiBP,aAAjB,GAAiC,KAAKA,aAAtC;MACH;IACJ;IAED,OAAO,IAAP;EACH,C;;EAED;;;;;;;;qBAOAoF,M,mBAAOvB,C,EAAGC,C,EACV;IACI,IAAMgB,KAAA,GAAQ,IAAAzG,KAAA,CAAA2G,OAAA,CAAY,CAACnB,CAAD,EAAIC,CAAJ,CAAZ,CAAd;IAEAgB,KAAA,CAAMI,MAAN,GAAe,KAAf;IACA,KAAKC,SAAL,CAAeL,KAAf;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;qBAQAO,M,mBAAOxB,C,EAAGC,C,EACV;IACI,IAAMiB,MAAA,GAAS,KAAKxE,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAtC;IAEA,IAAMlD,KAAA,GAAQkD,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,CAAd;IACA,IAAMwC,KAAA,GAAQiD,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,CAAd;IAEA,IAAIuC,KAAA,KAAUgC,CAAV,IAAe/B,KAAA,KAAUgC,CAA7B,EACA;MACIiB,MAAA,CAAOrD,IAAP,CAAYmC,CAAZ,EAAeC,CAAf;MACA,KAAKhD,KAAL;IACH;IAED,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;;;qBAUAwE,gB,6BAAiBvD,G,EAAKC,G,EAAKC,G,EAAKC,G,EAChC;IACI,IAAI,KAAK3B,WAAT,EACA;MACI,IAAI,KAAKA,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAvB,CAA8BzF,MAA9B,KAAyC,CAA7C,EACA;QACI,KAAKiB,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAvB,GAAgC,CAAC,CAAD,EAAI,CAAJ,CAAhC;MACH;IACJ,CAND,MAQA;MACI,KAAKK,MAAL,CAAY,CAAZ,EAAe,CAAf;IACH;IAED,IAAML,MAAA,GAAS,KAAKxE,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAtC;IACA,IAAIQ,EAAA,GAAK,CAAT;IACA,IAAIC,EAAA,GAAK,CAAT;IAEA,IAAIT,MAAA,CAAOzF,MAAP,KAAkB,CAAtB,EACA;MACI,KAAK8F,MAAL,CAAY,CAAZ,EAAe,CAAf;IACH;IAED,IAAMvD,KAAA,GAAQkD,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,CAAd;IACA,IAAMwC,KAAA,GAAQiD,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,CAAd;IACA,IAAM+D,CAAA,GAAIlE,QAAA,CAASkF,MAAT,CAAgBoB,QAAhB,GACE,KAAKtB,cAAL,CAAoB,KAAKvC,qBAAL,CAA2BC,KAA3B,EAAkCC,KAAlC,EAAyCC,GAAzC,EAA8CC,GAA9C,EAAmDC,GAAnD,EAAwDC,GAAxD,CAApB,CADF,GAEE,EAFZ;IAIA,KAAK,IAAIT,CAAA,GAAI,CAAb,EAAgBA,CAAA,IAAK4B,CAArB,EAAwB,EAAE5B,CAA1B,EACA;MACI,IAAMiE,CAAA,GAAIjE,CAAA,GAAI4B,CAAd;MAEAkC,EAAA,GAAK1D,KAAA,GAAS,CAACE,GAAA,GAAMF,KAAP,IAAgB6D,CAA9B;MACAF,EAAA,GAAK1D,KAAA,GAAS,CAACE,GAAA,GAAMF,KAAP,IAAgB4D,CAA9B;MAEAX,MAAA,CAAOrD,IAAP,CAAY6D,EAAA,GAAM,CAAExD,GAAA,GAAO,CAACE,GAAA,GAAMF,GAAP,IAAc2D,CAAtB,GAA4BH,EAA7B,IAAmCG,CAArD,EACIF,EAAA,GAAM,CAAExD,GAAA,GAAO,CAACE,GAAA,GAAMF,GAAP,IAAc0D,CAAtB,GAA4BF,EAA7B,IAAmCE,CAD7C;IAEH;IAED,KAAK5E,KAAL;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;;;;qBAWA6E,a,0BAAc5D,G,EAAKC,G,EAAKmB,I,EAAMC,I,EAAMnB,G,EAAKC,G,EACzC;IACI,IAAI,KAAK3B,WAAT,EACA;MACI,IAAI,KAAKA,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAvB,CAA8BzF,MAA9B,KAAyC,CAA7C,EACA;QACI,KAAKiB,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAvB,GAAgC,CAAC,CAAD,EAAI,CAAJ,CAAhC;MACH;IACJ,CAND,MAQA;MACI,KAAKK,MAAL,CAAY,CAAZ,EAAe,CAAf;IACH;IAED,IAAML,MAAA,GAAS,KAAKxE,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAtC;IAEA,IAAMlD,KAAA,GAAQkD,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,CAAd;IACA,IAAMwC,KAAA,GAAQiD,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,CAAd;IAEAyF,MAAA,CAAOzF,MAAP,IAAiB,CAAjB;IAEA,IAAM+D,CAAA,GAAIlE,QAAA,CAASkF,MAAT,CAAgBoB,QAAhB,GACE,KAAKtB,cAAL,CAAoB,KAAKjB,kBAAL,CAAwBrB,KAAxB,EAA+BC,KAA/B,EAAsCC,GAAtC,EAA2CC,GAA3C,EAAgDmB,IAAhD,EAAsDC,IAAtD,EAA4DnB,GAA5D,EAAiEC,GAAjE,CAApB,CADF,GAEE,EAFZ;IAIA,IAAA0D,eAAA,CAAA/E,OAAA,EAAcgB,KAAd,EAAqBC,KAArB,EAA4BC,GAA5B,EAAiCC,GAAjC,EAAsCmB,IAAtC,EAA4CC,IAA5C,EAAkDnB,GAAlD,EAAuDC,GAAvD,EAA4DmB,CAA5D,EAA+D0B,MAA/D;IAEA,KAAKjE,KAAL;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;;;;;qBAYA+E,K,kBAAMC,E,EAAIC,E,EAAIC,E,EAAIC,E,EAAIC,M,EACtB;IACI,IAAI,KAAK3F,WAAT,EACA;MACI,IAAI,KAAKA,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAvB,CAA8BzF,MAA9B,KAAyC,CAA7C,EACA;QACI,KAAKiB,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAvB,CAA8BrD,IAA9B,CAAmCoE,EAAnC,EAAuCC,EAAvC;MACH;IACJ,CAND,MAQA;MACI,KAAKX,MAAL,CAAYU,EAAZ,EAAgBC,EAAhB;IACH;IAED,IAAMhB,MAAA,GAAS,KAAKxE,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAtC;IACA,IAAMlD,KAAA,GAAQkD,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,CAAd;IACA,IAAMwC,KAAA,GAAQiD,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,CAAd;IACA,IAAM6G,EAAA,GAAKrE,KAAA,GAAQiE,EAAnB;IACA,IAAMK,EAAA,GAAKvE,KAAA,GAAQiE,EAAnB;IACA,IAAMjD,EAAA,GAAKoD,EAAA,GAAKF,EAAhB;IACA,IAAMM,EAAA,GAAKL,EAAA,GAAKF,EAAhB;IACA,IAAMQ,EAAA,GAAK3D,IAAA,CAAK4D,GAAL,CAAUJ,EAAA,GAAKE,EAAN,GAAaD,EAAA,GAAKvD,EAA3B,CAAX;IAEA,IAAIyD,EAAA,GAAK,MAAL,IAAeJ,MAAA,KAAW,CAA9B,EACA;MACI,IAAInB,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,MAA8BwG,EAA9B,IAAoCf,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,MAA8ByG,EAAtE,EACA;QACIhB,MAAA,CAAOrD,IAAP,CAAYoE,EAAZ,EAAgBC,EAAhB;MACH;IACJ,CAND,MAQA;MACI,IAAMS,EAAA,GAAML,EAAA,GAAKA,EAAN,GAAaC,EAAA,GAAKA,EAA7B;MACA,IAAMK,EAAA,GAAM5D,EAAA,GAAKA,EAAN,GAAawD,EAAA,GAAKA,EAA7B;MACA,IAAMK,EAAA,GAAMP,EAAA,GAAKtD,EAAN,GAAauD,EAAA,GAAKC,EAA7B;MACA,IAAMM,EAAA,GAAKT,MAAA,GAASvD,IAAA,CAAKC,IAAL,CAAU4D,EAAV,CAAT,GAAyBF,EAApC;MACA,IAAMM,EAAA,GAAKV,MAAA,GAASvD,IAAA,CAAKC,IAAL,CAAU6D,EAAV,CAAT,GAAyBH,EAApC;MACA,IAAMO,EAAA,GAAKF,EAAA,GAAKD,EAAL,GAAUF,EAArB;MACA,IAAMM,EAAA,GAAKF,EAAA,GAAKF,EAAL,GAAUD,EAArB;MACA,IAAMM,EAAA,GAAMJ,EAAA,GAAKN,EAAN,GAAaO,EAAA,GAAKR,EAA7B;MACA,IAAMY,EAAA,GAAML,EAAA,GAAK9D,EAAN,GAAa+D,EAAA,GAAKT,EAA7B;MACA,IAAMc,EAAA,GAAKb,EAAA,IAAMQ,EAAA,GAAKC,EAAX,CAAX;MACA,IAAMK,EAAA,GAAKf,EAAA,IAAMS,EAAA,GAAKC,EAAX,CAAX;MACA,IAAMM,EAAA,GAAKd,EAAA,IAAMM,EAAA,GAAKG,EAAX,CAAX;MACA,IAAMM,EAAA,GAAKvE,EAAA,IAAM8D,EAAA,GAAKG,EAAX,CAAX;MACA,IAAMO,UAAA,GAAa1E,IAAA,CAAK2E,KAAL,CAAWJ,EAAA,GAAKF,EAAhB,EAAoBC,EAAA,GAAKF,EAAzB,CAAnB;MACA,IAAMQ,QAAA,GAAW5E,IAAA,CAAK2E,KAAL,CAAWF,EAAA,GAAKJ,EAAhB,EAAoBG,EAAA,GAAKJ,EAAzB,CAAjB;MAEA,KAAKS,GAAL,CAAST,EAAA,GAAKjB,EAAd,EAAkBkB,EAAA,GAAKjB,EAAvB,EAA2BG,MAA3B,EAAmCmB,UAAnC,EAA+CE,QAA/C,EAAyDnB,EAAA,GAAKvD,EAAL,GAAUwD,EAAA,GAAKF,EAAxE;IACH;IAED,KAAKrF,KAAL;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;;;;;;;qBAcA0G,G,gBAAIT,E,EAAIC,E,EAAId,M,EAAQmB,U,EAAYE,Q,EAChC;IAAA,IAD0CE,aAC1C,GAAApI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAD0D,KAC1D;IACI,IAAIgI,UAAA,KAAeE,QAAnB,EACA;MACI,OAAO,IAAP;IACH;IAED,IAAI,CAACE,aAAD,IAAkBF,QAAA,IAAYF,UAAlC,EACA;MACIE,QAAA,IAAAhJ,MAAA,CAAAmJ,IAAA;IACH,CAHD,MAIK,IAAID,aAAA,IAAiBJ,UAAA,IAAcE,QAAnC,EACL;MACIF,UAAA,IAAA9I,MAAA,CAAAmJ,IAAA;IACH;IAED,IAAMC,KAAA,GAAQJ,QAAA,GAAWF,UAAzB;IACA,IAAMO,IAAA,GAAOzI,QAAA,CAASkF,MAAT,CAAgBoB,QAAhB,GACE,KAAKtB,cAAL,CAAoBxB,IAAA,CAAK4D,GAAL,CAASoB,KAAT,IAAkBzB,MAAtC,CADF,GAEEvD,IAAA,CAAKyB,IAAL,CAAUzB,IAAA,CAAK4D,GAAL,CAASoB,KAAT,IAAApJ,MAAA,CAAAmJ,IAAV,IAAoC,EAFnD;IAIA,IAAIC,KAAA,KAAU,CAAd,EACA;MACI,OAAO,IAAP;IACH;IAED,IAAME,MAAA,GAASd,EAAA,GAAMpE,IAAA,CAAKmF,GAAL,CAAST,UAAT,IAAuBnB,MAA5C;IACA,IAAM6B,MAAA,GAASf,EAAA,GAAMrE,IAAA,CAAKqF,GAAL,CAASX,UAAT,IAAuBnB,MAA5C;;IAEA;IACA,IAAInB,MAAA,GAAS,KAAKxE,WAAL,GAAmB,KAAKA,WAAL,CAAiBuE,KAAjB,CAAuBC,MAA1C,GAAmD,IAAhE;IAEA,IAAIA,MAAJ,EACA;MACI;MACA,IAAMkD,KAAA,GAAQtF,IAAA,CAAK4D,GAAL,CAASxB,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,IAA4BuI,MAArC,CAAd;MACA,IAAMK,KAAA,GAAQvF,IAAA,CAAK4D,GAAL,CAASxB,MAAA,CAAOA,MAAA,CAAOzF,MAAP,GAAgB,CAAvB,IAA4ByI,MAArC,CAAd;MAEA,IAAIE,KAAA,GAAQ,KAAR,IAAiBC,KAAA,GAAQ,KAA7B,EACA;QACI;QACA;MAAA,CAHJ,MAMA;QACInD,MAAA,CAAOrD,IAAP,CAAYmG,MAAZ,EAAoBE,MAApB;MACH;IACJ,CAfD,MAiBA;MACI,KAAK3C,MAAL,CAAYyC,MAAZ,EAAoBE,MAApB;MACAhD,MAAA,GAAS,KAAKxE,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAhC;IACH;IAED,IAAMoD,KAAA,GAAQR,KAAA,IAASC,IAAA,GAAO,CAAhB,CAAd;IACA,IAAMQ,MAAA,GAASD,KAAA,GAAQ,CAAvB;IAEA,IAAME,MAAA,GAAS1F,IAAA,CAAKmF,GAAL,CAASK,KAAT,CAAf;IACA,IAAMG,MAAA,GAAS3F,IAAA,CAAKqF,GAAL,CAASG,KAAT,CAAf;IAEA,IAAMI,QAAA,GAAWX,IAAA,GAAO,CAAxB;IAEA,IAAMY,SAAA,GAAaD,QAAA,GAAW,CAAZ,GAAiBA,QAAnC;IAEA,KAAK,IAAI9G,CAAA,GAAI,CAAb,EAAgBA,CAAA,IAAK8G,QAArB,EAA+B,EAAE9G,CAAjC,EACA;MACI,IAAMgH,IAAA,GAAOhH,CAAA,GAAK+G,SAAA,GAAY/G,CAA9B;MAEA,IAAMiH,KAAA,GAAUP,KAAD,GAAUd,UAAV,GAAwBe,MAAA,GAASK,IAAhD;MAEA,IAAMhG,CAAA,GAAIE,IAAA,CAAKmF,GAAL,CAASY,KAAT,CAAV;MACA,IAAMhG,CAAA,GAAI,CAACC,IAAA,CAAKqF,GAAL,CAASU,KAAT,CAAX;MAEA3D,MAAA,CAAOrD,IAAP,CACK,CAAE2G,MAAA,GAAS5F,CAAV,GAAgB6F,MAAA,GAAS5F,CAA1B,IAAgCwD,MAAjC,GAA2Ca,EAD/C,EAEK,CAAEsB,MAAA,GAAS,CAAC3F,CAAX,GAAiB4F,MAAA,GAAS7F,CAA3B,IAAiCyD,MAAlC,GAA4Cc,EAFhD;IAIH;IAED,KAAKlG,KAAL;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;qBAQA6H,S,wBACA;IAAA,IADUjE,KACV,GAAArF,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MADkB,CAClB;IAAA,IADqBsF,KACrB,GAAAtF,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAD6B,CAC7B;IACI,KAAKuJ,OAAL,GAAe,IAAf;IACA,KAAKC,SAAL,GAAiBnE,KAAjB;IACA,KAAK7E,SAAL,GAAiB8E,KAAjB;IAEA,IAAI,KAAKpE,WAAT,EACA;MACI,IAAI,KAAKA,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAvB,CAA8BzF,MAA9B,IAAwC,CAA5C,EACA;QACI,KAAKiB,WAAL,CAAiBuI,IAAjB,GAAwB,KAAKF,OAA7B;QACA,KAAKrI,WAAL,CAAiBsI,SAAjB,GAA6B,KAAKA,SAAlC;QACA,KAAKtI,WAAL,CAAiBV,SAAjB,GAA6B,KAAKA,SAAlC;MACH;IACJ;IAED,OAAO,IAAP;EACH,C;;EAED;;;;;;qBAKAkJ,O,sBACA;IACI,KAAKH,OAAL,GAAe,KAAf;IACA,KAAKC,SAAL,GAAiB,IAAjB;IACA,KAAKhJ,SAAL,GAAiB,CAAjB;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;qBAQAmJ,Q,qBAASnF,C,EAAGC,C,EAAGmF,K,EAAOC,M,EACtB;IACI,KAAK/D,SAAL,CAAe,IAAA9G,KAAA,CAAA8K,SAAA,CAActF,CAAd,EAAiBC,CAAjB,EAAoBmF,KAApB,EAA2BC,MAA3B,CAAf;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;;qBASAE,e,4BAAgBvF,C,EAAGC,C,EAAGmF,K,EAAOC,M,EAAQhD,M,EACrC;IACI,KAAKf,SAAL,CAAe,IAAA9G,KAAA,CAAAgL,gBAAA,CAAqBxF,CAArB,EAAwBC,CAAxB,EAA2BmF,KAA3B,EAAkCC,MAAlC,EAA0ChD,MAA1C,CAAf;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;qBAQAoD,U,uBAAWzF,C,EAAGC,C,EAAGoC,M,EACjB;IACI,KAAKf,SAAL,CAAe,IAAA9G,KAAA,CAAAkL,MAAA,CAAW1F,CAAX,EAAcC,CAAd,EAAiBoC,MAAjB,CAAf;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;;qBASAsD,W,wBAAY3F,C,EAAGC,C,EAAGmF,K,EAAOC,M,EACzB;IACI,KAAK/D,SAAL,CAAe,IAAA9G,KAAA,CAAAoL,OAAA,CAAY5F,CAAZ,EAAeC,CAAf,EAAkBmF,KAAlB,EAAyBC,MAAzB,CAAf;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;qBAMAQ,W,wBAAYC,I,EACZ;IACI;IACA;IACA,IAAI5E,MAAA,GAAS4E,IAAb;IAEA,IAAIzE,MAAA,GAAS,IAAb;IAEA,IAAIH,MAAA,YAAA1G,KAAA,CAAA2G,OAAJ,EACA;MACIE,MAAA,GAASH,MAAA,CAAOG,MAAhB;MACAH,MAAA,GAASA,MAAA,CAAOA,MAAhB;IACH;IAED,IAAI,CAAC6E,KAAA,CAAMC,OAAN,CAAc9E,MAAd,CAAL,EACA;MACI;MACA;MACAA,MAAA,GAAS,IAAI6E,KAAJ,CAAUvK,SAAA,CAAUC,MAApB,CAAT;MAEA,KAAK,IAAImC,CAAA,GAAI,CAAb,EAAgBA,CAAA,GAAIsD,MAAA,CAAOzF,MAA3B,EAAmC,EAAEmC,CAArC,EACA;QACIsD,MAAA,CAAOtD,CAAP,IAAYpC,SAAA,CAAUoC,CAAV,CAAZ,CADJ,CAC8B;MAC7B;IACJ;;IAED,IAAMqD,KAAA,GAAQ,IAAAzG,KAAA,CAAA2G,OAAA,CAAYD,MAAZ,CAAd;IAEAD,KAAA,CAAMI,MAAN,GAAeA,MAAf;IAEA,KAAKC,SAAL,CAAeL,KAAf;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;;;;qBAWAgF,Q,qBAASjG,C,EAAGC,C,EAAGiB,M,EAAQmB,M,EAAQ6D,W,EAC/B;IAAA,IAD4CC,QAC5C,GAAA3K,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MADuD,CACvD;IACI0K,WAAA,GAAcA,WAAA,IAAe7D,MAAA,GAAS,CAAtC;IAEA,IAAMmB,UAAA,GAAc,CAAC,CAAD,GAAK1E,IAAA,CAAKsH,EAAV,GAAe,CAAhB,GAAqBD,QAAxC;IACA,IAAME,GAAA,GAAMnF,MAAA,GAAS,CAArB;IACA,IAAMoF,KAAA,GAAQ5L,MAAA,CAAAmJ,IAAA,GAAOwC,GAArB;IACA,IAAME,OAAA,GAAU,EAAhB;IAEA,KAAK,IAAI3I,CAAA,GAAI,CAAb,EAAgBA,CAAA,GAAIyI,GAApB,EAAyBzI,CAAA,EAAzB,EACA;MACI,IAAM4I,CAAA,GAAI5I,CAAA,GAAI,CAAJ,GAAQsI,WAAR,GAAsB7D,MAAhC;MACA,IAAMwC,KAAA,GAASjH,CAAA,GAAI0I,KAAL,GAAc9C,UAA5B;MAEA+C,OAAA,CAAQ1I,IAAR,CACImC,CAAA,GAAKwG,CAAA,GAAI1H,IAAA,CAAKmF,GAAL,CAASY,KAAT,CADb,EAEI5E,CAAA,GAAKuG,CAAA,GAAI1H,IAAA,CAAKqF,GAAL,CAASU,KAAT,CAFb;IAIH;IAED,OAAO,KAAKgB,WAAL,CAAiBU,OAAjB,CAAP;EACH,C;;EAED;;;;;;qBAKAE,K,oBACA;IACI,IAAI,KAAKxK,SAAL,IAAkB,KAAK8I,OAAvB,IAAkC,KAAK3I,YAAL,CAAkBX,MAAlB,GAA2B,CAAjE,EACA;MACI,KAAKQ,SAAL,GAAiB,CAAjB;MACA,KAAKE,aAAL,GAAqB,GAArB;MAEA,KAAK4I,OAAL,GAAe,KAAf;MAEA,KAAK3H,WAAL,GAAmB,CAAC,CAApB;MACA,KAAKsJ,eAAL,GAAuB,CAAC,CAAxB;MACA,KAAKzJ,KAAL;MACA,KAAKE,UAAL;MACA,KAAKf,YAAL,CAAkBX,MAAlB,GAA2B,CAA3B;IACH;IAED,KAAKiB,WAAL,GAAmB,IAAnB;IACA,KAAKY,WAAL,GAAmB,IAAnB;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;qBAMAqJ,U,yBACA;IACI,OAAO,KAAKvK,YAAL,CAAkBX,MAAlB,KAA6B,CAA7B,IACA,KAAKW,YAAL,CAAkB,CAAlB,EAAqB6E,KAArB,CAA2B2F,IAA3B,KAAoClM,MAAA,CAAAmM,MAAA,CAAOC,IAD3C,IAEA,CAAC,KAAK1K,YAAL,CAAkB,CAAlB,EAAqBH,SAF7B;EAGH,C;;EAED;;;;;;;qBAMA8K,Y,yBAAaC,Q,EACb;IACI;IACA,IAAI,KAAK/J,KAAL,KAAe,KAAKC,aAAxB,EACA;MACI,KAAKA,aAAL,GAAqB,KAAKD,KAA1B;MACA,KAAKM,SAAL,GAAiB,KAAKoJ,UAAL,EAAjB;IACH;;IAED;IACA,IAAI,KAAKpJ,SAAT,EACA;MACI,KAAK0J,iBAAL,CAAuBD,QAAvB;IACH,CAHD,MAKA;MACIA,QAAA,CAASE,iBAAT,CAA2BF,QAAA,CAASG,OAAT,CAAiBC,QAA5C;MACAJ,QAAA,CAASG,OAAT,CAAiBC,QAAjB,CAA0BC,MAA1B,CAAiC,IAAjC;IACH;EACJ,C;;EAED;;;;;;;qBAMAJ,iB,8BAAkBD,Q,EAClB;IACI,IAAMM,IAAA,GAAO,KAAKlL,YAAL,CAAkB,CAAlB,EAAqB6E,KAAlC;IAEA,IAAI,CAAC,KAAK3D,WAAV,EACA;MACI,KAAKA,WAAL,GAAmB,IAAAiK,QAAA,CAAAvK,OAAA,CAAW,IAAAwK,SAAA,CAAAxK,OAAA,CAAYwK,SAAA,CAAAxK,OAAA,CAAQyK,KAApB,CAAX,CAAnB;IACH;IAED,IAAMC,MAAA,GAAS,KAAKpK,WAApB;IACA,IAAM0H,SAAA,GAAY,KAAK5I,YAAL,CAAkB,CAAlB,EAAqB4I,SAAvC;IAEA,IAAI,KAAK3I,IAAL,KAAc,QAAlB,EACA;MACIqL,MAAA,CAAOrL,IAAP,GAAc2I,SAAd;IACH,CAHD,MAIK,IAAI,KAAK3I,IAAL,KAAc,KAAKmB,aAAnB,IAAoCwH,SAAA,KAAc,KAAKvH,kBAA3D,EACL;MACI,IAAMkK,EAAA,GAAKxM,UAAX;MACA,IAAMwE,EAAA,GAAKtE,UAAX;MAEA,IAAAZ,MAAA,CAAAmN,OAAA,EAAQ5C,SAAR,EAAmB2C,EAAnB;MACA,IAAAlN,MAAA,CAAAmN,OAAA,EAAQ,KAAKvL,IAAb,EAAmBsD,EAAnB;MAEAgI,EAAA,CAAG,CAAH,KAAShI,EAAA,CAAG,CAAH,CAAT;MACAgI,EAAA,CAAG,CAAH,KAAShI,EAAA,CAAG,CAAH,CAAT;MACAgI,EAAA,CAAG,CAAH,KAAShI,EAAA,CAAG,CAAH,CAAT;MAEA+H,MAAA,CAAOrL,IAAP,GAAc,IAAA5B,MAAA,CAAAoN,OAAA,EAAQF,EAAR,CAAd;MAEA,KAAKnK,aAAL,GAAqB,KAAKnB,IAA1B;MACA,KAAKoB,kBAAL,GAA0BuH,SAA1B;IACH;IAED0C,MAAA,CAAO5G,KAAP,GAAe,KAAK1E,YAAL,CAAkB,CAAlB,EAAqBJ,SAApC;IACA0L,MAAA,CAAOI,UAAP,GAAoB,KAAKA,UAAL,GAAkBJ,MAAA,CAAO5G,KAA7C;IACA4G,MAAA,CAAOnL,SAAP,GAAmB,KAAKA,SAAxB;IAEAmL,MAAA,CAAOK,QAAP,CAAgBC,MAAhB,CAAuB5C,KAAvB,GAA+BkC,IAAA,CAAKlC,KAApC;IACAsC,MAAA,CAAOK,QAAP,CAAgBC,MAAhB,CAAuB3C,MAAvB,GAAgCiC,IAAA,CAAKjC,MAArC;IAEAqC,MAAA,CAAOO,SAAP,CAAiBC,cAAjB,GAAkC,KAAKD,SAAL,CAAeC,cAAjD;IAEAR,MAAA,CAAOS,MAAP,CAAcC,GAAd,CAAkB,CAACd,IAAA,CAAKtH,CAAN,GAAUsH,IAAA,CAAKlC,KAAjC,EAAwC,CAACkC,IAAA,CAAKrH,CAAN,GAAUqH,IAAA,CAAKjC,MAAvD;IACAqC,MAAA,CAAOW,eAAP;IAEAX,MAAA,CAAOX,YAAP,CAAoBC,QAApB;EACH,C;;EAED;;;;;;;qBAMAsB,a,0BAActB,Q,EACd;IACI,IAAI,KAAKpK,MAAL,KAAgB,IAApB,EACA;MACI;IACH;IAEDoK,QAAA,CAASG,OAAT,CAAiBC,QAAjB,CAA0BC,MAA1B,CAAiC,IAAjC;EACH,C;;EAED;;;;;;qBAKAkB,gB,+BACA;IACI,IAAI,KAAKnL,WAAL,KAAqB,KAAKH,KAA9B,EACA;MACI,KAAKG,WAAL,GAAmB,KAAKH,KAAxB;MACA,KAAKa,iBAAL;MAEA,KAAKT,iBAAL,GAAyB,IAAzB;IACH;IAED,IAAMmL,EAAA,GAAK,KAAK1L,YAAhB;IAEA,KAAK2L,OAAL,CAAaC,QAAb,CAAsB,KAAKT,SAA3B,EAAsCO,EAAA,CAAGG,IAAzC,EAA+CH,EAAA,CAAGI,IAAlD,EAAwDJ,EAAA,CAAGK,IAA3D,EAAiEL,EAAA,CAAGM,IAApE;EACH,C;;EAED;;;;;;;qBAMAC,a,0BAAcC,K,EACd;IACI,KAAKd,cAAL,CAAoBe,YAApB,CAAiCD,KAAjC,EAAwC/N,SAAxC;IAEA,IAAMmB,YAAA,GAAe,KAAKA,YAA1B;IAEA,KAAK,IAAIwB,CAAA,GAAI,CAAb,EAAgBA,CAAA,GAAIxB,YAAA,CAAaX,MAAjC,EAAyC,EAAEmC,CAA3C,EACA;MACI,IAAMsL,IAAA,GAAO9M,YAAA,CAAawB,CAAb,CAAb;MAEA,IAAI,CAACsL,IAAA,CAAKjE,IAAV,EACA;QACI;MACH;;MAED;MACA,IAAIiE,IAAA,CAAKjI,KAAT,EACA;QACI,IAAIiI,IAAA,CAAKjI,KAAL,CAAWkI,QAAX,CAAoBlO,SAAA,CAAU+E,CAA9B,EAAiC/E,SAAA,CAAUgF,CAA3C,CAAJ,EACA;UACI,IAAImJ,OAAA,GAAU,KAAd;UAEA,IAAIF,IAAA,CAAKG,KAAT,EACA;YACI,KAAK,IAAIC,EAAA,GAAI,CAAb,EAAgBA,EAAA,GAAIJ,IAAA,CAAKG,KAAL,CAAW5N,MAA/B,EAAuC6N,EAAA,EAAvC,EACA;cACI,IAAMC,IAAA,GAAOL,IAAA,CAAKG,KAAL,CAAWC,EAAX,CAAb;cAEA,IAAIC,IAAA,CAAKJ,QAAL,CAAclO,SAAA,CAAU+E,CAAxB,EAA2B/E,SAAA,CAAUgF,CAArC,CAAJ,EACA;gBACImJ,OAAA,GAAU,IAAV;gBACA;cACH;YACJ;UACJ;UAED,IAAI,CAACA,OAAL,EACA;YACI,OAAO,IAAP;UACH;QACJ;MACJ;IACJ;IAED,OAAO,KAAP;EACH,C;;EAED;;;;;qBAIAtL,iB,gCACA;IACI,IAAI6K,IAAA,GAAOa,QAAX;IACA,IAAIX,IAAA,GAAO,CAACW,QAAZ;IAEA,IAAIZ,IAAA,GAAOY,QAAX;IACA,IAAIV,IAAA,GAAO,CAACU,QAAZ;IAEA,IAAI,KAAKpN,YAAL,CAAkBX,MAAtB,EACA;MACI,IAAIwF,KAAA,GAAQ,CAAZ;MACA,IAAIjB,CAAA,GAAI,CAAR;MACA,IAAIC,CAAA,GAAI,CAAR;MACA,IAAIwJ,CAAA,GAAI,CAAR;MACA,IAAIC,CAAA,GAAI,CAAR;MAEA,KAAK,IAAI9L,CAAA,GAAI,CAAb,EAAgBA,CAAA,GAAI,KAAKxB,YAAL,CAAkBX,MAAtC,EAA8CmC,CAAA,EAA9C,EACA;QACI,IAAMsL,IAAA,GAAO,KAAK9M,YAAL,CAAkBwB,CAAlB,CAAb;QACA,IAAMgJ,IAAA,GAAOsC,IAAA,CAAKtC,IAAlB;QACA,IAAM3K,SAAA,GAAYiN,IAAA,CAAKjN,SAAvB;QACA,IAAME,aAAA,GAAgB+M,IAAA,CAAK/M,aAA3B;QAEA,IAAMwN,UAAA,GAAa1N,SAAA,GAAYE,aAA/B;QAEA8E,KAAA,GAAQiI,IAAA,CAAKjI,KAAb;QAEA,IAAI2F,IAAA,KAASlM,MAAA,CAAAmM,MAAA,CAAOC,IAAhB,IAAwBF,IAAA,KAASlM,MAAA,CAAAmM,MAAA,CAAO+C,IAA5C,EACA;UACI5J,CAAA,GAAIiB,KAAA,CAAMjB,CAAN,GAAU2J,UAAd;UACA1J,CAAA,GAAIgB,KAAA,CAAMhB,CAAN,GAAU0J,UAAd;UACAF,CAAA,GAAIxI,KAAA,CAAMmE,KAAN,GAAeuE,UAAA,GAAa,CAAhC;UACAD,CAAA,GAAIzI,KAAA,CAAMoE,MAAN,GAAgBsE,UAAA,GAAa,CAAjC;UAEAhB,IAAA,GAAO3I,CAAA,GAAI2I,IAAJ,GAAW3I,CAAX,GAAe2I,IAAtB;UACAE,IAAA,GAAO7I,CAAA,GAAIyJ,CAAJ,GAAQZ,IAAR,GAAe7I,CAAA,GAAIyJ,CAAnB,GAAuBZ,IAA9B;UAEAD,IAAA,GAAO3I,CAAA,GAAI2I,IAAJ,GAAW3I,CAAX,GAAe2I,IAAtB;UACAE,IAAA,GAAO7I,CAAA,GAAIyJ,CAAJ,GAAQZ,IAAR,GAAe7I,CAAA,GAAIyJ,CAAnB,GAAuBZ,IAA9B;QACH,CAZD,MAaK,IAAIlC,IAAA,KAASlM,MAAA,CAAAmM,MAAA,CAAOgD,IAApB,EACL;UACI7J,CAAA,GAAIiB,KAAA,CAAMjB,CAAV;UACAC,CAAA,GAAIgB,KAAA,CAAMhB,CAAV;UACAwJ,CAAA,GAAIxI,KAAA,CAAMoB,MAAN,GAAesH,UAAnB;UACAD,CAAA,GAAIzI,KAAA,CAAMoB,MAAN,GAAesH,UAAnB;UAEAhB,IAAA,GAAO3I,CAAA,GAAIyJ,CAAJ,GAAQd,IAAR,GAAe3I,CAAA,GAAIyJ,CAAnB,GAAuBd,IAA9B;UACAE,IAAA,GAAO7I,CAAA,GAAIyJ,CAAJ,GAAQZ,IAAR,GAAe7I,CAAA,GAAIyJ,CAAnB,GAAuBZ,IAA9B;UAEAD,IAAA,GAAO3I,CAAA,GAAIyJ,CAAJ,GAAQd,IAAR,GAAe3I,CAAA,GAAIyJ,CAAnB,GAAuBd,IAA9B;UACAE,IAAA,GAAO7I,CAAA,GAAIyJ,CAAJ,GAAQZ,IAAR,GAAe7I,CAAA,GAAIyJ,CAAnB,GAAuBZ,IAA9B;QACH,CAZI,MAaA,IAAIlC,IAAA,KAASlM,MAAA,CAAAmM,MAAA,CAAOiD,IAApB,EACL;UACI9J,CAAA,GAAIiB,KAAA,CAAMjB,CAAV;UACAC,CAAA,GAAIgB,KAAA,CAAMhB,CAAV;UACAwJ,CAAA,GAAIxI,KAAA,CAAMmE,KAAN,GAAcuE,UAAlB;UACAD,CAAA,GAAIzI,KAAA,CAAMoE,MAAN,GAAesE,UAAnB;UAEAhB,IAAA,GAAO3I,CAAA,GAAIyJ,CAAJ,GAAQd,IAAR,GAAe3I,CAAA,GAAIyJ,CAAnB,GAAuBd,IAA9B;UACAE,IAAA,GAAO7I,CAAA,GAAIyJ,CAAJ,GAAQZ,IAAR,GAAe7I,CAAA,GAAIyJ,CAAnB,GAAuBZ,IAA9B;UAEAD,IAAA,GAAO3I,CAAA,GAAIyJ,CAAJ,GAAQd,IAAR,GAAe3I,CAAA,GAAIyJ,CAAnB,GAAuBd,IAA9B;UACAE,IAAA,GAAO7I,CAAA,GAAIyJ,CAAJ,GAAQZ,IAAR,GAAe7I,CAAA,GAAIyJ,CAAnB,GAAuBZ,IAA9B;QACH,CAZI,MAcL;UACI;UACA,IAAM5H,MAAA,GAASD,KAAA,CAAMC,MAArB;UACA,IAAIiB,EAAA,GAAK,CAAT;UACA,IAAIC,EAAA,GAAK,CAAT;UACA,IAAIlC,EAAA,GAAK,CAAT;UACA,IAAIC,EAAA,GAAK,CAAT;UACA,IAAI4J,EAAA,GAAK,CAAT;UACA,IAAIC,EAAA,GAAK,CAAT;UACA,IAAI9G,EAAA,GAAK,CAAT;UACA,IAAIC,EAAA,GAAK,CAAT;UAEA,KAAK,IAAItB,CAAA,GAAI,CAAb,EAAgBA,CAAA,GAAI,CAAJ,GAAQX,MAAA,CAAOzF,MAA/B,EAAuCoG,CAAA,IAAK,CAA5C,EACA;YACI7B,CAAA,GAAIkB,MAAA,CAAOW,CAAP,CAAJ;YACA5B,CAAA,GAAIiB,MAAA,CAAOW,CAAA,GAAI,CAAX,CAAJ;YACAM,EAAA,GAAKjB,MAAA,CAAOW,CAAA,GAAI,CAAX,CAAL;YACAO,EAAA,GAAKlB,MAAA,CAAOW,CAAA,GAAI,CAAX,CAAL;YACA3B,EAAA,GAAKpB,IAAA,CAAK4D,GAAL,CAASP,EAAA,GAAKnC,CAAd,CAAL;YACAG,EAAA,GAAKrB,IAAA,CAAK4D,GAAL,CAASN,EAAA,GAAKnC,CAAd,CAAL;YACAyJ,CAAA,GAAIC,UAAA,GAAa,CAAjB;YACAF,CAAA,GAAI3K,IAAA,CAAKC,IAAL,CAAWmB,EAAA,GAAKA,EAAN,GAAaC,EAAA,GAAKA,EAA5B,CAAJ;YAEA,IAAIsJ,CAAA,GAAI,IAAR,EACA;cACI;YACH;YAEDM,EAAA,GAAK,CAAEL,CAAA,GAAID,CAAJ,GAAQtJ,EAAT,GAAeD,EAAhB,IAAsB,CAA3B;YACA8J,EAAA,GAAK,CAAEN,CAAA,GAAID,CAAJ,GAAQvJ,EAAT,GAAeC,EAAhB,IAAsB,CAA3B;YACA+C,EAAA,GAAK,CAACf,EAAA,GAAKnC,CAAN,IAAW,CAAhB;YACAmD,EAAA,GAAK,CAACf,EAAA,GAAKnC,CAAN,IAAW,CAAhB;YAEA0I,IAAA,GAAOzF,EAAA,GAAK6G,EAAL,GAAUpB,IAAV,GAAiBzF,EAAA,GAAK6G,EAAtB,GAA2BpB,IAAlC;YACAE,IAAA,GAAO3F,EAAA,GAAK6G,EAAL,GAAUlB,IAAV,GAAiB3F,EAAA,GAAK6G,EAAtB,GAA2BlB,IAAlC;YAEAD,IAAA,GAAOzF,EAAA,GAAK6G,EAAL,GAAUpB,IAAV,GAAiBzF,EAAA,GAAK6G,EAAtB,GAA2BpB,IAAlC;YACAE,IAAA,GAAO3F,EAAA,GAAK6G,EAAL,GAAUlB,IAAV,GAAiB3F,EAAA,GAAK6G,EAAtB,GAA2BlB,IAAlC;UACH;QACJ;MACJ;IACJ,CApGD,MAsGA;MACIH,IAAA,GAAO,CAAP;MACAE,IAAA,GAAO,CAAP;MACAD,IAAA,GAAO,CAAP;MACAE,IAAA,GAAO,CAAP;IACH;IAED,IAAMmB,OAAA,GAAU,KAAKpN,aAArB;IAEA,KAAKC,YAAL,CAAkB6L,IAAlB,GAAyBA,IAAA,GAAOsB,OAAhC;IACA,KAAKnN,YAAL,CAAkB+L,IAAlB,GAAyBA,IAAA,GAAOoB,OAAhC;IAEA,KAAKnN,YAAL,CAAkB8L,IAAlB,GAAyBA,IAAA,GAAOqB,OAAhC;IACA,KAAKnN,YAAL,CAAkBgM,IAAlB,GAAyBA,IAAA,GAAOmB,OAAhC;EACH,C;;EAED;;;;;;;qBAMA3I,S,sBAAUL,K,EACV;IACI,IAAI,KAAKvE,WAAT,EACA;MACI;MACA,IAAI,KAAKA,WAAL,CAAiBuE,KAAjB,CAAuBC,MAAvB,CAA8BzF,MAA9B,IAAwC,CAA5C,EACA;QACI,KAAKW,YAAL,CAAkB8N,GAAlB;MACH;IACJ;IAED,KAAKxN,WAAL,GAAmB,IAAnB;IAEA,IAAMwM,IAAA,GAAO,IAAAiB,cAAA,CAAAnN,OAAA,CACT,KAAKf,SADI,EAET,KAAKC,SAFI,EAGT,KAAK8E,SAHI,EAIT,KAAKgE,SAJI,EAKT,KAAKhJ,SALI,EAMT,KAAK+I,OANI,EAOT,KAAKxJ,WAPI,EAQT0F,KARS,EAST,KAAK9E,aATI,CAAb;IAYA,KAAKC,YAAL,CAAkByB,IAAlB,CAAuBqL,IAAvB;IAEA,IAAIA,IAAA,CAAKtC,IAAL,KAAclM,MAAA,CAAAmM,MAAA,CAAOuD,IAAzB,EACA;MACIlB,IAAA,CAAKjI,KAAL,CAAWI,MAAX,GAAoB6H,IAAA,CAAKjI,KAAL,CAAWI,MAA/B;MACA,KAAK3E,WAAL,GAAmBwM,IAAnB;IACH;IAED,KAAKjM,KAAL;IAEA,OAAOiM,IAAP;EACH,C;;EAED;;;;;;;;qBAOAmB,qB,kCAAsBC,S,EACtB;IAAA,IADiCC,UACjC,GAAA/O,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAD8C,CAC9C;IACI,IAAMgP,MAAA,GAAS,KAAKC,cAAL,EAAf;IAEA,IAAMC,YAAA,GAAeC,eAAA,CAAA3N,OAAA,CAAc4N,MAAd,CAAqBJ,MAAA,CAAOpF,KAA5B,EAAmCoF,MAAA,CAAOnF,MAA1C,EAAkDiF,SAAlD,EAA6DC,UAA7D,CAArB;IAEA,IAAI,CAACzP,cAAL,EACA;MACIA,cAAA,GAAiB,IAAA+P,gBAAA,CAAA7N,OAAA,EAAjB;IACH;IAED,KAAKiL,SAAL,CAAe6C,oBAAf;IACA,KAAK7C,SAAL,CAAe8C,cAAf,CAA8BC,IAA9B,CAAmCjQ,UAAnC;IAEAA,UAAA,CAAWkQ,MAAX;IAEAlQ,UAAA,CAAWmQ,EAAX,IAAiBV,MAAA,CAAOxK,CAAxB;IACAjF,UAAA,CAAWoQ,EAAX,IAAiBX,MAAA,CAAOvK,CAAxB;IAEAnF,cAAA,CAAeuM,MAAf,CAAsB,IAAtB,EAA4BqD,YAA5B,EAA0C,IAA1C,EAAgD3P,UAAhD;IAEA,IAAMqQ,OAAA,GAAU5D,SAAA,CAAAxK,OAAA,CAAQqO,UAAR,CAAmBX,YAAA,CAAaY,WAAb,CAAyBC,mBAAzB,CAA6CC,MAAhE,EAAwElB,SAAxE,EAAmF,UAAnF,CAAhB;IAEAc,OAAA,CAAQE,WAAR,CAAoBf,UAApB,GAAiCA,UAAjC;IACAa,OAAA,CAAQE,WAAR,CAAoBG,MAApB;IAEA,OAAOL,OAAP;EACH,C;;EAED;;;;;;qBAKAM,S,wBACA;IACI;IACA,IAAMhP,WAAA,GAAc,KAAKA,WAAzB;IAEA,IAAIA,WAAA,IAAeA,WAAA,CAAYuE,KAA/B,EACA;MACIvE,WAAA,CAAYuE,KAAZ,CAAkB0K,KAAlB;IACH;IAED,OAAO,IAAP;EACH,C;;EAED;;;;;;qBAKAC,O,sBACA;IACI;IACA,IAAMrC,IAAA,GAAO,KAAKnN,YAAL,CAAkB8N,GAAlB,EAAb;IAEA,KAAKxN,WAAL,GAAmB,KAAKN,YAAL,CAAkB,KAAKA,YAAL,CAAkBX,MAAlB,GAA2B,CAA7C,CAAnB;IAEA,KAAKiB,WAAL,CAAiBkP,OAAjB,CAAyBrC,IAAA,CAAKtI,KAA9B;IACA,KAAKvE,WAAL,GAAmB,IAAnB;IAEA,OAAO,IAAP;EACH,C;;EAED;;;;;;;;;;;;;qBAYAmP,O,oBAAQC,O,EACR;IACIhQ,UAAA,CAAAiQ,SAAA,CAAMF,OAAN,CAAA9P,IAAA,OAAc+P,OAAd;;IAEA;IACA,KAAK,IAAIlO,CAAA,GAAI,CAAb,EAAgBA,CAAA,GAAI,KAAKxB,YAAL,CAAkBX,MAAtC,EAA8C,EAAEmC,CAAhD,EACA;MACI,KAAKxB,YAAL,CAAkBwB,CAAlB,EAAqBiO,OAArB;IACH;;IAED;IACA,KAAK,IAAMG,EAAX,IAAiB,KAAKrP,MAAtB,EACA;MACI,KAAK,IAAIkF,CAAA,GAAI,CAAb,EAAgBA,CAAA,GAAI,KAAKlF,MAAL,CAAYqP,EAAZ,EAAgB9C,IAAhB,CAAqBzN,MAAzC,EAAiD,EAAEoG,CAAnD,EACA;QACI,KAAKlF,MAAL,CAAYqP,EAAZ,EAAgB9C,IAAhB,CAAqBrH,CAArB,EAAwBgK,OAAxB;MACH;IACJ;IAED,IAAI,KAAKvO,WAAT,EACA;MACI,KAAKA,WAAL,CAAiBuO,OAAjB;IACH;IAED,KAAKzP,YAAL,GAAoB,IAApB;IAEA,KAAKM,WAAL,GAAmB,IAAnB;IACA,KAAKC,MAAL,GAAc,IAAd;IACA,KAAKG,YAAL,GAAoB,IAApB;EACH,C;;;kBA50CgBxB,Q;AAg1CrBA,QAAA,CAAS2Q,eAAT,GAA2B,IAA3B;;AAEA;;;;;;;;;;;;;;;AAeA3Q,QAAA,CAASkF,MAAT,GAAkB;EACdoB,QAAA,EAAU,KADI;EAEdnB,SAAA,EAAW,EAFG;EAGdC,WAAA,EAAa,CAHC;EAIdC,WAAA,EAAa;AAJC,CAAlB"},"metadata":{},"sourceType":"script","externalDependencies":[]}