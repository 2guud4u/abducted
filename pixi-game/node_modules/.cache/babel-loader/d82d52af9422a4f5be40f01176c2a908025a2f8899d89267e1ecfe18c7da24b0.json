{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _core = require('../../core');\nvar core = _interopRequireWildcard(_core);\nvar _ParticleShader = require('./ParticleShader');\nvar _ParticleShader2 = _interopRequireDefault(_ParticleShader);\nvar _ParticleBuffer = require('./ParticleBuffer');\nvar _ParticleBuffer2 = _interopRequireDefault(_ParticleBuffer);\nvar _utils = require('../../core/utils');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n */\nvar ParticleRenderer = function (_core$ObjectRenderer) {\n  _inherits(ParticleRenderer, _core$ObjectRenderer);\n\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n   */\n  function ParticleRenderer(renderer) {\n    _classCallCheck(this, ParticleRenderer);\n\n    // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n    // so max number of particles is 65536 / 4 = 16384\n    // and max number of element in the index buffer is 16384 * 6 = 98304\n    // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n    // let numIndices = 98304;\n\n    /**\n     * The default shader that is used if a sprite doesn't have a more specific one.\n     *\n     * @member {PIXI.Shader}\n     */\n    var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));\n    _this.shader = null;\n    _this.indexBuffer = null;\n    _this.properties = null;\n    _this.tempMatrix = new core.Matrix();\n    _this.CONTEXT_UID = 0;\n    return _this;\n  }\n\n  /**\n   * When there is a WebGL context change\n   *\n   * @private\n   */\n\n  ParticleRenderer.prototype.onContextChange = function onContextChange() {\n    var gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n    // setup default shader\n    this.shader = new _ParticleShader2.default(gl);\n    this.properties = [\n    // verticesData\n    {\n      attribute: this.shader.attributes.aVertexPosition,\n      size: 2,\n      uploadFunction: this.uploadVertices,\n      offset: 0\n    },\n    // positionData\n    {\n      attribute: this.shader.attributes.aPositionCoord,\n      size: 2,\n      uploadFunction: this.uploadPosition,\n      offset: 0\n    },\n    // rotationData\n    {\n      attribute: this.shader.attributes.aRotation,\n      size: 1,\n      uploadFunction: this.uploadRotation,\n      offset: 0\n    },\n    // uvsData\n    {\n      attribute: this.shader.attributes.aTextureCoord,\n      size: 2,\n      uploadFunction: this.uploadUvs,\n      offset: 0\n    },\n    // tintData\n    {\n      attribute: this.shader.attributes.aColor,\n      size: 1,\n      unsignedByte: true,\n      uploadFunction: this.uploadTint,\n      offset: 0\n    }];\n  };\n\n  /**\n   * Starts a new particle batch.\n   *\n   */\n\n  ParticleRenderer.prototype.start = function start() {\n    this.renderer.bindShader(this.shader);\n  };\n\n  /**\n   * Renders the particle container object.\n   *\n   * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n   */\n\n  ParticleRenderer.prototype.render = function render(container) {\n    var children = container.children;\n    var maxSize = container._maxSize;\n    var batchSize = container._batchSize;\n    var renderer = this.renderer;\n    var totalChildren = children.length;\n    if (totalChildren === 0) {\n      return;\n    } else if (totalChildren > maxSize) {\n      totalChildren = maxSize;\n    }\n    var buffers = container._glBuffers[renderer.CONTEXT_UID];\n    if (!buffers) {\n      buffers = container._glBuffers[renderer.CONTEXT_UID] = this.generateBuffers(container);\n    }\n    var baseTexture = children[0]._texture.baseTexture;\n\n    // if the uvs have not updated then no point rendering just yet!\n    this.renderer.setBlendMode(core.utils.correctBlendMode(container.blendMode, baseTexture.premultipliedAlpha));\n    var gl = renderer.gl;\n    var m = container.worldTransform.copy(this.tempMatrix);\n    m.prepend(renderer._activeRenderTarget.projectionMatrix);\n    this.shader.uniforms.projectionMatrix = m.toArray(true);\n    this.shader.uniforms.uColor = core.utils.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultipliedAlpha);\n\n    // make sure the texture is bound..\n    this.shader.uniforms.uSampler = renderer.bindTexture(baseTexture);\n    var updateStatic = false;\n\n    // now lets upload and render the buffers..\n    for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {\n      var amount = totalChildren - i;\n      if (amount > batchSize) {\n        amount = batchSize;\n      }\n      if (j >= buffers.length) {\n        if (!container.autoResize) {\n          break;\n        }\n        buffers.push(this._generateOneMoreBuffer(container));\n      }\n      var buffer = buffers[j];\n\n      // we always upload the dynamic\n      buffer.uploadDynamic(children, i, amount);\n      var bid = container._bufferUpdateIDs[j] || 0;\n      updateStatic = updateStatic || buffer._updateID < bid;\n      // we only upload the static content when we have to!\n      if (updateStatic) {\n        buffer._updateID = container._updateID;\n        buffer.uploadStatic(children, i, amount);\n      }\n\n      // bind the buffer\n      renderer.bindVao(buffer.vao);\n      buffer.vao.draw(gl.TRIANGLES, amount * 6);\n    }\n  };\n\n  /**\n   * Creates one particle buffer for each child in the container we want to render and updates internal properties\n   *\n   * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n   * @return {PIXI.ParticleBuffer[]} The buffers\n   */\n\n  ParticleRenderer.prototype.generateBuffers = function generateBuffers(container) {\n    var gl = this.renderer.gl;\n    var buffers = [];\n    var size = container._maxSize;\n    var batchSize = container._batchSize;\n    var dynamicPropertyFlags = container._properties;\n    for (var i = 0; i < size; i += batchSize) {\n      buffers.push(new _ParticleBuffer2.default(gl, this.properties, dynamicPropertyFlags, batchSize));\n    }\n    return buffers;\n  };\n\n  /**\n   * Creates one more particle buffer, because container has autoResize feature\n   *\n   * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n   * @return {PIXI.ParticleBuffer} generated buffer\n   * @private\n   */\n\n  ParticleRenderer.prototype._generateOneMoreBuffer = function _generateOneMoreBuffer(container) {\n    var gl = this.renderer.gl;\n    var batchSize = container._batchSize;\n    var dynamicPropertyFlags = container._properties;\n    return new _ParticleBuffer2.default(gl, this.properties, dynamicPropertyFlags, batchSize);\n  };\n\n  /**\n   * Uploads the verticies.\n   *\n   * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n   * @param {number} startIndex - the index to start from in the children array\n   * @param {number} amount - the amount of children that will have their vertices uploaded\n   * @param {number[]} array - The vertices to upload.\n   * @param {number} stride - Stride to use for iteration.\n   * @param {number} offset - Offset to start at.\n   */\n\n  ParticleRenderer.prototype.uploadVertices = function uploadVertices(children, startIndex, amount, array, stride, offset) {\n    var w0 = 0;\n    var w1 = 0;\n    var h0 = 0;\n    var h1 = 0;\n    for (var i = 0; i < amount; ++i) {\n      var sprite = children[startIndex + i];\n      var texture = sprite._texture;\n      var sx = sprite.scale.x;\n      var sy = sprite.scale.y;\n      var trim = texture.trim;\n      var orig = texture.orig;\n      if (trim) {\n        // if the sprite is trimmed and is not a tilingsprite then we need to add the\n        // extra space before transforming the sprite coords..\n        w1 = trim.x - sprite.anchor.x * orig.width;\n        w0 = w1 + trim.width;\n        h1 = trim.y - sprite.anchor.y * orig.height;\n        h0 = h1 + trim.height;\n      } else {\n        w0 = orig.width * (1 - sprite.anchor.x);\n        w1 = orig.width * -sprite.anchor.x;\n        h0 = orig.height * (1 - sprite.anchor.y);\n        h1 = orig.height * -sprite.anchor.y;\n      }\n      array[offset] = w1 * sx;\n      array[offset + 1] = h1 * sy;\n      array[offset + stride] = w0 * sx;\n      array[offset + stride + 1] = h1 * sy;\n      array[offset + stride * 2] = w0 * sx;\n      array[offset + stride * 2 + 1] = h0 * sy;\n      array[offset + stride * 3] = w1 * sx;\n      array[offset + stride * 3 + 1] = h0 * sy;\n      offset += stride * 4;\n    }\n  };\n\n  /**\n   *\n   * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n   * @param {number} startIndex - the index to start from in the children array\n   * @param {number} amount - the amount of children that will have their positions uploaded\n   * @param {number[]} array - The vertices to upload.\n   * @param {number} stride - Stride to use for iteration.\n   * @param {number} offset - Offset to start at.\n   */\n\n  ParticleRenderer.prototype.uploadPosition = function uploadPosition(children, startIndex, amount, array, stride, offset) {\n    for (var i = 0; i < amount; i++) {\n      var spritePosition = children[startIndex + i].position;\n      array[offset] = spritePosition.x;\n      array[offset + 1] = spritePosition.y;\n      array[offset + stride] = spritePosition.x;\n      array[offset + stride + 1] = spritePosition.y;\n      array[offset + stride * 2] = spritePosition.x;\n      array[offset + stride * 2 + 1] = spritePosition.y;\n      array[offset + stride * 3] = spritePosition.x;\n      array[offset + stride * 3 + 1] = spritePosition.y;\n      offset += stride * 4;\n    }\n  };\n\n  /**\n   *\n   * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n   * @param {number} startIndex - the index to start from in the children array\n   * @param {number} amount - the amount of children that will have their rotation uploaded\n   * @param {number[]} array - The vertices to upload.\n   * @param {number} stride - Stride to use for iteration.\n   * @param {number} offset - Offset to start at.\n   */\n\n  ParticleRenderer.prototype.uploadRotation = function uploadRotation(children, startIndex, amount, array, stride, offset) {\n    for (var i = 0; i < amount; i++) {\n      var spriteRotation = children[startIndex + i].rotation;\n      array[offset] = spriteRotation;\n      array[offset + stride] = spriteRotation;\n      array[offset + stride * 2] = spriteRotation;\n      array[offset + stride * 3] = spriteRotation;\n      offset += stride * 4;\n    }\n  };\n\n  /**\n   *\n   * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n   * @param {number} startIndex - the index to start from in the children array\n   * @param {number} amount - the amount of children that will have their rotation uploaded\n   * @param {number[]} array - The vertices to upload.\n   * @param {number} stride - Stride to use for iteration.\n   * @param {number} offset - Offset to start at.\n   */\n\n  ParticleRenderer.prototype.uploadUvs = function uploadUvs(children, startIndex, amount, array, stride, offset) {\n    for (var i = 0; i < amount; ++i) {\n      var textureUvs = children[startIndex + i]._texture._uvs;\n      if (textureUvs) {\n        array[offset] = textureUvs.x0;\n        array[offset + 1] = textureUvs.y0;\n        array[offset + stride] = textureUvs.x1;\n        array[offset + stride + 1] = textureUvs.y1;\n        array[offset + stride * 2] = textureUvs.x2;\n        array[offset + stride * 2 + 1] = textureUvs.y2;\n        array[offset + stride * 3] = textureUvs.x3;\n        array[offset + stride * 3 + 1] = textureUvs.y3;\n        offset += stride * 4;\n      } else {\n        // TODO you know this can be easier!\n        array[offset] = 0;\n        array[offset + 1] = 0;\n        array[offset + stride] = 0;\n        array[offset + stride + 1] = 0;\n        array[offset + stride * 2] = 0;\n        array[offset + stride * 2 + 1] = 0;\n        array[offset + stride * 3] = 0;\n        array[offset + stride * 3 + 1] = 0;\n        offset += stride * 4;\n      }\n    }\n  };\n\n  /**\n   *\n   * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n   * @param {number} startIndex - the index to start from in the children array\n   * @param {number} amount - the amount of children that will have their rotation uploaded\n   * @param {number[]} array - The vertices to upload.\n   * @param {number} stride - Stride to use for iteration.\n   * @param {number} offset - Offset to start at.\n   */\n\n  ParticleRenderer.prototype.uploadTint = function uploadTint(children, startIndex, amount, array, stride, offset) {\n    for (var i = 0; i < amount; ++i) {\n      var sprite = children[startIndex + i];\n      var premultiplied = sprite._texture.baseTexture.premultipliedAlpha;\n      var alpha = sprite.alpha;\n      // we dont call extra function if alpha is 1.0, that's faster\n      var argb = alpha < 1.0 && premultiplied ? (0, _utils.premultiplyTint)(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);\n      array[offset] = argb;\n      array[offset + stride] = argb;\n      array[offset + stride * 2] = argb;\n      array[offset + stride * 3] = argb;\n      offset += stride * 4;\n    }\n  };\n\n  /**\n   * Destroys the ParticleRenderer.\n   *\n   */\n\n  ParticleRenderer.prototype.destroy = function destroy() {\n    if (this.renderer.gl) {\n      this.renderer.gl.deleteBuffer(this.indexBuffer);\n    }\n    _core$ObjectRenderer.prototype.destroy.call(this);\n    this.shader.destroy();\n    this.indices = null;\n    this.tempMatrix = null;\n  };\n  return ParticleRenderer;\n}(core.ObjectRenderer);\nexports.default = ParticleRenderer;\ncore.WebGLRenderer.registerPlugin('particle', ParticleRenderer);","map":{"version":3,"names":["_core","require","core","_ParticleShader","_ParticleBuffer","_utils","ParticleRenderer","renderer","_classCallCheck","_this","_possibleConstructorReturn","_core$ObjectRenderer","call","shader","indexBuffer","properties","tempMatrix","Matrix","CONTEXT_UID","onContextChange","gl","_ParticleShader2","default","attribute","attributes","aVertexPosition","size","uploadFunction","uploadVertices","offset","aPositionCoord","uploadPosition","aRotation","uploadRotation","aTextureCoord","uploadUvs","aColor","unsignedByte","uploadTint","start","bindShader","render","container","children","maxSize","_maxSize","batchSize","_batchSize","totalChildren","length","buffers","_glBuffers","generateBuffers","baseTexture","_texture","setBlendMode","utils","correctBlendMode","blendMode","premultipliedAlpha","m","worldTransform","copy","prepend","_activeRenderTarget","projectionMatrix","uniforms","toArray","uColor","premultiplyRgba","tintRgb","worldAlpha","uSampler","bindTexture","updateStatic","i","j","amount","autoResize","push","_generateOneMoreBuffer","buffer","uploadDynamic","bid","_bufferUpdateIDs","_updateID","uploadStatic","bindVao","vao","draw","TRIANGLES","dynamicPropertyFlags","_properties","_ParticleBuffer2","startIndex","array","stride","w0","w1","h0","h1","sprite","texture","sx","scale","x","sy","y","trim","orig","anchor","width","height","spritePosition","position","spriteRotation","rotation","textureUvs","_uvs","x0","y0","x1","y1","x2","y2","x3","y3","premultiplied","alpha","argb","premultiplyTint","_tintRGB","destroy","deleteBuffer","prototype","indices","ObjectRenderer","WebGLRenderer","registerPlugin"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/particles/webgl/ParticleRenderer.js"],"sourcesContent":["import * as core from '../../core';\nimport ParticleShader from './ParticleShader';\nimport ParticleBuffer from './ParticleBuffer';\nimport { premultiplyTint } from '../../core/utils';\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n */\nexport default class ParticleRenderer extends core.ObjectRenderer\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        // and max number of element in the index buffer is 16384 * 6 = 98304\n        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n        // let numIndices = 98304;\n\n        /**\n         * The default shader that is used if a sprite doesn't have a more specific one.\n         *\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        this.indexBuffer = null;\n\n        this.properties = null;\n\n        this.tempMatrix = new core.Matrix();\n\n        this.CONTEXT_UID = 0;\n    }\n\n    /**\n     * When there is a WebGL context change\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        // setup default shader\n        this.shader = new ParticleShader(gl);\n\n        this.properties = [\n            // verticesData\n            {\n                attribute: this.shader.attributes.aVertexPosition,\n                size: 2,\n                uploadFunction: this.uploadVertices,\n                offset: 0,\n            },\n            // positionData\n            {\n                attribute: this.shader.attributes.aPositionCoord,\n                size: 2,\n                uploadFunction: this.uploadPosition,\n                offset: 0,\n            },\n            // rotationData\n            {\n                attribute: this.shader.attributes.aRotation,\n                size: 1,\n                uploadFunction: this.uploadRotation,\n                offset: 0,\n            },\n            // uvsData\n            {\n                attribute: this.shader.attributes.aTextureCoord,\n                size: 2,\n                uploadFunction: this.uploadUvs,\n                offset: 0,\n            },\n            // tintData\n            {\n                attribute: this.shader.attributes.aColor,\n                size: 1,\n                unsignedByte: true,\n                uploadFunction: this.uploadTint,\n                offset: 0,\n            },\n        ];\n    }\n\n    /**\n     * Starts a new particle batch.\n     *\n     */\n    start()\n    {\n        this.renderer.bindShader(this.shader);\n    }\n\n    /**\n     * Renders the particle container object.\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     */\n    render(container)\n    {\n        const children = container.children;\n        const maxSize = container._maxSize;\n        const batchSize = container._batchSize;\n        const renderer = this.renderer;\n        let totalChildren = children.length;\n\n        if (totalChildren === 0)\n        {\n            return;\n        }\n        else if (totalChildren > maxSize)\n        {\n            totalChildren = maxSize;\n        }\n\n        let buffers = container._glBuffers[renderer.CONTEXT_UID];\n\n        if (!buffers)\n        {\n            buffers = container._glBuffers[renderer.CONTEXT_UID] = this.generateBuffers(container);\n        }\n\n        const baseTexture = children[0]._texture.baseTexture;\n\n        // if the uvs have not updated then no point rendering just yet!\n        this.renderer.setBlendMode(core.utils.correctBlendMode(container.blendMode, baseTexture.premultipliedAlpha));\n\n        const gl = renderer.gl;\n\n        const m = container.worldTransform.copy(this.tempMatrix);\n\n        m.prepend(renderer._activeRenderTarget.projectionMatrix);\n\n        this.shader.uniforms.projectionMatrix = m.toArray(true);\n\n        this.shader.uniforms.uColor = core.utils.premultiplyRgba(container.tintRgb,\n            container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultipliedAlpha);\n\n        // make sure the texture is bound..\n        this.shader.uniforms.uSampler = renderer.bindTexture(baseTexture);\n\n        let updateStatic = false;\n\n        // now lets upload and render the buffers..\n        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)\n        {\n            let amount = (totalChildren - i);\n\n            if (amount > batchSize)\n            {\n                amount = batchSize;\n            }\n\n            if (j >= buffers.length)\n            {\n                if (!container.autoResize)\n                {\n                    break;\n                }\n                buffers.push(this._generateOneMoreBuffer(container));\n            }\n\n            const buffer = buffers[j];\n\n            // we always upload the dynamic\n            buffer.uploadDynamic(children, i, amount);\n\n            const bid = container._bufferUpdateIDs[j] || 0;\n\n            updateStatic = updateStatic || (buffer._updateID < bid);\n            // we only upload the static content when we have to!\n            if (updateStatic)\n            {\n                buffer._updateID = container._updateID;\n                buffer.uploadStatic(children, i, amount);\n            }\n\n            // bind the buffer\n            renderer.bindVao(buffer.vao);\n            buffer.vao.draw(gl.TRIANGLES, amount * 6);\n        }\n    }\n\n    /**\n     * Creates one particle buffer for each child in the container we want to render and updates internal properties\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     * @return {PIXI.ParticleBuffer[]} The buffers\n     */\n    generateBuffers(container)\n    {\n        const gl = this.renderer.gl;\n        const buffers = [];\n        const size = container._maxSize;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        for (let i = 0; i < size; i += batchSize)\n        {\n            buffers.push(new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize));\n        }\n\n        return buffers;\n    }\n\n    /**\n     * Creates one more particle buffer, because container has autoResize feature\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     * @return {PIXI.ParticleBuffer} generated buffer\n     * @private\n     */\n    _generateOneMoreBuffer(container)\n    {\n        const gl = this.renderer.gl;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        return new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize);\n    }\n\n    /**\n     * Uploads the verticies.\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their vertices uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadVertices(children, startIndex, amount, array, stride, offset)\n    {\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const texture = sprite._texture;\n            const sx = sprite.scale.x;\n            const sy = sprite.scale.y;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                // if the sprite is trimmed and is not a tilingsprite then we need to add the\n                // extra space before transforming the sprite coords..\n                w1 = trim.x - (sprite.anchor.x * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (sprite.anchor.y * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w0 = (orig.width) * (1 - sprite.anchor.x);\n                w1 = (orig.width) * -sprite.anchor.x;\n\n                h0 = orig.height * (1 - sprite.anchor.y);\n                h1 = orig.height * -sprite.anchor.y;\n            }\n\n            array[offset] = w1 * sx;\n            array[offset + 1] = h1 * sy;\n\n            array[offset + stride] = w0 * sx;\n            array[offset + stride + 1] = h1 * sy;\n\n            array[offset + (stride * 2)] = w0 * sx;\n            array[offset + (stride * 2) + 1] = h0 * sy;\n\n            array[offset + (stride * 3)] = w1 * sx;\n            array[offset + (stride * 3) + 1] = h0 * sy;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their positions uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadPosition(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spritePosition = children[startIndex + i].position;\n\n            array[offset] = spritePosition.x;\n            array[offset + 1] = spritePosition.y;\n\n            array[offset + stride] = spritePosition.x;\n            array[offset + stride + 1] = spritePosition.y;\n\n            array[offset + (stride * 2)] = spritePosition.x;\n            array[offset + (stride * 2) + 1] = spritePosition.y;\n\n            array[offset + (stride * 3)] = spritePosition.x;\n            array[offset + (stride * 3) + 1] = spritePosition.y;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadRotation(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spriteRotation = children[startIndex + i].rotation;\n\n            array[offset] = spriteRotation;\n            array[offset + stride] = spriteRotation;\n            array[offset + (stride * 2)] = spriteRotation;\n            array[offset + (stride * 3)] = spriteRotation;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadUvs(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const textureUvs = children[startIndex + i]._texture._uvs;\n\n            if (textureUvs)\n            {\n                array[offset] = textureUvs.x0;\n                array[offset + 1] = textureUvs.y0;\n\n                array[offset + stride] = textureUvs.x1;\n                array[offset + stride + 1] = textureUvs.y1;\n\n                array[offset + (stride * 2)] = textureUvs.x2;\n                array[offset + (stride * 2) + 1] = textureUvs.y2;\n\n                array[offset + (stride * 3)] = textureUvs.x3;\n                array[offset + (stride * 3) + 1] = textureUvs.y3;\n\n                offset += stride * 4;\n            }\n            else\n            {\n                // TODO you know this can be easier!\n                array[offset] = 0;\n                array[offset + 1] = 0;\n\n                array[offset + stride] = 0;\n                array[offset + stride + 1] = 0;\n\n                array[offset + (stride * 2)] = 0;\n                array[offset + (stride * 2) + 1] = 0;\n\n                array[offset + (stride * 3)] = 0;\n                array[offset + (stride * 3) + 1] = 0;\n\n                offset += stride * 4;\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadTint(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const premultiplied = sprite._texture.baseTexture.premultipliedAlpha;\n            const alpha = sprite.alpha;\n            // we dont call extra function if alpha is 1.0, that's faster\n            const argb = alpha < 1.0 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha)\n                : sprite._tintRGB + (alpha * 255 << 24);\n\n            array[offset] = argb;\n            array[offset + stride] = argb;\n            array[offset + (stride * 2)] = argb;\n            array[offset + (stride * 3)] = argb;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Destroys the ParticleRenderer.\n     *\n     */\n    destroy()\n    {\n        if (this.renderer.gl)\n        {\n            this.renderer.gl.deleteBuffer(this.indexBuffer);\n        }\n\n        super.destroy();\n\n        this.shader.destroy();\n\n        this.indices = null;\n        this.tempMatrix = null;\n    }\n\n}\n\ncore.WebGLRenderer.registerPlugin('particle', ParticleRenderer);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}