{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _math = require('../../../math');\nvar _const = require('../../../const');\nvar _settings = require('../../../settings');\nvar _settings2 = _interopRequireDefault(_settings);\nvar _pixiGlCore = require('pixi-gl-core');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * @class\n * @memberof PIXI\n */\nvar RenderTarget = function () {\n  /**\n   * @param {WebGLRenderingContext} gl - The current WebGL drawing context\n   * @param {number} [width=0] - the horizontal range of the filter\n   * @param {number} [height=0] - the vertical range of the filter\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {number} [resolution=1] - The current resolution / device pixel ratio\n   * @param {boolean} [root=false] - Whether this object is the root element or not\n   */\n  function RenderTarget(gl, width, height, scaleMode, resolution, root) {\n    _classCallCheck(this, RenderTarget);\n\n    // TODO Resolution could go here ( eg low res blurs )\n\n    /**\n     * The current WebGL drawing context.\n     *\n     * @member {WebGLRenderingContext}\n     */\n    this.gl = gl;\n\n    // next time to create a frame buffer and texture\n\n    /**\n     * A frame buffer\n     *\n     * @member {PIXI.glCore.GLFramebuffer}\n     */\n    this.frameBuffer = null;\n\n    /**\n     * The texture\n     *\n     * @member {PIXI.glCore.GLTexture}\n     */\n    this.texture = null;\n\n    /**\n     * The background colour of this render target, as an array of [r,g,b,a] values\n     *\n     * @member {number[]}\n     */\n    this.clearColor = [0, 0, 0, 0];\n\n    /**\n     * The size of the object as a rectangle\n     *\n     * @member {PIXI.Rectangle}\n     */\n    this.size = new _math.Rectangle(0, 0, 1, 1);\n\n    /**\n     * The current resolution / device pixel ratio\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.resolution = resolution || _settings2.default.RESOLUTION;\n\n    /**\n     * The projection matrix\n     *\n     * @member {PIXI.Matrix}\n     */\n    this.projectionMatrix = new _math.Matrix();\n\n    /**\n     * The object's transform\n     *\n     * @member {PIXI.Matrix}\n     */\n    this.transform = null;\n\n    /**\n     * The frame.\n     *\n     * @member {PIXI.Rectangle}\n     */\n    this.frame = null;\n\n    /**\n     * The stencil buffer stores masking data for the render target\n     *\n     * @member {glCore.GLBuffer}\n     */\n    this.defaultFrame = new _math.Rectangle();\n    this.destinationFrame = null;\n    this.sourceFrame = null;\n\n    /**\n     * The stencil buffer stores masking data for the render target\n     *\n     * @member {glCore.GLBuffer}\n     */\n    this.stencilBuffer = null;\n\n    /**\n     * The data structure for the stencil masks\n     *\n     * @member {PIXI.Graphics[]}\n     */\n    this.stencilMaskStack = [];\n\n    /**\n     * Stores filter data for the render target\n     *\n     * @member {object[]}\n     */\n    this.filterData = null;\n\n    /**\n     * The key for pooled texture of FilterSystem\n     * @private\n     * @member {string}\n     */\n    this.filterPoolKey = '';\n\n    /**\n     * The scale mode.\n     *\n     * @member {number}\n     * @default PIXI.settings.SCALE_MODE\n     * @see PIXI.SCALE_MODES\n     */\n    this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;\n\n    /**\n     * Whether this object is the root element or not\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.root = root || false;\n    if (!this.root) {\n      this.frameBuffer = _pixiGlCore.GLFramebuffer.createRGBA(gl, 100, 100);\n      if (this.scaleMode === _const.SCALE_MODES.NEAREST) {\n        this.frameBuffer.texture.enableNearestScaling();\n      } else {\n        this.frameBuffer.texture.enableLinearScaling();\n      }\n      /*\n          A frame buffer needs a target to render to..\n          create a texture and bind it attach it to the framebuffer..\n       */\n\n      // this is used by the base texture\n      this.texture = this.frameBuffer.texture;\n    } else {\n      // make it a null framebuffer..\n      this.frameBuffer = new _pixiGlCore.GLFramebuffer(gl, 100, 100);\n      this.frameBuffer.framebuffer = null;\n    }\n    this.setFrame();\n    this.resize(width, height);\n  }\n\n  /**\n   * Clears the filter texture.\n   *\n   * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer\n   */\n\n  RenderTarget.prototype.clear = function clear(clearColor) {\n    var cc = clearColor || this.clearColor;\n    this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]); // r,g,b,a);\n  };\n\n  /**\n   * Binds the stencil buffer.\n   *\n   */\n\n  RenderTarget.prototype.attachStencilBuffer = function attachStencilBuffer() {\n    // TODO check if stencil is done?\n    /**\n     * The stencil buffer is used for masking in pixi\n     * lets create one and then add attach it to the framebuffer..\n     */\n    if (!this.root) {\n      this.frameBuffer.enableStencil();\n    }\n  };\n\n  /**\n   * Sets the frame of the render target.\n   *\n   * @param {Rectangle} destinationFrame - The destination frame.\n   * @param {Rectangle} sourceFrame - The source frame.\n   */\n\n  RenderTarget.prototype.setFrame = function setFrame(destinationFrame, sourceFrame) {\n    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;\n    this.sourceFrame = sourceFrame || this.sourceFrame || this.destinationFrame;\n  };\n\n  /**\n   * Binds the buffers and initialises the viewport.\n   *\n   */\n\n  RenderTarget.prototype.activate = function activate() {\n    // TODO refactor usage of frame..\n    var gl = this.gl;\n\n    // make sure the texture is unbound!\n    this.frameBuffer.bind();\n    this.calculateProjection(this.destinationFrame, this.sourceFrame);\n    if (this.transform) {\n      this.projectionMatrix.append(this.transform);\n    }\n\n    // TODO add a check as them may be the same!\n    if (this.destinationFrame !== this.sourceFrame) {\n      gl.enable(gl.SCISSOR_TEST);\n      gl.scissor(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);\n    } else {\n      gl.disable(gl.SCISSOR_TEST);\n    }\n\n    // TODO - does not need to be updated all the time??\n    gl.viewport(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);\n  };\n\n  /**\n   * Updates the projection matrix based on a projection frame (which is a rectangle)\n   *\n   * @param {Rectangle} destinationFrame - The destination frame.\n   * @param {Rectangle} sourceFrame - The source frame.\n   */\n\n  RenderTarget.prototype.calculateProjection = function calculateProjection(destinationFrame, sourceFrame) {\n    var pm = this.projectionMatrix;\n    sourceFrame = sourceFrame || destinationFrame;\n    pm.identity();\n\n    // TODO: make dest scale source\n    if (!this.root) {\n      pm.a = 1 / destinationFrame.width * 2;\n      pm.d = 1 / destinationFrame.height * 2;\n      pm.tx = -1 - sourceFrame.x * pm.a;\n      pm.ty = -1 - sourceFrame.y * pm.d;\n    } else {\n      pm.a = 1 / destinationFrame.width * 2;\n      pm.d = -1 / destinationFrame.height * 2;\n      pm.tx = -1 - sourceFrame.x * pm.a;\n      pm.ty = 1 - sourceFrame.y * pm.d;\n    }\n  };\n\n  /**\n   * Resizes the texture to the specified width and height\n   *\n   * @param {number} width - the new width of the texture\n   * @param {number} height - the new height of the texture\n   */\n\n  RenderTarget.prototype.resize = function resize(width, height) {\n    width = width | 0;\n    height = height | 0;\n    if (this.size.width === width && this.size.height === height) {\n      return;\n    }\n    this.size.width = width;\n    this.size.height = height;\n    this.defaultFrame.width = width;\n    this.defaultFrame.height = height;\n    this.frameBuffer.resize(width * this.resolution, height * this.resolution);\n    var projectionFrame = this.frame || this.size;\n    this.calculateProjection(projectionFrame);\n  };\n\n  /**\n   * Destroys the render target.\n   *\n   */\n\n  RenderTarget.prototype.destroy = function destroy() {\n    if (this.frameBuffer.stencil) {\n      this.gl.deleteRenderbuffer(this.frameBuffer.stencil);\n    }\n    this.frameBuffer.destroy();\n    this.frameBuffer = null;\n    this.texture = null;\n  };\n  return RenderTarget;\n}();\nexports.default = RenderTarget;","map":{"version":3,"names":["_math","require","_const","_settings","_pixiGlCore","RenderTarget","gl","width","height","scaleMode","resolution","root","_classCallCheck","frameBuffer","texture","clearColor","size","Rectangle","_settings2","default","RESOLUTION","projectionMatrix","Matrix","transform","frame","defaultFrame","destinationFrame","sourceFrame","stencilBuffer","stencilMaskStack","filterData","filterPoolKey","undefined","SCALE_MODE","GLFramebuffer","createRGBA","SCALE_MODES","NEAREST","enableNearestScaling","enableLinearScaling","framebuffer","setFrame","resize","clear","cc","attachStencilBuffer","enableStencil","activate","bind","calculateProjection","append","enable","SCISSOR_TEST","scissor","x","y","disable","viewport","pm","identity","a","d","tx","ty","projectionFrame","destroy","stencil","deleteRenderbuffer"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/renderers/webgl/utils/RenderTarget.js"],"sourcesContent":["import { Rectangle, Matrix } from '../../../math';\nimport { SCALE_MODES } from '../../../const';\nimport settings from '../../../settings';\nimport { GLFramebuffer } from 'pixi-gl-core';\n\n/**\n * @class\n * @memberof PIXI\n */\nexport default class RenderTarget\n{\n    /**\n     * @param {WebGLRenderingContext} gl - The current WebGL drawing context\n     * @param {number} [width=0] - the horizontal range of the filter\n     * @param {number} [height=0] - the vertical range of the filter\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [resolution=1] - The current resolution / device pixel ratio\n     * @param {boolean} [root=false] - Whether this object is the root element or not\n     */\n    constructor(gl, width, height, scaleMode, resolution, root)\n    {\n        // TODO Resolution could go here ( eg low res blurs )\n\n        /**\n         * The current WebGL drawing context.\n         *\n         * @member {WebGLRenderingContext}\n         */\n        this.gl = gl;\n\n        // next time to create a frame buffer and texture\n\n        /**\n         * A frame buffer\n         *\n         * @member {PIXI.glCore.GLFramebuffer}\n         */\n        this.frameBuffer = null;\n\n        /**\n         * The texture\n         *\n         * @member {PIXI.glCore.GLTexture}\n         */\n        this.texture = null;\n\n        /**\n         * The background colour of this render target, as an array of [r,g,b,a] values\n         *\n         * @member {number[]}\n         */\n        this.clearColor = [0, 0, 0, 0];\n\n        /**\n         * The size of the object as a rectangle\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.size = new Rectangle(0, 0, 1, 1);\n\n        /**\n         * The current resolution / device pixel ratio\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.resolution = resolution || settings.RESOLUTION;\n\n        /**\n         * The projection matrix\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.projectionMatrix = new Matrix();\n\n        /**\n         * The object's transform\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.transform = null;\n\n        /**\n         * The frame.\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.frame = null;\n\n        /**\n         * The stencil buffer stores masking data for the render target\n         *\n         * @member {glCore.GLBuffer}\n         */\n        this.defaultFrame = new Rectangle();\n        this.destinationFrame = null;\n        this.sourceFrame = null;\n\n        /**\n         * The stencil buffer stores masking data for the render target\n         *\n         * @member {glCore.GLBuffer}\n         */\n        this.stencilBuffer = null;\n\n        /**\n         * The data structure for the stencil masks\n         *\n         * @member {PIXI.Graphics[]}\n         */\n        this.stencilMaskStack = [];\n\n        /**\n         * Stores filter data for the render target\n         *\n         * @member {object[]}\n         */\n        this.filterData = null;\n\n        /**\n         * The key for pooled texture of FilterSystem\n         * @private\n         * @member {string}\n         */\n        this.filterPoolKey = '';\n\n        /**\n         * The scale mode.\n         *\n         * @member {number}\n         * @default PIXI.settings.SCALE_MODE\n         * @see PIXI.SCALE_MODES\n         */\n        this.scaleMode = scaleMode !== undefined ? scaleMode : settings.SCALE_MODE;\n\n        /**\n         * Whether this object is the root element or not\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.root = root || false;\n\n        if (!this.root)\n        {\n            this.frameBuffer = GLFramebuffer.createRGBA(gl, 100, 100);\n\n            if (this.scaleMode === SCALE_MODES.NEAREST)\n            {\n                this.frameBuffer.texture.enableNearestScaling();\n            }\n            else\n            {\n                this.frameBuffer.texture.enableLinearScaling();\n            }\n            /*\n                A frame buffer needs a target to render to..\n                create a texture and bind it attach it to the framebuffer..\n             */\n\n            // this is used by the base texture\n            this.texture = this.frameBuffer.texture;\n        }\n        else\n        {\n            // make it a null framebuffer..\n            this.frameBuffer = new GLFramebuffer(gl, 100, 100);\n            this.frameBuffer.framebuffer = null;\n        }\n\n        this.setFrame();\n\n        this.resize(width, height);\n    }\n\n    /**\n     * Clears the filter texture.\n     *\n     * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer\n     */\n    clear(clearColor)\n    {\n        const cc = clearColor || this.clearColor;\n\n        this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]);// r,g,b,a);\n    }\n\n    /**\n     * Binds the stencil buffer.\n     *\n     */\n    attachStencilBuffer()\n    {\n        // TODO check if stencil is done?\n        /**\n         * The stencil buffer is used for masking in pixi\n         * lets create one and then add attach it to the framebuffer..\n         */\n        if (!this.root)\n        {\n            this.frameBuffer.enableStencil();\n        }\n    }\n\n    /**\n     * Sets the frame of the render target.\n     *\n     * @param {Rectangle} destinationFrame - The destination frame.\n     * @param {Rectangle} sourceFrame - The source frame.\n     */\n    setFrame(destinationFrame, sourceFrame)\n    {\n        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;\n        this.sourceFrame = sourceFrame || this.sourceFrame || this.destinationFrame;\n    }\n\n    /**\n     * Binds the buffers and initialises the viewport.\n     *\n     */\n    activate()\n    {\n        // TODO refactor usage of frame..\n        const gl = this.gl;\n\n        // make sure the texture is unbound!\n        this.frameBuffer.bind();\n\n        this.calculateProjection(this.destinationFrame, this.sourceFrame);\n\n        if (this.transform)\n        {\n            this.projectionMatrix.append(this.transform);\n        }\n\n        // TODO add a check as them may be the same!\n        if (this.destinationFrame !== this.sourceFrame)\n        {\n            gl.enable(gl.SCISSOR_TEST);\n            gl.scissor(\n                this.destinationFrame.x | 0,\n                this.destinationFrame.y | 0,\n                (this.destinationFrame.width * this.resolution) | 0,\n                (this.destinationFrame.height * this.resolution) | 0\n            );\n        }\n        else\n        {\n            gl.disable(gl.SCISSOR_TEST);\n        }\n\n        // TODO - does not need to be updated all the time??\n        gl.viewport(\n            this.destinationFrame.x | 0,\n            this.destinationFrame.y | 0,\n            (this.destinationFrame.width * this.resolution) | 0,\n            (this.destinationFrame.height * this.resolution) | 0\n        );\n    }\n\n    /**\n     * Updates the projection matrix based on a projection frame (which is a rectangle)\n     *\n     * @param {Rectangle} destinationFrame - The destination frame.\n     * @param {Rectangle} sourceFrame - The source frame.\n     */\n    calculateProjection(destinationFrame, sourceFrame)\n    {\n        const pm = this.projectionMatrix;\n\n        sourceFrame = sourceFrame || destinationFrame;\n\n        pm.identity();\n\n        // TODO: make dest scale source\n        if (!this.root)\n        {\n            pm.a = 1 / destinationFrame.width * 2;\n            pm.d = 1 / destinationFrame.height * 2;\n\n            pm.tx = -1 - (sourceFrame.x * pm.a);\n            pm.ty = -1 - (sourceFrame.y * pm.d);\n        }\n        else\n        {\n            pm.a = 1 / destinationFrame.width * 2;\n            pm.d = -1 / destinationFrame.height * 2;\n\n            pm.tx = -1 - (sourceFrame.x * pm.a);\n            pm.ty = 1 - (sourceFrame.y * pm.d);\n        }\n    }\n\n    /**\n     * Resizes the texture to the specified width and height\n     *\n     * @param {number} width - the new width of the texture\n     * @param {number} height - the new height of the texture\n     */\n    resize(width, height)\n    {\n        width = width | 0;\n        height = height | 0;\n\n        if (this.size.width === width && this.size.height === height)\n        {\n            return;\n        }\n\n        this.size.width = width;\n        this.size.height = height;\n\n        this.defaultFrame.width = width;\n        this.defaultFrame.height = height;\n\n        this.frameBuffer.resize(width * this.resolution, height * this.resolution);\n\n        const projectionFrame = this.frame || this.size;\n\n        this.calculateProjection(projectionFrame);\n    }\n\n    /**\n     * Destroys the render target.\n     *\n     */\n    destroy()\n    {\n        if (this.frameBuffer.stencil)\n        {\n            this.gl.deleteRenderbuffer(this.frameBuffer.stencil);\n        }\n        this.frameBuffer.destroy();\n\n        this.frameBuffer = null;\n        this.texture = null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}