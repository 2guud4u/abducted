{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _Sprite2 = require('../sprites/Sprite');\nvar _Sprite3 = _interopRequireDefault(_Sprite2);\nvar _Texture = require('../textures/Texture');\nvar _Texture2 = _interopRequireDefault(_Texture);\nvar _math = require('../math');\nvar _utils = require('../utils');\nvar _const = require('../const');\nvar _settings = require('../settings');\nvar _settings2 = _interopRequireDefault(_settings);\nvar _TextStyle = require('./TextStyle');\nvar _TextStyle2 = _interopRequireDefault(_TextStyle);\nvar _TextMetrics = require('./TextMetrics');\nvar _TextMetrics2 = _interopRequireDefault(_TextMetrics);\nvar _trimCanvas = require('../utils/trimCanvas');\nvar _trimCanvas2 = _interopRequireDefault(_trimCanvas);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} /* eslint max-depth: [2, 8] */\n\nvar defaultDestroyOptions = {\n  texture: true,\n  children: false,\n  baseTexture: true\n};\n\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * A Text can be created directly from a string and a style object,\n * which can be generated [here](https://pixijs.io/pixi-text-style).\n *\n * ```js\n * let text = new PIXI.Text('This is a PixiJS text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n */\n\nvar Text = function (_Sprite) {\n  _inherits(Text, _Sprite);\n\n  /**\n   * @param {string} text - The string that you would like the text to display\n   * @param {object|PIXI.TextStyle} [style] - The style parameters\n   * @param {HTMLCanvasElement} [canvas] - The canvas element for drawing text\n   */\n  function Text(text, style, canvas) {\n    _classCallCheck(this, Text);\n    canvas = canvas || document.createElement('canvas');\n    canvas.width = 3;\n    canvas.height = 3;\n    var texture = _Texture2.default.fromCanvas(canvas, _settings2.default.SCALE_MODE, 'text');\n    texture.orig = new _math.Rectangle();\n    texture.trim = new _math.Rectangle();\n\n    // base texture is already automatically added to the cache, now adding the actual texture\n    var _this = _possibleConstructorReturn(this, _Sprite.call(this, texture));\n    _Texture2.default.addToCache(_this._texture, _this._texture.baseTexture.textureCacheIds[0]);\n\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @member {HTMLCanvasElement}\n     */\n    _this.canvas = canvas;\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @member {CanvasRenderingContext2D}\n     */\n    _this.context = _this.canvas.getContext('2d');\n\n    /**\n     * The resolution / device pixel ratio of the canvas. This is set automatically by the renderer.\n     * @member {number}\n     * @default 1\n     */\n    _this.resolution = _settings2.default.RESOLUTION;\n\n    /**\n     * Private tracker for the current text.\n     *\n     * @member {string}\n     * @private\n     */\n    _this._text = null;\n\n    /**\n     * Private tracker for the current style.\n     *\n     * @member {object}\n     * @private\n     */\n    _this._style = null;\n    /**\n     * Private listener to track style changes.\n     *\n     * @member {Function}\n     * @private\n     */\n    _this._styleListener = null;\n\n    /**\n     * Private tracker for the current font.\n     *\n     * @member {string}\n     * @private\n     */\n    _this._font = '';\n    _this.text = text;\n    _this.style = style;\n    _this.localStyleID = -1;\n    return _this;\n  }\n\n  /**\n   * Renders text and updates it when needed.\n   *\n   * @private\n   * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n   */\n\n  Text.prototype.updateText = function updateText(respectDirty) {\n    var style = this._style;\n\n    // check if style has changed..\n    if (this.localStyleID !== style.styleID) {\n      this.dirty = true;\n      this.localStyleID = style.styleID;\n    }\n    if (!this.dirty && respectDirty) {\n      return;\n    }\n    this._font = this._style.toFontString();\n    var context = this.context;\n    var measured = _TextMetrics2.default.measureText(this._text, this._style, this._style.wordWrap, this.canvas);\n    var width = measured.width;\n    var height = measured.height;\n    var lines = measured.lines;\n    var lineHeight = measured.lineHeight;\n    var lineWidths = measured.lineWidths;\n    var maxLineWidth = measured.maxLineWidth;\n    var fontProperties = measured.fontProperties;\n    this.canvas.width = Math.ceil((Math.max(1, width) + style.padding * 2) * this.resolution);\n    this.canvas.height = Math.ceil((Math.max(1, height) + style.padding * 2) * this.resolution);\n    context.scale(this.resolution, this.resolution);\n    context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    context.font = this._font;\n    context.strokeStyle = style.stroke;\n    context.lineWidth = style.strokeThickness;\n    context.textBaseline = style.textBaseline;\n    context.lineJoin = style.lineJoin;\n    context.miterLimit = style.miterLimit;\n    var linePositionX = void 0;\n    var linePositionY = void 0;\n    if (style.dropShadow) {\n      context.fillStyle = style.dropShadowColor;\n      context.globalAlpha = style.dropShadowAlpha;\n      context.shadowBlur = style.dropShadowBlur;\n      if (style.dropShadowBlur > 0) {\n        context.shadowColor = style.dropShadowColor;\n      }\n      var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n      var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n      for (var i = 0; i < lines.length; i++) {\n        linePositionX = style.strokeThickness / 2;\n        linePositionY = style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent;\n        if (style.align === 'right') {\n          linePositionX += maxLineWidth - lineWidths[i];\n        } else if (style.align === 'center') {\n          linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n        }\n        if (style.fill) {\n          this.drawLetterSpacing(lines[i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding);\n          if (style.stroke && style.strokeThickness) {\n            context.strokeStyle = style.dropShadowColor;\n            this.drawLetterSpacing(lines[i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding, true);\n            context.strokeStyle = style.stroke;\n          }\n        }\n      }\n    }\n\n    // reset the shadow blur and alpha that was set by the drop shadow, for the regular text\n    context.shadowBlur = 0;\n    context.globalAlpha = 1;\n\n    // set canvas text styles\n    context.fillStyle = this._generateFillStyle(style, lines);\n\n    // draw lines line by line\n    for (var _i = 0; _i < lines.length; _i++) {\n      linePositionX = style.strokeThickness / 2;\n      linePositionY = style.strokeThickness / 2 + _i * lineHeight + fontProperties.ascent;\n      if (style.align === 'right') {\n        linePositionX += maxLineWidth - lineWidths[_i];\n      } else if (style.align === 'center') {\n        linePositionX += (maxLineWidth - lineWidths[_i]) / 2;\n      }\n      if (style.stroke && style.strokeThickness) {\n        this.drawLetterSpacing(lines[_i], linePositionX + style.padding, linePositionY + style.padding, true);\n      }\n      if (style.fill) {\n        this.drawLetterSpacing(lines[_i], linePositionX + style.padding, linePositionY + style.padding);\n      }\n    }\n    this.updateTexture();\n  };\n\n  /**\n   * Render the text with letter-spacing.\n   * @param {string} text - The text to draw\n   * @param {number} x - Horizontal position to draw the text\n   * @param {number} y - Vertical position to draw the text\n   * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the\n   *  text? If not, it's for the inside fill\n   * @private\n   */\n\n  Text.prototype.drawLetterSpacing = function drawLetterSpacing(text, x, y) {\n    var isStroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var style = this._style;\n\n    // letterSpacing of 0 means normal\n    var letterSpacing = style.letterSpacing;\n    if (letterSpacing === 0) {\n      if (isStroke) {\n        this.context.strokeText(text, x, y);\n      } else {\n        this.context.fillText(text, x, y);\n      }\n      return;\n    }\n    var characters = String.prototype.split.call(text, '');\n    var currentPosition = x;\n    var index = 0;\n    var current = '';\n    var previousWidth = this.context.measureText(text).width;\n    var currentWidth = 0;\n    while (index < text.length) {\n      current = characters[index++];\n      if (isStroke) {\n        this.context.strokeText(current, currentPosition, y);\n      } else {\n        this.context.fillText(current, currentPosition, y);\n      }\n      currentWidth = this.context.measureText(text.substring(index)).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  };\n\n  /**\n   * Updates texture size based on canvas size\n   *\n   * @private\n   */\n\n  Text.prototype.updateTexture = function updateTexture() {\n    var canvas = this.canvas;\n    if (this._style.trim) {\n      var trimmed = (0, _trimCanvas2.default)(canvas);\n      if (trimmed.data) {\n        canvas.width = trimmed.width;\n        canvas.height = trimmed.height;\n        this.context.putImageData(trimmed.data, 0, 0);\n      }\n    }\n    var texture = this._texture;\n    var style = this._style;\n    var padding = style.trim ? 0 : style.padding;\n    var baseTexture = texture.baseTexture;\n    baseTexture.hasLoaded = true;\n    baseTexture.resolution = this.resolution;\n    baseTexture.realWidth = canvas.width;\n    baseTexture.realHeight = canvas.height;\n    baseTexture.width = canvas.width / this.resolution;\n    baseTexture.height = canvas.height / this.resolution;\n    texture.trim.width = texture._frame.width = canvas.width / this.resolution;\n    texture.trim.height = texture._frame.height = canvas.height / this.resolution;\n    texture.trim.x = -padding;\n    texture.trim.y = -padding;\n    texture.orig.width = texture._frame.width - padding * 2;\n    texture.orig.height = texture._frame.height - padding * 2;\n\n    // call sprite onTextureUpdate to update scale if _width or _height were set\n    this._onTextureUpdate();\n    baseTexture.emit('update', baseTexture);\n    this.dirty = false;\n  };\n\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n  Text.prototype.renderWebGL = function renderWebGL(renderer) {\n    if (this.resolution !== renderer.resolution) {\n      this.resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    this.updateText(true);\n    _Sprite.prototype.renderWebGL.call(this, renderer);\n  };\n\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */\n\n  Text.prototype._renderCanvas = function _renderCanvas(renderer) {\n    if (this.resolution !== renderer.resolution) {\n      this.resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    this.updateText(true);\n    _Sprite.prototype._renderCanvas.call(this, renderer);\n  };\n\n  /**\n   * Gets the local bounds of the text object.\n   *\n   * @param {Rectangle} rect - The output rectangle.\n   * @return {Rectangle} The bounds.\n   */\n\n  Text.prototype.getLocalBounds = function getLocalBounds(rect) {\n    this.updateText(true);\n    return _Sprite.prototype.getLocalBounds.call(this, rect);\n  };\n\n  /**\n   * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n   */\n\n  Text.prototype._calculateBounds = function _calculateBounds() {\n    this.updateText(true);\n    this.calculateVertices();\n    // if we have already done this on THIS frame.\n    this._bounds.addQuad(this.vertexData);\n  };\n\n  /**\n   * Method to be called upon a TextStyle change.\n   * @private\n   */\n\n  Text.prototype._onStyleChange = function _onStyleChange() {\n    this.dirty = true;\n  };\n\n  /**\n   * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n   *\n   * @private\n   * @param {object} style - The style.\n   * @param {string[]} lines - The lines of text.\n   * @return {string|number|CanvasGradient} The fill style\n   */\n\n  Text.prototype._generateFillStyle = function _generateFillStyle(style, lines) {\n    if (!Array.isArray(style.fill)) {\n      return style.fill;\n    }\n\n    // cocoon on canvas+ cannot generate textures, so use the first colour instead\n    if (navigator.isCocoonJS) {\n      return style.fill[0];\n    }\n\n    // the gradient will be evenly spaced out according to how large the array is.\n    // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n    var gradient = void 0;\n    var totalIterations = void 0;\n    var currentIteration = void 0;\n    var stop = void 0;\n    var width = this.canvas.width / this.resolution;\n    var height = this.canvas.height / this.resolution;\n\n    // make a copy of the style settings, so we can manipulate them later\n    var fill = style.fill.slice();\n    var fillGradientStops = style.fillGradientStops.slice();\n\n    // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n    if (!fillGradientStops.length) {\n      var lengthPlus1 = fill.length + 1;\n      for (var i = 1; i < lengthPlus1; ++i) {\n        fillGradientStops.push(i / lengthPlus1);\n      }\n    }\n\n    // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n    // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n    fill.unshift(style.fill[0]);\n    fillGradientStops.unshift(0);\n    fill.push(style.fill[style.fill.length - 1]);\n    fillGradientStops.push(1);\n    if (style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {\n      // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n      gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);\n\n      // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n      // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n      totalIterations = (fill.length + 1) * lines.length;\n      currentIteration = 0;\n      for (var _i2 = 0; _i2 < lines.length; _i2++) {\n        currentIteration += 1;\n        for (var j = 0; j < fill.length; j++) {\n          if (typeof fillGradientStops[j] === 'number') {\n            stop = fillGradientStops[j] / lines.length + _i2 / lines.length;\n          } else {\n            stop = currentIteration / totalIterations;\n          }\n          gradient.addColorStop(stop, fill[j]);\n          currentIteration++;\n        }\n      }\n    } else {\n      // start the gradient at the center left of the canvas, and end at the center right of the canvas\n      gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);\n\n      // can just evenly space out the gradients in this case, as multiple lines makes no difference\n      // to an even left to right gradient\n      totalIterations = fill.length + 1;\n      currentIteration = 1;\n      for (var _i3 = 0; _i3 < fill.length; _i3++) {\n        if (typeof fillGradientStops[_i3] === 'number') {\n          stop = fillGradientStops[_i3];\n        } else {\n          stop = currentIteration / totalIterations;\n        }\n        gradient.addColorStop(stop, fill[_i3]);\n        currentIteration++;\n      }\n    }\n    return gradient;\n  };\n\n  /**\n   * Destroys this text object.\n   * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n   * the majority of the time the texture will not be shared with any other Sprites.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their\n   *  destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n   * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n   */\n\n  Text.prototype.destroy = function destroy(options) {\n    if (typeof options === 'boolean') {\n      options = {\n        children: options\n      };\n    }\n    options = Object.assign({}, defaultDestroyOptions, options);\n    _Sprite.prototype.destroy.call(this, options);\n\n    // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n    this.context = null;\n    this.canvas = null;\n    this._style = null;\n  };\n\n  /**\n   * The width of the Text, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   */\n\n  _createClass(Text, [{\n    key: 'width',\n    get: function get() {\n      this.updateText(true);\n      return Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.updateText(true);\n      var s = (0, _utils.sign)(this.scale.x) || 1;\n      this.scale.x = s * value / this._texture.orig.width;\n      this._width = value;\n    }\n\n    /**\n     * The height of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n  }, {\n    key: 'height',\n    get: function get() {\n      this.updateText(true);\n      return Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.updateText(true);\n      var s = (0, _utils.sign)(this.scale.y) || 1;\n      this.scale.y = s * value / this._texture.orig.height;\n      this._height = value;\n    }\n\n    /**\n     * Set the style of the text. Set up an event listener to listen for changes on the style\n     * object and mark the text as dirty.\n     *\n     * @member {object|PIXI.TextStyle}\n     */\n  }, {\n    key: 'style',\n    get: function get() {\n      return this._style;\n    },\n    set: function set(style)\n    // eslint-disable-line require-jsdoc\n    {\n      style = style || {};\n      if (style instanceof _TextStyle2.default) {\n        this._style = style;\n      } else {\n        this._style = new _TextStyle2.default(style);\n      }\n      this.localStyleID = -1;\n      this.dirty = true;\n    }\n\n    /**\n     * Set the copy for the text object. To split a line you can use '\\n'.\n     *\n     * @member {string}\n     */\n  }, {\n    key: 'text',\n    get: function get() {\n      return this._text;\n    },\n    set: function set(text)\n    // eslint-disable-line require-jsdoc\n    {\n      text = String(text === '' || text === null || text === undefined ? ' ' : text);\n      if (this._text === text) {\n        return;\n      }\n      this._text = text;\n      this.dirty = true;\n    }\n  }]);\n  return Text;\n}(_Sprite3.default);\nexports.default = Text;","map":{"version":3,"names":["_Sprite2","require","_Texture","_math","_utils","_const","_settings","_TextStyle","_TextMetrics","_trimCanvas","defaultDestroyOptions","texture","children","baseTexture","Text","text","style","canvas","_classCallCheck","document","createElement","width","height","_Texture2","default","fromCanvas","_settings2","SCALE_MODE","orig","Rectangle","trim","_this","_possibleConstructorReturn","_Sprite","call","addToCache","_texture","textureCacheIds","context","getContext","resolution","RESOLUTION","_text","_style","_styleListener","_font","localStyleID","updateText","respectDirty","styleID","dirty","toFontString","measured","_TextMetrics2","measureText","wordWrap","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","Math","ceil","max","padding","scale","clearRect","font","strokeStyle","stroke","lineWidth","strokeThickness","textBaseline","lineJoin","miterLimit","linePositionX","linePositionY","dropShadow","fillStyle","dropShadowColor","globalAlpha","dropShadowAlpha","shadowBlur","dropShadowBlur","shadowColor","xShadowOffset","cos","dropShadowAngle","dropShadowDistance","yShadowOffset","sin","i","length","ascent","align","fill","drawLetterSpacing","_generateFillStyle","_i","updateTexture","x","y","isStroke","arguments","undefined","letterSpacing","strokeText","fillText","characters","String","prototype","split","currentPosition","index","current","previousWidth","currentWidth","substring","trimmed","_trimCanvas2","data","putImageData","hasLoaded","realWidth","realHeight","_frame","_onTextureUpdate","emit","renderWebGL","renderer","_renderCanvas","getLocalBounds","rect","_calculateBounds","calculateVertices","_bounds","addQuad","vertexData","_onStyleChange","Array","isArray","navigator","isCocoonJS","gradient","totalIterations","currentIteration","stop","slice","fillGradientStops","lengthPlus1","push","unshift","fillGradientType","TEXT_GRADIENT","LINEAR_VERTICAL","createLinearGradient","_i2","j","addColorStop","_i3","destroy","options","Object","assign","abs","value","s","sign","_width","_height","_TextStyle2"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/text/Text.js"],"sourcesContent":["/* eslint max-depth: [2, 8] */\nimport Sprite from '../sprites/Sprite';\nimport Texture from '../textures/Texture';\nimport { Rectangle } from '../math';\nimport { sign } from '../utils';\nimport { TEXT_GRADIENT } from '../const';\nimport settings from '../settings';\nimport TextStyle from './TextStyle';\nimport TextMetrics from './TextMetrics';\nimport trimCanvas from '../utils/trimCanvas';\n\nconst defaultDestroyOptions = {\n    texture: true,\n    children: false,\n    baseTexture: true,\n};\n\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * A Text can be created directly from a string and a style object,\n * which can be generated [here](https://pixijs.io/pixi-text-style).\n *\n * ```js\n * let text = new PIXI.Text('This is a PixiJS text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n */\nexport default class Text extends Sprite\n{\n    /**\n     * @param {string} text - The string that you would like the text to display\n     * @param {object|PIXI.TextStyle} [style] - The style parameters\n     * @param {HTMLCanvasElement} [canvas] - The canvas element for drawing text\n     */\n    constructor(text, style, canvas)\n    {\n        canvas = canvas || document.createElement('canvas');\n\n        canvas.width = 3;\n        canvas.height = 3;\n\n        const texture = Texture.fromCanvas(canvas, settings.SCALE_MODE, 'text');\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        super(texture);\n\n        // base texture is already automatically added to the cache, now adding the actual texture\n        Texture.addToCache(this._texture, this._texture.baseTexture.textureCacheIds[0]);\n\n        /**\n         * The canvas element that everything is drawn to\n         *\n         * @member {HTMLCanvasElement}\n         */\n        this.canvas = canvas;\n\n        /**\n         * The canvas 2d context that everything is drawn with\n         * @member {CanvasRenderingContext2D}\n         */\n        this.context = this.canvas.getContext('2d');\n\n        /**\n         * The resolution / device pixel ratio of the canvas. This is set automatically by the renderer.\n         * @member {number}\n         * @default 1\n         */\n        this.resolution = settings.RESOLUTION;\n\n        /**\n         * Private tracker for the current text.\n         *\n         * @member {string}\n         * @private\n         */\n        this._text = null;\n\n        /**\n         * Private tracker for the current style.\n         *\n         * @member {object}\n         * @private\n         */\n        this._style = null;\n        /**\n         * Private listener to track style changes.\n         *\n         * @member {Function}\n         * @private\n         */\n        this._styleListener = null;\n\n        /**\n         * Private tracker for the current font.\n         *\n         * @member {string}\n         * @private\n         */\n        this._font = '';\n\n        this.text = text;\n        this.style = style;\n\n        this.localStyleID = -1;\n    }\n\n    /**\n     * Renders text and updates it when needed.\n     *\n     * @private\n     * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n     */\n    updateText(respectDirty)\n    {\n        const style = this._style;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        this._font = this._style.toFontString();\n\n        const context = this.context;\n        const measured = TextMetrics.measureText(this._text, this._style, this._style.wordWrap, this.canvas);\n        const width = measured.width;\n        const height = measured.height;\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        this.canvas.width = Math.ceil((Math.max(1, width) + (style.padding * 2)) * this.resolution);\n        this.canvas.height = Math.ceil((Math.max(1, height) + (style.padding * 2)) * this.resolution);\n\n        context.scale(this.resolution, this.resolution);\n\n        context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        context.font = this._font;\n        context.strokeStyle = style.stroke;\n        context.lineWidth = style.strokeThickness;\n        context.textBaseline = style.textBaseline;\n        context.lineJoin = style.lineJoin;\n        context.miterLimit = style.miterLimit;\n\n        let linePositionX;\n        let linePositionY;\n\n        if (style.dropShadow)\n        {\n            context.fillStyle = style.dropShadowColor;\n            context.globalAlpha = style.dropShadowAlpha;\n            context.shadowBlur = style.dropShadowBlur;\n\n            if (style.dropShadowBlur > 0)\n            {\n                context.shadowColor = style.dropShadowColor;\n            }\n\n            const xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n            const yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = style.strokeThickness / 2;\n                linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style.fill)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding\n                    );\n\n                    if (style.stroke && style.strokeThickness)\n                    {\n                        context.strokeStyle = style.dropShadowColor;\n                        this.drawLetterSpacing(\n                            lines[i],\n                            linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding,\n                            true\n                        );\n                        context.strokeStyle = style.stroke;\n                    }\n                }\n            }\n        }\n\n        // reset the shadow blur and alpha that was set by the drop shadow, for the regular text\n        context.shadowBlur = 0;\n        context.globalAlpha = 1;\n\n        // set canvas text styles\n        context.fillStyle = this._generateFillStyle(style, lines);\n\n        // draw lines line by line\n        for (let i = 0; i < lines.length; i++)\n        {\n            linePositionX = style.strokeThickness / 2;\n            linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;\n\n            if (style.align === 'right')\n            {\n                linePositionX += maxLineWidth - lineWidths[i];\n            }\n            else if (style.align === 'center')\n            {\n                linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            if (style.stroke && style.strokeThickness)\n            {\n                this.drawLetterSpacing(\n                    lines[i],\n                    linePositionX + style.padding,\n                    linePositionY + style.padding,\n                    true\n                );\n            }\n\n            if (style.fill)\n            {\n                this.drawLetterSpacing(\n                    lines[i],\n                    linePositionX + style.padding,\n                    linePositionY + style.padding\n                );\n            }\n        }\n\n        this.updateTexture();\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param {string} text - The text to draw\n     * @param {number} x - Horizontal position to draw the text\n     * @param {number} y - Vertical position to draw the text\n     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     * @private\n     */\n    drawLetterSpacing(text, x, y, isStroke = false)\n    {\n        const style = this._style;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        if (letterSpacing === 0)\n        {\n            if (isStroke)\n            {\n                this.context.strokeText(text, x, y);\n            }\n            else\n            {\n                this.context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        const characters = String.prototype.split.call(text, '');\n        let currentPosition = x;\n        let index = 0;\n        let current = '';\n        let previousWidth = this.context.measureText(text).width;\n        let currentWidth = 0;\n\n        while (index < text.length)\n        {\n            current = characters[index++];\n            if (isStroke)\n            {\n                this.context.strokeText(current, currentPosition, y);\n            }\n            else\n            {\n                this.context.fillText(current, currentPosition, y);\n            }\n            currentWidth = this.context.measureText(text.substring(index)).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    /**\n     * Updates texture size based on canvas size\n     *\n     * @private\n     */\n    updateTexture()\n    {\n        const canvas = this.canvas;\n\n        if (this._style.trim)\n        {\n            const trimmed = trimCanvas(canvas);\n\n            if (trimmed.data)\n            {\n                canvas.width = trimmed.width;\n                canvas.height = trimmed.height;\n                this.context.putImageData(trimmed.data, 0, 0);\n            }\n        }\n\n        const texture = this._texture;\n        const style = this._style;\n        const padding = style.trim ? 0 : style.padding;\n        const baseTexture = texture.baseTexture;\n\n        baseTexture.hasLoaded = true;\n        baseTexture.resolution = this.resolution;\n\n        baseTexture.realWidth = canvas.width;\n        baseTexture.realHeight = canvas.height;\n        baseTexture.width = canvas.width / this.resolution;\n        baseTexture.height = canvas.height / this.resolution;\n\n        texture.trim.width = texture._frame.width = canvas.width / this.resolution;\n        texture.trim.height = texture._frame.height = canvas.height / this.resolution;\n        texture.trim.x = -padding;\n        texture.trim.y = -padding;\n\n        texture.orig.width = texture._frame.width - (padding * 2);\n        texture.orig.height = texture._frame.height - (padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        baseTexture.emit('update', baseTexture);\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderWebGL(renderer)\n    {\n        if (this.resolution !== renderer.resolution)\n        {\n            this.resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super.renderWebGL(renderer);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer)\n    {\n        if (this.resolution !== renderer.resolution)\n        {\n            this.resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._renderCanvas(renderer);\n    }\n\n    /**\n     * Gets the local bounds of the text object.\n     *\n     * @param {Rectangle} rect - The output rectangle.\n     * @return {Rectangle} The bounds.\n     */\n    getLocalBounds(rect)\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n     */\n    _calculateBounds()\n    {\n        this.updateText(true);\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        this._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Method to be called upon a TextStyle change.\n     * @private\n     */\n    _onStyleChange()\n    {\n        this.dirty = true;\n    }\n\n    /**\n     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n     *\n     * @private\n     * @param {object} style - The style.\n     * @param {string[]} lines - The lines of text.\n     * @return {string|number|CanvasGradient} The fill style\n     */\n    _generateFillStyle(style, lines)\n    {\n        if (!Array.isArray(style.fill))\n        {\n            return style.fill;\n        }\n\n        // cocoon on canvas+ cannot generate textures, so use the first colour instead\n        if (navigator.isCocoonJS)\n        {\n            return style.fill[0];\n        }\n\n        // the gradient will be evenly spaced out according to how large the array is.\n        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n        let gradient;\n        let totalIterations;\n        let currentIteration;\n        let stop;\n\n        const width = this.canvas.width / this.resolution;\n        const height = this.canvas.height / this.resolution;\n\n        // make a copy of the style settings, so we can manipulate them later\n        const fill = style.fill.slice();\n        const fillGradientStops = style.fillGradientStops.slice();\n\n        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n        if (!fillGradientStops.length)\n        {\n            const lengthPlus1 = fill.length + 1;\n\n            for (let i = 1; i < lengthPlus1; ++i)\n            {\n                fillGradientStops.push(i / lengthPlus1);\n            }\n        }\n\n        // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n        fill.unshift(style.fill[0]);\n        fillGradientStops.unshift(0);\n\n        fill.push(style.fill[style.fill.length - 1]);\n        fillGradientStops.push(1);\n\n        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL)\n        {\n            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n            gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);\n\n            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n            totalIterations = (fill.length + 1) * lines.length;\n            currentIteration = 0;\n            for (let i = 0; i < lines.length; i++)\n            {\n                currentIteration += 1;\n                for (let j = 0; j < fill.length; j++)\n                {\n                    if (typeof fillGradientStops[j] === 'number')\n                    {\n                        stop = (fillGradientStops[j] / lines.length) + (i / lines.length);\n                    }\n                    else\n                    {\n                        stop = currentIteration / totalIterations;\n                    }\n                    gradient.addColorStop(stop, fill[j]);\n                    currentIteration++;\n                }\n            }\n        }\n        else\n        {\n            // start the gradient at the center left of the canvas, and end at the center right of the canvas\n            gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);\n\n            // can just evenly space out the gradients in this case, as multiple lines makes no difference\n            // to an even left to right gradient\n            totalIterations = fill.length + 1;\n            currentIteration = 1;\n\n            for (let i = 0; i < fill.length; i++)\n            {\n                if (typeof fillGradientStops[i] === 'number')\n                {\n                    stop = fillGradientStops[i];\n                }\n                else\n                {\n                    stop = currentIteration / totalIterations;\n                }\n                gradient.addColorStop(stop, fill[i]);\n                currentIteration++;\n            }\n        }\n\n        return gradient;\n    }\n\n    /**\n     * Destroys this text object.\n     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n     * the majority of the time the texture will not be shared with any other Sprites.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n     */\n    destroy(options)\n    {\n        if (typeof options === 'boolean')\n        {\n            options = { children: options };\n        }\n\n        options = Object.assign({}, defaultDestroyOptions, options);\n\n        super.destroy(options);\n\n        // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n        this.context = null;\n        this.canvas = null;\n\n        this._style = null;\n    }\n\n    /**\n     * The width of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /**\n     * The height of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * Set the style of the text. Set up an event listener to listen for changes on the style\n     * object and mark the text as dirty.\n     *\n     * @member {object|PIXI.TextStyle}\n     */\n    get style()\n    {\n        return this._style;\n    }\n\n    set style(style) // eslint-disable-line require-jsdoc\n    {\n        style = style || {};\n\n        if (style instanceof TextStyle)\n        {\n            this._style = style;\n        }\n        else\n        {\n            this._style = new TextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /**\n     * Set the copy for the text object. To split a line you can use '\\n'.\n     *\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(text) // eslint-disable-line require-jsdoc\n    {\n        text = String(text === '' || text === null || text === undefined ? ' ' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}