{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _BaseTexture2 = require('./BaseTexture');\nvar _BaseTexture3 = _interopRequireDefault(_BaseTexture2);\nvar _settings = require('../settings');\nvar _settings2 = _interopRequireDefault(_settings);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * A BaseRenderTexture is a special texture that allows any PixiJS display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a BaseRenderTexture should be preloaded\n * otherwise black rectangles will be drawn instead.\n *\n * A BaseRenderTexture takes a snapshot of any Display Object given to its render method. The position\n * and rotation of the given Display Objects is ignored. For example:\n *\n * ```js\n * let renderer = PIXI.autoDetectRenderer(1024, 1024);\n * let baseRenderTexture = new PIXI.BaseRenderTexture(800, 600);\n * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);\n * let sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *\n * sprite.position.x = 800/2;\n * sprite.position.y = 600/2;\n * sprite.anchor.x = 0.5;\n * sprite.anchor.y = 0.5;\n *\n * renderer.render(sprite, renderTexture);\n * ```\n *\n * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0\n * you can clear the transform\n *\n * ```js\n *\n * sprite.setTransform()\n *\n * let baseRenderTexture = new PIXI.BaseRenderTexture(100, 100);\n * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);\n *\n * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture\n * ```\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n */\nvar BaseRenderTexture = function (_BaseTexture) {\n  _inherits(BaseRenderTexture, _BaseTexture);\n\n  /**\n   * @param {number} [width=100] - The width of the base render texture\n   * @param {number} [height=100] - The height of the base render texture\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated\n   */\n  function BaseRenderTexture() {\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    var scaleMode = arguments[2];\n    var resolution = arguments[3];\n    _classCallCheck(this, BaseRenderTexture);\n    var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, null, scaleMode));\n    _this.resolution = resolution || _settings2.default.RESOLUTION;\n    _this.width = Math.ceil(width);\n    _this.height = Math.ceil(height);\n    _this.realWidth = _this.width * _this.resolution;\n    _this.realHeight = _this.height * _this.resolution;\n    _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;\n    _this.hasLoaded = true;\n\n    /**\n     * A map of renderer IDs to webgl renderTargets\n     *\n     * @private\n     * @member {object<number, WebGLTexture>}\n     */\n    _this._glRenderTargets = {};\n\n    /**\n     * A reference to the canvas render target (we only need one as this can be shared across renderers)\n     *\n     * @private\n     * @member {object<number, WebGLTexture>}\n     */\n    _this._canvasRenderTarget = null;\n\n    /**\n     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n     *\n     * @member {boolean}\n     */\n    _this.valid = false;\n    return _this;\n  }\n\n  /**\n   * Resizes the BaseRenderTexture.\n   *\n   * @param {number} width - The width to resize to.\n   * @param {number} height - The height to resize to.\n   */\n\n  BaseRenderTexture.prototype.resize = function resize(width, height) {\n    width = Math.ceil(width);\n    height = Math.ceil(height);\n    if (width === this.width && height === this.height) {\n      return;\n    }\n    this.valid = width > 0 && height > 0;\n    this.width = width;\n    this.height = height;\n    this.realWidth = this.width * this.resolution;\n    this.realHeight = this.height * this.resolution;\n    if (!this.valid) {\n      return;\n    }\n    this.emit('update', this);\n  };\n\n  /**\n   * Destroys this texture\n   *\n   */\n\n  BaseRenderTexture.prototype.destroy = function destroy() {\n    _BaseTexture.prototype.destroy.call(this, true);\n    this.renderer = null;\n  };\n  return BaseRenderTexture;\n}(_BaseTexture3.default);\nexports.default = BaseRenderTexture;","map":{"version":3,"names":["_BaseTexture2","require","_settings","BaseRenderTexture","width","arguments","length","undefined","height","scaleMode","resolution","_classCallCheck","_this","_possibleConstructorReturn","_BaseTexture","call","_settings2","default","RESOLUTION","Math","ceil","realWidth","realHeight","SCALE_MODE","hasLoaded","_glRenderTargets","_canvasRenderTarget","valid","resize","emit","destroy","prototype","renderer"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/textures/BaseRenderTexture.js"],"sourcesContent":["import BaseTexture from './BaseTexture';\nimport settings from '../settings';\n\n/**\n * A BaseRenderTexture is a special texture that allows any PixiJS display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a BaseRenderTexture should be preloaded\n * otherwise black rectangles will be drawn instead.\n *\n * A BaseRenderTexture takes a snapshot of any Display Object given to its render method. The position\n * and rotation of the given Display Objects is ignored. For example:\n *\n * ```js\n * let renderer = PIXI.autoDetectRenderer(1024, 1024);\n * let baseRenderTexture = new PIXI.BaseRenderTexture(800, 600);\n * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);\n * let sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *\n * sprite.position.x = 800/2;\n * sprite.position.y = 600/2;\n * sprite.anchor.x = 0.5;\n * sprite.anchor.y = 0.5;\n *\n * renderer.render(sprite, renderTexture);\n * ```\n *\n * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0\n * you can clear the transform\n *\n * ```js\n *\n * sprite.setTransform()\n *\n * let baseRenderTexture = new PIXI.BaseRenderTexture(100, 100);\n * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);\n *\n * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture\n * ```\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n */\nexport default class BaseRenderTexture extends BaseTexture\n{\n    /**\n     * @param {number} [width=100] - The width of the base render texture\n     * @param {number} [height=100] - The height of the base render texture\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated\n     */\n    constructor(width = 100, height = 100, scaleMode, resolution)\n    {\n        super(null, scaleMode);\n\n        this.resolution = resolution || settings.RESOLUTION;\n\n        this.width = Math.ceil(width);\n        this.height = Math.ceil(height);\n\n        this.realWidth = this.width * this.resolution;\n        this.realHeight = this.height * this.resolution;\n\n        this.scaleMode = scaleMode !== undefined ? scaleMode : settings.SCALE_MODE;\n        this.hasLoaded = true;\n\n        /**\n         * A map of renderer IDs to webgl renderTargets\n         *\n         * @private\n         * @member {object<number, WebGLTexture>}\n         */\n        this._glRenderTargets = {};\n\n        /**\n         * A reference to the canvas render target (we only need one as this can be shared across renderers)\n         *\n         * @private\n         * @member {object<number, WebGLTexture>}\n         */\n        this._canvasRenderTarget = null;\n\n        /**\n         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n         *\n         * @member {boolean}\n         */\n        this.valid = false;\n    }\n\n    /**\n     * Resizes the BaseRenderTexture.\n     *\n     * @param {number} width - The width to resize to.\n     * @param {number} height - The height to resize to.\n     */\n    resize(width, height)\n    {\n        width = Math.ceil(width);\n        height = Math.ceil(height);\n\n        if (width === this.width && height === this.height)\n        {\n            return;\n        }\n\n        this.valid = (width > 0 && height > 0);\n\n        this.width = width;\n        this.height = height;\n\n        this.realWidth = this.width * this.resolution;\n        this.realHeight = this.height * this.resolution;\n\n        if (!this.valid)\n        {\n            return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /**\n     * Destroys this texture\n     *\n     */\n    destroy()\n    {\n        super.destroy(true);\n        this.renderer = null;\n    }\n}\n"],"mappings":";;;AAAA,IAAAA,aAAA,GAAAC,OAAA;;AACA,IAAAC,SAAA,GAAAD,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAwCqBE,iB;;;EAEjB;;;;;;EAMA,SAAAA,kBAAA,EACA;IAAA,IADYC,KACZ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MADoB,GACpB;IAAA,IADyBG,MACzB,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MADkC,GAClC;IAAA,IADuCI,SACvC,GAAAJ,SAAA;IAAA,IADkDK,UAClD,GAAAL,SAAA;IAAAM,eAAA,OAAAR,iBAAA;IAAA,IAAAS,KAAA,GAAAC,0BAAA,OACIC,YAAA,CAAAC,IAAA,OAAM,IAAN,EAAYN,SAAZ,CADJ;IAGIG,KAAA,CAAKF,UAAL,GAAkBA,UAAA,IAAcM,UAAA,CAAAC,OAAA,CAASC,UAAzC;IAEAN,KAAA,CAAKR,KAAL,GAAae,IAAA,CAAKC,IAAL,CAAUhB,KAAV,CAAb;IACAQ,KAAA,CAAKJ,MAAL,GAAcW,IAAA,CAAKC,IAAL,CAAUZ,MAAV,CAAd;IAEAI,KAAA,CAAKS,SAAL,GAAiBT,KAAA,CAAKR,KAAL,GAAaQ,KAAA,CAAKF,UAAnC;IACAE,KAAA,CAAKU,UAAL,GAAkBV,KAAA,CAAKJ,MAAL,GAAcI,KAAA,CAAKF,UAArC;IAEAE,KAAA,CAAKH,SAAL,GAAiBA,SAAA,KAAcF,SAAd,GAA0BE,SAA1B,GAAsCO,UAAA,CAAAC,OAAA,CAASM,UAAhE;IACAX,KAAA,CAAKY,SAAL,GAAiB,IAAjB;;IAEA;;;;;;IAMAZ,KAAA,CAAKa,gBAAL,GAAwB,EAAxB;;IAEA;;;;;;IAMAb,KAAA,CAAKc,mBAAL,GAA2B,IAA3B;;IAEA;;;;;IAKAd,KAAA,CAAKe,KAAL,GAAa,KAAb;IAnCJ,OAAAf,KAAA;EAoCC;;EAED;;;;;;;8BAMAgB,M,mBAAOxB,K,EAAOI,M,EACd;IACIJ,KAAA,GAAQe,IAAA,CAAKC,IAAL,CAAUhB,KAAV,CAAR;IACAI,MAAA,GAASW,IAAA,CAAKC,IAAL,CAAUZ,MAAV,CAAT;IAEA,IAAIJ,KAAA,KAAU,KAAKA,KAAf,IAAwBI,MAAA,KAAW,KAAKA,MAA5C,EACA;MACI;IACH;IAED,KAAKmB,KAAL,GAAcvB,KAAA,GAAQ,CAAR,IAAaI,MAAA,GAAS,CAApC;IAEA,KAAKJ,KAAL,GAAaA,KAAb;IACA,KAAKI,MAAL,GAAcA,MAAd;IAEA,KAAKa,SAAL,GAAiB,KAAKjB,KAAL,GAAa,KAAKM,UAAnC;IACA,KAAKY,UAAL,GAAkB,KAAKd,MAAL,GAAc,KAAKE,UAArC;IAEA,IAAI,CAAC,KAAKiB,KAAV,EACA;MACI;IACH;IAED,KAAKE,IAAL,CAAU,QAAV,EAAoB,IAApB;EACH,C;;EAED;;;;;8BAIAC,O,sBACA;IACIhB,YAAA,CAAAiB,SAAA,CAAMD,OAAN,CAAAf,IAAA,OAAc,IAAd;IACA,KAAKiB,QAAL,GAAgB,IAAhB;EACH,C;;;kBAvFgB7B,iB"},"metadata":{},"sourceType":"script","externalDependencies":[]}