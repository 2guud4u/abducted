{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.eachSeries = eachSeries;\nexports.queue = queue;\n/**\n * Smaller version of the async library constructs.\n *\n * @namespace async\n */\n\n/**\n * Noop function\n *\n * @ignore\n * @function\n * @memberof async\n */\nfunction _noop() {} /* empty */\n\n/**\n * Iterates an array in series.\n *\n * @memberof async\n * @param {Array.<*>} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n */\nfunction eachSeries(array, iterator, callback, deferNext) {\n  var i = 0;\n  var len = array.length;\n  (function next(err) {\n    if (err || i === len) {\n      if (callback) {\n        callback(err);\n      }\n      return;\n    }\n    if (deferNext) {\n      setTimeout(function () {\n        iterator(array[i++], next);\n      }, 1);\n    } else {\n      iterator(array[i++], next);\n    }\n  })();\n}\n\n/**\n * Ensures a function is only called once.\n *\n * @ignore\n * @memberof async\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\nfunction onlyOnce(fn) {\n  return function onceWrapper() {\n    if (fn === null) {\n      throw new Error('Callback was already called.');\n    }\n    var callFn = fn;\n    fn = null;\n    callFn.apply(this, arguments);\n  };\n}\n\n/**\n * Async queue implementation,\n *\n * @memberof async\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\nfunction queue(worker, concurrency) {\n  if (concurrency == null) {\n    // eslint-disable-line no-eq-null,eqeqeq\n    concurrency = 1;\n  } else if (concurrency === 0) {\n    throw new Error('Concurrency must not be zero');\n  }\n  var workers = 0;\n  var q = {\n    _tasks: [],\n    concurrency: concurrency,\n    saturated: _noop,\n    unsaturated: _noop,\n    buffer: concurrency / 4,\n    empty: _noop,\n    drain: _noop,\n    error: _noop,\n    started: false,\n    paused: false,\n    push: function push(data, callback) {\n      _insert(data, false, callback);\n    },\n    kill: function kill() {\n      workers = 0;\n      q.drain = _noop;\n      q.started = false;\n      q._tasks = [];\n    },\n    unshift: function unshift(data, callback) {\n      _insert(data, true, callback);\n    },\n    process: function process() {\n      while (!q.paused && workers < q.concurrency && q._tasks.length) {\n        var task = q._tasks.shift();\n        if (q._tasks.length === 0) {\n          q.empty();\n        }\n        workers += 1;\n        if (workers === q.concurrency) {\n          q.saturated();\n        }\n        worker(task.data, onlyOnce(_next(task)));\n      }\n    },\n    length: function length() {\n      return q._tasks.length;\n    },\n    running: function running() {\n      return workers;\n    },\n    idle: function idle() {\n      return q._tasks.length + workers === 0;\n    },\n    pause: function pause() {\n      if (q.paused === true) {\n        return;\n      }\n      q.paused = true;\n    },\n    resume: function resume() {\n      if (q.paused === false) {\n        return;\n      }\n      q.paused = false;\n\n      // Need to call q.process once per concurrent\n      // worker to preserve full concurrency after pause\n      for (var w = 1; w <= q.concurrency; w++) {\n        q.process();\n      }\n    }\n  };\n  function _insert(data, insertAtFront, callback) {\n    if (callback != null && typeof callback !== 'function') {\n      // eslint-disable-line no-eq-null,eqeqeq\n      throw new Error('task callback must be a function');\n    }\n    q.started = true;\n    if (data == null && q.idle()) {\n      // eslint-disable-line no-eq-null,eqeqeq\n      // call drain immediately if there are no tasks\n      setTimeout(function () {\n        return q.drain();\n      }, 1);\n      return;\n    }\n    var item = {\n      data: data,\n      callback: typeof callback === 'function' ? callback : _noop\n    };\n    if (insertAtFront) {\n      q._tasks.unshift(item);\n    } else {\n      q._tasks.push(item);\n    }\n    setTimeout(function () {\n      return q.process();\n    }, 1);\n  }\n  function _next(task) {\n    return function next() {\n      workers -= 1;\n      task.callback.apply(task, arguments);\n      if (arguments[0] != null) {\n        // eslint-disable-line no-eq-null,eqeqeq\n        q.error(arguments[0], task.data);\n      }\n      if (workers <= q.concurrency - q.buffer) {\n        q.unsaturated();\n      }\n      if (q.idle()) {\n        q.drain();\n      }\n      q.process();\n    };\n  }\n  return q;\n}","map":{"version":3,"names":["eachSeries","queue","_noop","array","iterator","callback","deferNext","i","len","length","next","err","setTimeout","onlyOnce","fn","onceWrapper","Error","callFn","apply","arguments","worker","concurrency","workers","q","_tasks","saturated","unsaturated","buffer","empty","drain","error","started","paused","push","data","_insert","kill","unshift","process","task","shift","_next","running","idle","pause","resume","w","insertAtFront","item"],"sources":["/Users/jiahuajiang/node_modules/resource-loader/src/async.js"],"sourcesContent":["/**\n * Smaller version of the async library constructs.\n *\n * @namespace async\n */\n\n/**\n * Noop function\n *\n * @ignore\n * @function\n * @memberof async\n */\nfunction _noop() { /* empty */ }\n\n/**\n * Iterates an array in series.\n *\n * @memberof async\n * @param {Array.<*>} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n */\nexport function eachSeries(array, iterator, callback, deferNext) {\n    let i = 0;\n    const len = array.length;\n\n    (function next(err) {\n        if (err || i === len) {\n            if (callback) {\n                callback(err);\n            }\n\n            return;\n        }\n\n        if (deferNext) {\n            setTimeout(() => {\n                iterator(array[i++], next);\n            }, 1);\n        }\n        else {\n            iterator(array[i++], next);\n        }\n    })();\n}\n\n/**\n * Ensures a function is only called once.\n *\n * @ignore\n * @memberof async\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\nfunction onlyOnce(fn) {\n    return function onceWrapper() {\n        if (fn === null) {\n            throw new Error('Callback was already called.');\n        }\n\n        const callFn = fn;\n\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\n/**\n * Async queue implementation,\n *\n * @memberof async\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\nexport function queue(worker, concurrency) {\n    if (concurrency == null) { // eslint-disable-line no-eq-null,eqeqeq\n        concurrency = 1;\n    }\n    else if (concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    let workers = 0;\n    const q = {\n        _tasks: [],\n        concurrency,\n        saturated: _noop,\n        unsaturated: _noop,\n        buffer: concurrency / 4,\n        empty: _noop,\n        drain: _noop,\n        error: _noop,\n        started: false,\n        paused: false,\n        push(data, callback) {\n            _insert(data, false, callback);\n        },\n        kill() {\n            workers = 0;\n            q.drain = _noop;\n            q.started = false;\n            q._tasks = [];\n        },\n        unshift(data, callback) {\n            _insert(data, true, callback);\n        },\n        process() {\n            while (!q.paused && workers < q.concurrency && q._tasks.length) {\n                const task = q._tasks.shift();\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                workers += 1;\n\n                if (workers === q.concurrency) {\n                    q.saturated();\n                }\n\n                worker(task.data, onlyOnce(_next(task)));\n            }\n        },\n        length() {\n            return q._tasks.length;\n        },\n        running() {\n            return workers;\n        },\n        idle() {\n            return q._tasks.length + workers === 0;\n        },\n        pause() {\n            if (q.paused === true) {\n                return;\n            }\n\n            q.paused = true;\n        },\n        resume() {\n            if (q.paused === false) {\n                return;\n            }\n\n            q.paused = false;\n\n            // Need to call q.process once per concurrent\n            // worker to preserve full concurrency after pause\n            for (let w = 1; w <= q.concurrency; w++) {\n                q.process();\n            }\n        },\n    };\n\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') { // eslint-disable-line no-eq-null,eqeqeq\n            throw new Error('task callback must be a function');\n        }\n\n        q.started = true;\n\n        if (data == null && q.idle()) { // eslint-disable-line no-eq-null,eqeqeq\n            // call drain immediately if there are no tasks\n            setTimeout(() => q.drain(), 1);\n\n            return;\n        }\n\n        const item = {\n            data,\n            callback: typeof callback === 'function' ? callback : _noop,\n        };\n\n        if (insertAtFront) {\n            q._tasks.unshift(item);\n        }\n        else {\n            q._tasks.push(item);\n        }\n\n        setTimeout(() => q.process(), 1);\n    }\n\n    function _next(task) {\n        return function next() {\n            workers -= 1;\n\n            task.callback.apply(task, arguments);\n\n            if (arguments[0] != null) { // eslint-disable-line no-eq-null,eqeqeq\n                q.error(arguments[0], task.data);\n            }\n\n            if (workers <= (q.concurrency - q.buffer)) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n\n            q.process();\n        };\n    }\n\n    return q;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}