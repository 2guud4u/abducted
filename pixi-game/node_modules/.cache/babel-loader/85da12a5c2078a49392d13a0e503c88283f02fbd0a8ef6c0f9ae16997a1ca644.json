{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _SystemRenderer2 = require('../SystemRenderer');\nvar _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);\nvar _MaskManager = require('./managers/MaskManager');\nvar _MaskManager2 = _interopRequireDefault(_MaskManager);\nvar _StencilManager = require('./managers/StencilManager');\nvar _StencilManager2 = _interopRequireDefault(_StencilManager);\nvar _FilterManager = require('./managers/FilterManager');\nvar _FilterManager2 = _interopRequireDefault(_FilterManager);\nvar _RenderTarget = require('./utils/RenderTarget');\nvar _RenderTarget2 = _interopRequireDefault(_RenderTarget);\nvar _ObjectRenderer = require('./utils/ObjectRenderer');\nvar _ObjectRenderer2 = _interopRequireDefault(_ObjectRenderer);\nvar _TextureManager = require('./TextureManager');\nvar _TextureManager2 = _interopRequireDefault(_TextureManager);\nvar _BaseTexture = require('../../textures/BaseTexture');\nvar _BaseTexture2 = _interopRequireDefault(_BaseTexture);\nvar _TextureGarbageCollector = require('./TextureGarbageCollector');\nvar _TextureGarbageCollector2 = _interopRequireDefault(_TextureGarbageCollector);\nvar _WebGLState = require('./WebGLState');\nvar _WebGLState2 = _interopRequireDefault(_WebGLState);\nvar _mapWebGLDrawModesToPixi = require('./utils/mapWebGLDrawModesToPixi');\nvar _mapWebGLDrawModesToPixi2 = _interopRequireDefault(_mapWebGLDrawModesToPixi);\nvar _validateContext = require('./utils/validateContext');\nvar _validateContext2 = _interopRequireDefault(_validateContext);\nvar _utils = require('../../utils');\nvar _pixiGlCore = require('pixi-gl-core');\nvar _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);\nvar _const = require('../../const');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar CONTEXT_UID = 0;\n\n/**\n * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\n\nvar WebGLRenderer = function (_SystemRenderer) {\n  _inherits(WebGLRenderer, _SystemRenderer);\n\n  // eslint-disable-next-line valid-jsdoc\n  /**\n   *\n   * @param {object} [options] - The optional renderer parameters\n   * @param {number} [options.width=800] - the width of the screen\n   * @param {number} [options.height=600] - the height of the screen\n   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n   * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n   * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA\n   *  antialiasing is used\n   * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.\n   *  FXAA is faster, but may not always look as great\n   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.\n   *  The resolution of the renderer retina would be 2.\n   * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear\n   *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set\n   *  preserveDrawingBuffer to `true`.\n   * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n   *  enable this if you need to call toDataUrl on the webgl context.\n   * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when\n   *  rendering, stopping pixel interpolation.\n   * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n   *  (shown if not transparent).\n   * @param {boolean} [options.legacy=false] - If true PixiJS will aim to ensure compatibility\n   *  with older / less advanced devices. If you experience unexplained flickering try setting this to true.\n   * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to \"high-performance\"\n   *  for devices with dual graphics card\n   */\n  function WebGLRenderer(options, arg2, arg3) {\n    _classCallCheck(this, WebGLRenderer);\n    var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'WebGL', options, arg2, arg3));\n    _this.legacy = _this.options.legacy;\n    if (_this.legacy) {\n      _pixiGlCore2.default.VertexArrayObject.FORCE_NATIVE = true;\n    }\n\n    /**\n     * The type of this renderer as a standardised const\n     *\n     * @member {number}\n     * @see PIXI.RENDERER_TYPE\n     */\n    _this.type = _const.RENDERER_TYPE.WEBGL;\n    _this.handleContextLost = _this.handleContextLost.bind(_this);\n    _this.handleContextRestored = _this.handleContextRestored.bind(_this);\n    _this.view.addEventListener('webglcontextlost', _this.handleContextLost, false);\n    _this.view.addEventListener('webglcontextrestored', _this.handleContextRestored, false);\n\n    /**\n     * The options passed in to create a new webgl context.\n     *\n     * @member {object}\n     * @private\n     */\n    _this._contextOptions = {\n      alpha: _this.transparent,\n      antialias: _this.options.antialias,\n      premultipliedAlpha: _this.transparent && _this.transparent !== 'notMultiplied',\n      stencil: true,\n      preserveDrawingBuffer: _this.options.preserveDrawingBuffer,\n      powerPreference: _this.options.powerPreference\n    };\n    _this._backgroundColorRgba[3] = _this.transparent ? 0 : 1;\n\n    /**\n     * Manages the masks using the stencil buffer.\n     *\n     * @member {PIXI.MaskManager}\n     */\n    _this.maskManager = new _MaskManager2.default(_this);\n\n    /**\n     * Manages the stencil buffer.\n     *\n     * @member {PIXI.StencilManager}\n     */\n    _this.stencilManager = new _StencilManager2.default(_this);\n\n    /**\n     * An empty renderer.\n     *\n     * @member {PIXI.ObjectRenderer}\n     */\n    _this.emptyRenderer = new _ObjectRenderer2.default(_this);\n\n    /**\n     * The currently active ObjectRenderer.\n     *\n     * @member {PIXI.ObjectRenderer}\n     */\n    _this.currentRenderer = _this.emptyRenderer;\n\n    /**\n     * Manages textures\n     * @member {PIXI.TextureManager}\n     */\n    _this.textureManager = null;\n\n    /**\n     * Manages the filters.\n     *\n     * @member {PIXI.FilterManager}\n     */\n    _this.filterManager = null;\n    _this.initPlugins();\n\n    /**\n     * The current WebGL rendering context, it is created here\n     *\n     * @member {WebGLRenderingContext}\n     */\n    // initialize the context so it is ready for the managers.\n    if (_this.options.context) {\n      // checks to see if a context is valid..\n      (0, _validateContext2.default)(_this.options.context);\n    }\n    _this.gl = _this.options.context || _pixiGlCore2.default.createContext(_this.view, _this._contextOptions);\n    _this.CONTEXT_UID = CONTEXT_UID++;\n\n    /**\n     * The currently active ObjectRenderer.\n     *\n     * @member {PIXI.WebGLState}\n     */\n    _this.state = new _WebGLState2.default(_this.gl);\n    _this.renderingToScreen = true;\n\n    /**\n     * Holds the current state of textures bound to the GPU.\n     * @type {Array}\n     */\n    _this.boundTextures = null;\n\n    /**\n     * Holds the current shader\n     *\n     * @member {PIXI.Shader}\n     */\n    _this._activeShader = null;\n    _this._activeVao = null;\n\n    /**\n     * Holds the current render target\n     *\n     * @member {PIXI.RenderTarget}\n     */\n    _this._activeRenderTarget = null;\n    _this._initContext();\n\n    // map some webGL blend and drawmodes..\n    _this.drawModes = (0, _mapWebGLDrawModesToPixi2.default)(_this.gl);\n    _this._nextTextureLocation = 0;\n    _this.setBlendMode(0);\n\n    /**\n     * Fired after rendering finishes.\n     *\n     * @event PIXI.WebGLRenderer#postrender\n     */\n\n    /**\n     * Fired before rendering starts.\n     *\n     * @event PIXI.WebGLRenderer#prerender\n     */\n\n    /**\n     * Fired when the WebGL context is set.\n     *\n     * @event PIXI.WebGLRenderer#context\n     * @param {WebGLRenderingContext} gl - WebGL context.\n     */\n    return _this;\n  }\n\n  /**\n   * Creates the WebGL context\n   *\n   * @private\n   */\n\n  WebGLRenderer.prototype._initContext = function _initContext() {\n    var gl = this.gl;\n\n    // restore a context if it was previously lost\n    if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {\n      gl.getExtension('WEBGL_lose_context').restoreContext();\n    }\n    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this._activeShader = null;\n    this._activeVao = null;\n    this.boundTextures = new Array(maxTextures);\n    this.emptyTextures = new Array(maxTextures);\n\n    /**\n     * Did someone temper with textures state? We'll overwrite them when we need to unbind something.\n     * @member {boolean}\n     * @private\n     */\n    this._unknownBoundTextures = false;\n\n    // create a texture manager...\n    this.textureManager = new _TextureManager2.default(this);\n    this.filterManager = new _FilterManager2.default(this);\n    this.textureGC = new _TextureGarbageCollector2.default(this);\n    this.state.resetToDefault();\n    this.rootRenderTarget = new _RenderTarget2.default(gl, this.width, this.height, null, this.resolution, true);\n    this.rootRenderTarget.clearColor = this._backgroundColorRgba;\n    this.bindRenderTarget(this.rootRenderTarget);\n\n    // now lets fill up the textures with empty ones!\n    var emptyGLTexture = new _pixiGlCore2.default.GLTexture.fromData(gl, null, 1, 1);\n    var tempObj = {\n      _glTextures: {}\n    };\n    tempObj._glTextures[this.CONTEXT_UID] = {};\n    for (var i = 0; i < maxTextures; i++) {\n      var empty = new _BaseTexture2.default();\n      empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;\n      this.boundTextures[i] = tempObj;\n      this.emptyTextures[i] = empty;\n      this.bindTexture(null, i);\n    }\n    this.emit('context', gl);\n\n    // setup the width/height properties and gl viewport\n    this.resize(this.screen.width, this.screen.height);\n  };\n\n  /**\n   * Renders the object to its webGL view\n   *\n   * @param {PIXI.DisplayObject} displayObject - the object to be rendered\n   * @param {PIXI.RenderTexture} renderTexture - The render texture to render to.\n   * @param {boolean} [clear] - Should the canvas be cleared before the new render\n   * @param {PIXI.Matrix} [transform] - A transform to apply to the render texture before rendering.\n   * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?\n   */\n\n  WebGLRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {\n    // can be handy to know!\n    this.renderingToScreen = !renderTexture;\n    this.emit('prerender');\n\n    // no point rendering if our context has been blown up!\n    if (!this.gl || this.gl.isContextLost()) {\n      return;\n    }\n    this._nextTextureLocation = 0;\n    if (!renderTexture) {\n      this._lastObjectRendered = displayObject;\n    }\n    if (!skipUpdateTransform) {\n      // update the scene graph\n      var cacheParent = displayObject.parent;\n      displayObject.parent = this._tempDisplayObjectParent;\n      displayObject.updateTransform();\n      displayObject.parent = cacheParent;\n      // displayObject.hitArea = //TODO add a temp hit area\n    }\n\n    this.bindRenderTexture(renderTexture, transform);\n    this.currentRenderer.start();\n    if (clear !== undefined ? clear : this.clearBeforeRender) {\n      this._activeRenderTarget.clear();\n    }\n    displayObject.renderWebGL(this);\n\n    // apply transform..\n    this.currentRenderer.flush();\n\n    // this.setObjectRenderer(this.emptyRenderer);\n\n    this.textureGC.update();\n    this.emit('postrender');\n  };\n\n  /**\n   * Changes the current renderer to the one given in parameter\n   *\n   * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.\n   */\n\n  WebGLRenderer.prototype.setObjectRenderer = function setObjectRenderer(objectRenderer) {\n    if (this.currentRenderer === objectRenderer) {\n      return;\n    }\n    this.currentRenderer.stop();\n    this.currentRenderer = objectRenderer;\n    this.currentRenderer.start();\n  };\n\n  /**\n   * This should be called if you wish to do some custom rendering\n   * It will basically render anything that may be batched up such as sprites\n   *\n   */\n\n  WebGLRenderer.prototype.flush = function flush() {\n    this.setObjectRenderer(this.emptyRenderer);\n  };\n\n  /**\n   * Resizes the webGL view to the specified width and height.\n   *\n   * @param {number} screenWidth - the new width of the screen\n   * @param {number} screenHeight - the new height of the screen\n   */\n\n  WebGLRenderer.prototype.resize = function resize(screenWidth, screenHeight) {\n    //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;\n\n    _SystemRenderer3.default.prototype.resize.call(this, screenWidth, screenHeight);\n    this.rootRenderTarget.resize(screenWidth, screenHeight);\n    if (this._activeRenderTarget === this.rootRenderTarget) {\n      this.rootRenderTarget.activate();\n      if (this._activeShader) {\n        this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);\n      }\n    }\n  };\n\n  /**\n   * Resizes the webGL view to the specified width and height.\n   *\n   * @param {number} blendMode - the desired blend mode\n   */\n\n  WebGLRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {\n    this.state.setBlendMode(blendMode);\n  };\n\n  /**\n   * Erases the active render target and fills the drawing area with a colour\n   *\n   * @param {number} [clearColor] - The colour\n   */\n\n  WebGLRenderer.prototype.clear = function clear(clearColor) {\n    this._activeRenderTarget.clear(clearColor);\n  };\n\n  /**\n   * Sets the transform of the active render target to the given matrix\n   *\n   * @param {PIXI.Matrix} matrix - The transformation matrix\n   */\n\n  WebGLRenderer.prototype.setTransform = function setTransform(matrix) {\n    this._activeRenderTarget.transform = matrix;\n  };\n\n  /**\n   * Erases the render texture and fills the drawing area with a colour\n   *\n   * @param {PIXI.RenderTexture} renderTexture - The render texture to clear\n   * @param {number} [clearColor] - The colour\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n  WebGLRenderer.prototype.clearRenderTexture = function clearRenderTexture(renderTexture, clearColor) {\n    var baseTexture = renderTexture.baseTexture;\n    var renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n    if (renderTarget) {\n      renderTarget.clear(clearColor);\n    }\n    return this;\n  };\n\n  /**\n   * Binds a render texture for rendering\n   *\n   * @param {PIXI.RenderTexture} renderTexture - The render texture to render\n   * @param {PIXI.Matrix} transform - The transform to be applied to the render texture\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n  WebGLRenderer.prototype.bindRenderTexture = function bindRenderTexture(renderTexture, transform) {\n    var renderTarget = void 0;\n    if (renderTexture) {\n      var baseTexture = renderTexture.baseTexture;\n      if (!baseTexture._glRenderTargets[this.CONTEXT_UID]) {\n        // bind the current texture\n        this.textureManager.updateTexture(baseTexture, 0);\n      }\n      this.unbindTexture(baseTexture);\n      renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n      renderTarget.setFrame(renderTexture.frame);\n    } else {\n      renderTarget = this.rootRenderTarget;\n    }\n    renderTarget.transform = transform;\n    this.bindRenderTarget(renderTarget);\n    return this;\n  };\n\n  /**\n   * Changes the current render target to the one given in parameter\n   *\n   * @param {PIXI.RenderTarget} renderTarget - the new render target\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n  WebGLRenderer.prototype.bindRenderTarget = function bindRenderTarget(renderTarget) {\n    if (renderTarget !== this._activeRenderTarget) {\n      this._activeRenderTarget = renderTarget;\n      renderTarget.activate();\n      if (this._activeShader) {\n        this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);\n      }\n      this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);\n    }\n    return this;\n  };\n\n  /**\n   * Changes the current shader to the one given in parameter\n   *\n   * @param {PIXI.Shader} shader - the new shader\n   * @param {boolean} [autoProject=true] - Whether automatically set the projection matrix\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n  WebGLRenderer.prototype.bindShader = function bindShader(shader, autoProject) {\n    // TODO cache\n    if (this._activeShader !== shader) {\n      this._activeShader = shader;\n      shader.bind();\n\n      // `autoProject` normally would be a default parameter set to true\n      // but because of how Babel transpiles default parameters\n      // it hinders the performance of this method.\n      if (autoProject !== false) {\n        // automatically set the projection matrix\n        shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Binds the texture. This will return the location of the bound texture.\n   * It may not be the same as the one you pass in. This is due to optimisation that prevents\n   * needless binding of textures. For example if the texture is already bound it will return the\n   * current location of the texture instead of the one provided. To bypass this use force location\n   *\n   * @param {PIXI.Texture} texture - the new texture\n   * @param {number} location - the suggested texture location\n   * @param {boolean} forceLocation - force the location\n   * @return {number} bound texture location\n   */\n\n  WebGLRenderer.prototype.bindTexture = function bindTexture(texture, location, forceLocation) {\n    texture = texture || this.emptyTextures[location];\n    texture = texture.baseTexture || texture;\n    texture.touched = this.textureGC.count;\n    if (!forceLocation) {\n      // TODO - maybe look into adding boundIds.. save us the loop?\n      for (var i = 0; i < this.boundTextures.length; i++) {\n        if (this.boundTextures[i] === texture) {\n          return i;\n        }\n      }\n      if (location === undefined) {\n        this._nextTextureLocation++;\n        this._nextTextureLocation %= this.boundTextures.length;\n        location = this.boundTextures.length - this._nextTextureLocation - 1;\n      }\n    } else {\n      location = location || 0;\n    }\n    var gl = this.gl;\n    var glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) {\n      // this will also bind the texture..\n      this.textureManager.updateTexture(texture, location);\n    } else {\n      // bind the current texture\n      this.boundTextures[location] = texture;\n      gl.activeTexture(gl.TEXTURE0 + location);\n      gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    }\n    return location;\n  };\n\n  /**\n  * unbinds the texture ...\n  *\n  * @param {PIXI.Texture} texture - the texture to unbind\n  * @return {PIXI.WebGLRenderer} Returns itself.\n  */\n\n  WebGLRenderer.prototype.unbindTexture = function unbindTexture(texture) {\n    var gl = this.gl;\n    texture = texture.baseTexture || texture;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = false;\n      // someone changed webGL state,\n      // we have to be sure that our texture does not appear in multitexture renderer samplers\n\n      for (var i = 0; i < this.boundTextures.length; i++) {\n        if (this.boundTextures[i] === this.emptyTextures[i]) {\n          gl.activeTexture(gl.TEXTURE0 + i);\n          gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);\n        }\n      }\n    }\n    for (var _i = 0; _i < this.boundTextures.length; _i++) {\n      if (this.boundTextures[_i] === texture) {\n        this.boundTextures[_i] = this.emptyTextures[_i];\n        gl.activeTexture(gl.TEXTURE0 + _i);\n        gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[_i]._glTextures[this.CONTEXT_UID].texture);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Creates a new VAO from this renderer's context and state.\n   *\n   * @return {VertexArrayObject} The new VAO.\n   */\n\n  WebGLRenderer.prototype.createVao = function createVao() {\n    return new _pixiGlCore2.default.VertexArrayObject(this.gl, this.state.attribState);\n  };\n\n  /**\n   * Changes the current Vao to the one given in parameter\n   *\n   * @param {PIXI.VertexArrayObject} vao - the new Vao\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n  WebGLRenderer.prototype.bindVao = function bindVao(vao) {\n    if (this._activeVao === vao) {\n      return this;\n    }\n    if (vao) {\n      vao.bind();\n    } else if (this._activeVao) {\n      // TODO this should always be true i think?\n      this._activeVao.unbind();\n    }\n    this._activeVao = vao;\n    return this;\n  };\n\n  /**\n   * Resets the WebGL state so you can render things however you fancy!\n   *\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n  WebGLRenderer.prototype.reset = function reset() {\n    this.setObjectRenderer(this.emptyRenderer);\n    this.bindVao(null);\n    this._activeShader = null;\n    this._activeRenderTarget = this.rootRenderTarget;\n    this._unknownBoundTextures = true;\n    for (var i = 0; i < this.boundTextures.length; i++) {\n      this.boundTextures[i] = this.emptyTextures[i];\n    }\n\n    // bind the main frame buffer (the screen);\n    this.rootRenderTarget.activate();\n    this.state.resetToDefault();\n    return this;\n  };\n\n  /**\n   * Handles a lost webgl context\n   *\n   * @private\n   * @param {WebGLContextEvent} event - The context lost event.\n   */\n\n  WebGLRenderer.prototype.handleContextLost = function handleContextLost(event) {\n    event.preventDefault();\n  };\n\n  /**\n   * Handles a restored webgl context\n   *\n   * @private\n   */\n\n  WebGLRenderer.prototype.handleContextRestored = function handleContextRestored() {\n    this.textureManager.removeAll();\n    this.filterManager.destroy(true);\n    this._initContext();\n  };\n\n  /**\n   * Removes everything from the renderer (event listeners, spritebatch, etc...)\n   *\n   * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n   *  See: https://github.com/pixijs/pixi.js/issues/2233\n   */\n\n  WebGLRenderer.prototype.destroy = function destroy(removeView) {\n    this.destroyPlugins();\n\n    // remove listeners\n    this.view.removeEventListener('webglcontextlost', this.handleContextLost);\n    this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);\n    this.textureManager.destroy();\n\n    // call base destroy\n    _SystemRenderer.prototype.destroy.call(this, removeView);\n    this.uid = 0;\n\n    // destroy the managers\n    this.maskManager.destroy();\n    this.stencilManager.destroy();\n    this.filterManager.destroy();\n    this.maskManager = null;\n    this.filterManager = null;\n    this.textureManager = null;\n    this.currentRenderer = null;\n    this.handleContextLost = null;\n    this.handleContextRestored = null;\n    this._contextOptions = null;\n    this.gl.useProgram(null);\n    if (this.gl.getExtension('WEBGL_lose_context')) {\n      this.gl.getExtension('WEBGL_lose_context').loseContext();\n    }\n    this.gl = null;\n\n    // this = null;\n  };\n\n  return WebGLRenderer;\n}(_SystemRenderer3.default);\n\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.WebGLRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.WebGLExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.WebGLPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.WebGLRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\nexports.default = WebGLRenderer;\n_utils.pluginTarget.mixin(WebGLRenderer);","map":{"version":3,"names":["_SystemRenderer2","require","_MaskManager","_StencilManager","_FilterManager","_RenderTarget","_ObjectRenderer","_TextureManager","_BaseTexture","_TextureGarbageCollector","_WebGLState","_mapWebGLDrawModesToPixi","_validateContext","_utils","_pixiGlCore","_const","CONTEXT_UID","WebGLRenderer","options","arg2","arg3","_classCallCheck","_this","_possibleConstructorReturn","_SystemRenderer","call","legacy","_pixiGlCore2","default","VertexArrayObject","FORCE_NATIVE","type","RENDERER_TYPE","WEBGL","handleContextLost","bind","handleContextRestored","view","addEventListener","_contextOptions","alpha","transparent","antialias","premultipliedAlpha","stencil","preserveDrawingBuffer","powerPreference","_backgroundColorRgba","maskManager","_MaskManager2","stencilManager","_StencilManager2","emptyRenderer","_ObjectRenderer2","currentRenderer","textureManager","filterManager","initPlugins","context","_validateContext2","gl","createContext","state","_WebGLState2","renderingToScreen","boundTextures","_activeShader","_activeVao","_activeRenderTarget","_initContext","drawModes","_mapWebGLDrawModesToPixi2","_nextTextureLocation","setBlendMode","isContextLost","getExtension","restoreContext","maxTextures","getParameter","MAX_TEXTURE_IMAGE_UNITS","Array","emptyTextures","_unknownBoundTextures","_TextureManager2","_FilterManager2","textureGC","_TextureGarbageCollector2","resetToDefault","rootRenderTarget","_RenderTarget2","width","height","resolution","clearColor","bindRenderTarget","emptyGLTexture","GLTexture","fromData","tempObj","_glTextures","i","empty","_BaseTexture2","bindTexture","emit","resize","screen","render","displayObject","renderTexture","clear","transform","skipUpdateTransform","_lastObjectRendered","cacheParent","parent","_tempDisplayObjectParent","updateTransform","bindRenderTexture","start","undefined","clearBeforeRender","renderWebGL","flush","update","setObjectRenderer","objectRenderer","stop","screenWidth","screenHeight","_SystemRenderer3","prototype","activate","uniforms","projectionMatrix","toArray","blendMode","setTransform","matrix","clearRenderTexture","baseTexture","renderTarget","_glRenderTargets","updateTexture","unbindTexture","setFrame","frame","setMaskStack","stencilMaskStack","bindShader","shader","autoProject","texture","location","forceLocation","touched","count","length","glTexture","activeTexture","TEXTURE0","TEXTURE_2D","_i","createVao","attribState","bindVao","vao","unbind","reset","event","preventDefault","removeAll","destroy","removeView","destroyPlugins","removeEventListener","uid","useProgram","loseContext","pluginTarget","mixin"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/renderers/webgl/WebGLRenderer.js"],"sourcesContent":["import SystemRenderer from '../SystemRenderer';\nimport MaskManager from './managers/MaskManager';\nimport StencilManager from './managers/StencilManager';\nimport FilterManager from './managers/FilterManager';\nimport RenderTarget from './utils/RenderTarget';\nimport ObjectRenderer from './utils/ObjectRenderer';\nimport TextureManager from './TextureManager';\nimport BaseTexture from '../../textures/BaseTexture';\nimport TextureGarbageCollector from './TextureGarbageCollector';\nimport WebGLState from './WebGLState';\nimport mapWebGLDrawModesToPixi from './utils/mapWebGLDrawModesToPixi';\nimport validateContext from './utils/validateContext';\nimport { pluginTarget } from '../../utils';\nimport glCore from 'pixi-gl-core';\nimport { RENDERER_TYPE } from '../../const';\n\nlet CONTEXT_UID = 0;\n\n/**\n * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\nexport default class WebGLRenderer extends SystemRenderer\n{\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     *\n     * @param {object} [options] - The optional renderer parameters\n     * @param {number} [options.width=800] - the width of the screen\n     * @param {number} [options.height=600] - the height of the screen\n     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n     * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA\n     *  antialiasing is used\n     * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.\n     *  FXAA is faster, but may not always look as great\n     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.\n     *  The resolution of the renderer retina would be 2.\n     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear\n     *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set\n     *  preserveDrawingBuffer to `true`.\n     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n     *  enable this if you need to call toDataUrl on the webgl context.\n     * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when\n     *  rendering, stopping pixel interpolation.\n     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n     *  (shown if not transparent).\n     * @param {boolean} [options.legacy=false] - If true PixiJS will aim to ensure compatibility\n     *  with older / less advanced devices. If you experience unexplained flickering try setting this to true.\n     * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to \"high-performance\"\n     *  for devices with dual graphics card\n     */\n    constructor(options, arg2, arg3)\n    {\n        super('WebGL', options, arg2, arg3);\n\n        this.legacy = this.options.legacy;\n\n        if (this.legacy)\n        {\n            glCore.VertexArrayObject.FORCE_NATIVE = true;\n        }\n\n        /**\n         * The type of this renderer as a standardised const\n         *\n         * @member {number}\n         * @see PIXI.RENDERER_TYPE\n         */\n        this.type = RENDERER_TYPE.WEBGL;\n\n        this.handleContextLost = this.handleContextLost.bind(this);\n        this.handleContextRestored = this.handleContextRestored.bind(this);\n\n        this.view.addEventListener('webglcontextlost', this.handleContextLost, false);\n        this.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);\n\n        /**\n         * The options passed in to create a new webgl context.\n         *\n         * @member {object}\n         * @private\n         */\n        this._contextOptions = {\n            alpha: this.transparent,\n            antialias: this.options.antialias,\n            premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',\n            stencil: true,\n            preserveDrawingBuffer: this.options.preserveDrawingBuffer,\n            powerPreference: this.options.powerPreference,\n        };\n\n        this._backgroundColorRgba[3] = this.transparent ? 0 : 1;\n\n        /**\n         * Manages the masks using the stencil buffer.\n         *\n         * @member {PIXI.MaskManager}\n         */\n        this.maskManager = new MaskManager(this);\n\n        /**\n         * Manages the stencil buffer.\n         *\n         * @member {PIXI.StencilManager}\n         */\n        this.stencilManager = new StencilManager(this);\n\n        /**\n         * An empty renderer.\n         *\n         * @member {PIXI.ObjectRenderer}\n         */\n        this.emptyRenderer = new ObjectRenderer(this);\n\n        /**\n         * The currently active ObjectRenderer.\n         *\n         * @member {PIXI.ObjectRenderer}\n         */\n        this.currentRenderer = this.emptyRenderer;\n\n        /**\n         * Manages textures\n         * @member {PIXI.TextureManager}\n         */\n        this.textureManager = null;\n\n        /**\n         * Manages the filters.\n         *\n         * @member {PIXI.FilterManager}\n         */\n        this.filterManager = null;\n\n        this.initPlugins();\n\n        /**\n         * The current WebGL rendering context, it is created here\n         *\n         * @member {WebGLRenderingContext}\n         */\n        // initialize the context so it is ready for the managers.\n        if (this.options.context)\n        {\n            // checks to see if a context is valid..\n            validateContext(this.options.context);\n        }\n\n        this.gl = this.options.context || glCore.createContext(this.view, this._contextOptions);\n\n        this.CONTEXT_UID = CONTEXT_UID++;\n\n        /**\n         * The currently active ObjectRenderer.\n         *\n         * @member {PIXI.WebGLState}\n         */\n        this.state = new WebGLState(this.gl);\n\n        this.renderingToScreen = true;\n\n        /**\n         * Holds the current state of textures bound to the GPU.\n         * @type {Array}\n         */\n        this.boundTextures = null;\n\n        /**\n         * Holds the current shader\n         *\n         * @member {PIXI.Shader}\n         */\n        this._activeShader = null;\n\n        this._activeVao = null;\n\n        /**\n         * Holds the current render target\n         *\n         * @member {PIXI.RenderTarget}\n         */\n        this._activeRenderTarget = null;\n\n        this._initContext();\n\n        // map some webGL blend and drawmodes..\n        this.drawModes = mapWebGLDrawModesToPixi(this.gl);\n\n        this._nextTextureLocation = 0;\n\n        this.setBlendMode(0);\n\n        /**\n         * Fired after rendering finishes.\n         *\n         * @event PIXI.WebGLRenderer#postrender\n         */\n\n        /**\n         * Fired before rendering starts.\n         *\n         * @event PIXI.WebGLRenderer#prerender\n         */\n\n        /**\n         * Fired when the WebGL context is set.\n         *\n         * @event PIXI.WebGLRenderer#context\n         * @param {WebGLRenderingContext} gl - WebGL context.\n         */\n    }\n\n    /**\n     * Creates the WebGL context\n     *\n     * @private\n     */\n    _initContext()\n    {\n        const gl = this.gl;\n\n        // restore a context if it was previously lost\n        if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context'))\n        {\n            gl.getExtension('WEBGL_lose_context').restoreContext();\n        }\n\n        const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        this._activeShader = null;\n        this._activeVao = null;\n\n        this.boundTextures = new Array(maxTextures);\n        this.emptyTextures = new Array(maxTextures);\n\n        /**\n         * Did someone temper with textures state? We'll overwrite them when we need to unbind something.\n         * @member {boolean}\n         * @private\n         */\n        this._unknownBoundTextures = false;\n\n        // create a texture manager...\n        this.textureManager = new TextureManager(this);\n        this.filterManager = new FilterManager(this);\n        this.textureGC = new TextureGarbageCollector(this);\n\n        this.state.resetToDefault();\n\n        this.rootRenderTarget = new RenderTarget(gl, this.width, this.height, null, this.resolution, true);\n        this.rootRenderTarget.clearColor = this._backgroundColorRgba;\n\n        this.bindRenderTarget(this.rootRenderTarget);\n\n        // now lets fill up the textures with empty ones!\n        const emptyGLTexture = new glCore.GLTexture.fromData(gl, null, 1, 1);\n\n        const tempObj = { _glTextures: {} };\n\n        tempObj._glTextures[this.CONTEXT_UID] = {};\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            const empty = new BaseTexture();\n\n            empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;\n\n            this.boundTextures[i] = tempObj;\n            this.emptyTextures[i] = empty;\n            this.bindTexture(null, i);\n        }\n\n        this.emit('context', gl);\n\n        // setup the width/height properties and gl viewport\n        this.resize(this.screen.width, this.screen.height);\n    }\n\n    /**\n     * Renders the object to its webGL view\n     *\n     * @param {PIXI.DisplayObject} displayObject - the object to be rendered\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to render to.\n     * @param {boolean} [clear] - Should the canvas be cleared before the new render\n     * @param {PIXI.Matrix} [transform] - A transform to apply to the render texture before rendering.\n     * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?\n     */\n    render(displayObject, renderTexture, clear, transform, skipUpdateTransform)\n    {\n        // can be handy to know!\n        this.renderingToScreen = !renderTexture;\n\n        this.emit('prerender');\n\n        // no point rendering if our context has been blown up!\n        if (!this.gl || this.gl.isContextLost())\n        {\n            return;\n        }\n\n        this._nextTextureLocation = 0;\n\n        if (!renderTexture)\n        {\n            this._lastObjectRendered = displayObject;\n        }\n\n        if (!skipUpdateTransform)\n        {\n            // update the scene graph\n            const cacheParent = displayObject.parent;\n\n            displayObject.parent = this._tempDisplayObjectParent;\n            displayObject.updateTransform();\n            displayObject.parent = cacheParent;\n           // displayObject.hitArea = //TODO add a temp hit area\n        }\n\n        this.bindRenderTexture(renderTexture, transform);\n\n        this.currentRenderer.start();\n\n        if (clear !== undefined ? clear : this.clearBeforeRender)\n        {\n            this._activeRenderTarget.clear();\n        }\n\n        displayObject.renderWebGL(this);\n\n        // apply transform..\n        this.currentRenderer.flush();\n\n        // this.setObjectRenderer(this.emptyRenderer);\n\n        this.textureGC.update();\n\n        this.emit('postrender');\n    }\n\n    /**\n     * Changes the current renderer to the one given in parameter\n     *\n     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.\n     */\n    setObjectRenderer(objectRenderer)\n    {\n        if (this.currentRenderer === objectRenderer)\n        {\n            return;\n        }\n\n        this.currentRenderer.stop();\n        this.currentRenderer = objectRenderer;\n        this.currentRenderer.start();\n    }\n\n    /**\n     * This should be called if you wish to do some custom rendering\n     * It will basically render anything that may be batched up such as sprites\n     *\n     */\n    flush()\n    {\n        this.setObjectRenderer(this.emptyRenderer);\n    }\n\n    /**\n     * Resizes the webGL view to the specified width and height.\n     *\n     * @param {number} screenWidth - the new width of the screen\n     * @param {number} screenHeight - the new height of the screen\n     */\n    resize(screenWidth, screenHeight)\n    {\n      //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;\n\n        SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight);\n\n        this.rootRenderTarget.resize(screenWidth, screenHeight);\n\n        if (this._activeRenderTarget === this.rootRenderTarget)\n        {\n            this.rootRenderTarget.activate();\n\n            if (this._activeShader)\n            {\n                this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);\n            }\n        }\n    }\n\n    /**\n     * Resizes the webGL view to the specified width and height.\n     *\n     * @param {number} blendMode - the desired blend mode\n     */\n    setBlendMode(blendMode)\n    {\n        this.state.setBlendMode(blendMode);\n    }\n\n    /**\n     * Erases the active render target and fills the drawing area with a colour\n     *\n     * @param {number} [clearColor] - The colour\n     */\n    clear(clearColor)\n    {\n        this._activeRenderTarget.clear(clearColor);\n    }\n\n    /**\n     * Sets the transform of the active render target to the given matrix\n     *\n     * @param {PIXI.Matrix} matrix - The transformation matrix\n     */\n    setTransform(matrix)\n    {\n        this._activeRenderTarget.transform = matrix;\n    }\n\n    /**\n     * Erases the render texture and fills the drawing area with a colour\n     *\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to clear\n     * @param {number} [clearColor] - The colour\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    clearRenderTexture(renderTexture, clearColor)\n    {\n        const baseTexture = renderTexture.baseTexture;\n        const renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n\n        if (renderTarget)\n        {\n            renderTarget.clear(clearColor);\n        }\n\n        return this;\n    }\n\n    /**\n     * Binds a render texture for rendering\n     *\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to render\n     * @param {PIXI.Matrix} transform - The transform to be applied to the render texture\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindRenderTexture(renderTexture, transform)\n    {\n        let renderTarget;\n\n        if (renderTexture)\n        {\n            const baseTexture = renderTexture.baseTexture;\n\n            if (!baseTexture._glRenderTargets[this.CONTEXT_UID])\n            {\n                // bind the current texture\n                this.textureManager.updateTexture(baseTexture, 0);\n            }\n\n            this.unbindTexture(baseTexture);\n\n            renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n            renderTarget.setFrame(renderTexture.frame);\n        }\n        else\n        {\n            renderTarget = this.rootRenderTarget;\n        }\n\n        renderTarget.transform = transform;\n        this.bindRenderTarget(renderTarget);\n\n        return this;\n    }\n\n    /**\n     * Changes the current render target to the one given in parameter\n     *\n     * @param {PIXI.RenderTarget} renderTarget - the new render target\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindRenderTarget(renderTarget)\n    {\n        if (renderTarget !== this._activeRenderTarget)\n        {\n            this._activeRenderTarget = renderTarget;\n            renderTarget.activate();\n\n            if (this._activeShader)\n            {\n                this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);\n            }\n\n            this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);\n        }\n\n        return this;\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter\n     *\n     * @param {PIXI.Shader} shader - the new shader\n     * @param {boolean} [autoProject=true] - Whether automatically set the projection matrix\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindShader(shader, autoProject)\n    {\n        // TODO cache\n        if (this._activeShader !== shader)\n        {\n            this._activeShader = shader;\n            shader.bind();\n\n            // `autoProject` normally would be a default parameter set to true\n            // but because of how Babel transpiles default parameters\n            // it hinders the performance of this method.\n            if (autoProject !== false)\n            {\n                // automatically set the projection matrix\n                shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Binds the texture. This will return the location of the bound texture.\n     * It may not be the same as the one you pass in. This is due to optimisation that prevents\n     * needless binding of textures. For example if the texture is already bound it will return the\n     * current location of the texture instead of the one provided. To bypass this use force location\n     *\n     * @param {PIXI.Texture} texture - the new texture\n     * @param {number} location - the suggested texture location\n     * @param {boolean} forceLocation - force the location\n     * @return {number} bound texture location\n     */\n    bindTexture(texture, location, forceLocation)\n    {\n        texture = texture || this.emptyTextures[location];\n        texture = texture.baseTexture || texture;\n        texture.touched = this.textureGC.count;\n\n        if (!forceLocation)\n        {\n            // TODO - maybe look into adding boundIds.. save us the loop?\n            for (let i = 0; i < this.boundTextures.length; i++)\n            {\n                if (this.boundTextures[i] === texture)\n                {\n                    return i;\n                }\n            }\n\n            if (location === undefined)\n            {\n                this._nextTextureLocation++;\n                this._nextTextureLocation %= this.boundTextures.length;\n                location = this.boundTextures.length - this._nextTextureLocation - 1;\n            }\n        }\n        else\n        {\n            location = location || 0;\n        }\n\n        const gl = this.gl;\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            // this will also bind the texture..\n            this.textureManager.updateTexture(texture, location);\n        }\n        else\n        {\n            // bind the current texture\n            this.boundTextures[location] = texture;\n            gl.activeTexture(gl.TEXTURE0 + location);\n            gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n        }\n\n        return location;\n    }\n\n     /**\n     * unbinds the texture ...\n     *\n     * @param {PIXI.Texture} texture - the texture to unbind\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    unbindTexture(texture)\n    {\n        const gl = this.gl;\n\n        texture = texture.baseTexture || texture;\n\n        if (this._unknownBoundTextures)\n        {\n            this._unknownBoundTextures = false;\n            // someone changed webGL state,\n            // we have to be sure that our texture does not appear in multitexture renderer samplers\n\n            for (let i = 0; i < this.boundTextures.length; i++)\n            {\n                if (this.boundTextures[i] === this.emptyTextures[i])\n                {\n                    gl.activeTexture(gl.TEXTURE0 + i);\n                    gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);\n                }\n            }\n        }\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            if (this.boundTextures[i] === texture)\n            {\n                this.boundTextures[i] = this.emptyTextures[i];\n\n                gl.activeTexture(gl.TEXTURE0 + i);\n                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Creates a new VAO from this renderer's context and state.\n     *\n     * @return {VertexArrayObject} The new VAO.\n     */\n    createVao()\n    {\n        return new glCore.VertexArrayObject(this.gl, this.state.attribState);\n    }\n\n    /**\n     * Changes the current Vao to the one given in parameter\n     *\n     * @param {PIXI.VertexArrayObject} vao - the new Vao\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindVao(vao)\n    {\n        if (this._activeVao === vao)\n        {\n            return this;\n        }\n\n        if (vao)\n        {\n            vao.bind();\n        }\n        else if (this._activeVao)\n        {\n            // TODO this should always be true i think?\n            this._activeVao.unbind();\n        }\n\n        this._activeVao = vao;\n\n        return this;\n    }\n\n    /**\n     * Resets the WebGL state so you can render things however you fancy!\n     *\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    reset()\n    {\n        this.setObjectRenderer(this.emptyRenderer);\n\n        this.bindVao(null);\n        this._activeShader = null;\n        this._activeRenderTarget = this.rootRenderTarget;\n\n        this._unknownBoundTextures = true;\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            this.boundTextures[i] = this.emptyTextures[i];\n        }\n\n        // bind the main frame buffer (the screen);\n        this.rootRenderTarget.activate();\n\n        this.state.resetToDefault();\n\n        return this;\n    }\n\n    /**\n     * Handles a lost webgl context\n     *\n     * @private\n     * @param {WebGLContextEvent} event - The context lost event.\n     */\n    handleContextLost(event)\n    {\n        event.preventDefault();\n    }\n\n    /**\n     * Handles a restored webgl context\n     *\n     * @private\n     */\n    handleContextRestored()\n    {\n        this.textureManager.removeAll();\n        this.filterManager.destroy(true);\n        this._initContext();\n    }\n\n    /**\n     * Removes everything from the renderer (event listeners, spritebatch, etc...)\n     *\n     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n     *  See: https://github.com/pixijs/pixi.js/issues/2233\n     */\n    destroy(removeView)\n    {\n        this.destroyPlugins();\n\n        // remove listeners\n        this.view.removeEventListener('webglcontextlost', this.handleContextLost);\n        this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);\n\n        this.textureManager.destroy();\n\n        // call base destroy\n        super.destroy(removeView);\n\n        this.uid = 0;\n\n        // destroy the managers\n        this.maskManager.destroy();\n        this.stencilManager.destroy();\n        this.filterManager.destroy();\n\n        this.maskManager = null;\n        this.filterManager = null;\n        this.textureManager = null;\n        this.currentRenderer = null;\n\n        this.handleContextLost = null;\n        this.handleContextRestored = null;\n\n        this._contextOptions = null;\n        this.gl.useProgram(null);\n\n        if (this.gl.getExtension('WEBGL_lose_context'))\n        {\n            this.gl.getExtension('WEBGL_lose_context').loseContext();\n        }\n\n        this.gl = null;\n\n        // this = null;\n    }\n}\n\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.WebGLRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.WebGLExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.WebGLPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.WebGLRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\npluginTarget.mixin(WebGLRenderer);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}