{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _core = require('../core');\nvar core = _interopRequireWildcard(_core);\nvar _CountLimiter = require('./limiters/CountLimiter');\nvar _CountLimiter2 = _interopRequireDefault(_CountLimiter);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar SharedTicker = core.ticker.shared;\n\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\ncore.settings.UPLOADS_PER_FRAME = 4;\n\n/**\n * The prepare manager provides functionality to upload content to the GPU. BasePrepare handles\n * basic queuing functionality and is extended by {@link PIXI.prepare.WebGLPrepare} and {@link PIXI.prepare.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @example\n * // Create a sprite\n * const sprite = new PIXI.Sprite.fromImage('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n *\n * @abstract\n * @class\n * @memberof PIXI.prepare\n */\n\nvar BasePrepare = function () {\n  /**\n   * @param {PIXI.SystemRenderer} renderer - A reference to the current renderer\n   */\n  function BasePrepare(renderer) {\n    var _this = this;\n    _classCallCheck(this, BasePrepare);\n\n    /**\n     * The limiter to be used to control how quickly items are prepared.\n     * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}\n     */\n    this.limiter = new _CountLimiter2.default(core.settings.UPLOADS_PER_FRAME);\n\n    /**\n     * Reference to the renderer.\n     * @type {PIXI.SystemRenderer}\n     * @protected\n     */\n    this.renderer = renderer;\n\n    /**\n     * The only real difference between CanvasPrepare and WebGLPrepare is what they pass\n     * to upload hooks. That different parameter is stored here.\n     * @type {PIXI.prepare.CanvasPrepare|PIXI.WebGLRenderer}\n     * @protected\n     */\n    this.uploadHookHelper = null;\n\n    /**\n     * Collection of items to uploads at once.\n     * @type {Array<*>}\n     * @private\n     */\n    this.queue = [];\n\n    /**\n     * Collection of additional hooks for finding assets.\n     * @type {Array<Function>}\n     * @private\n     */\n    this.addHooks = [];\n\n    /**\n     * Collection of additional hooks for processing assets.\n     * @type {Array<Function>}\n     * @private\n     */\n    this.uploadHooks = [];\n\n    /**\n     * Callback to call after completed.\n     * @type {Array<Function>}\n     * @private\n     */\n    this.completes = [];\n\n    /**\n     * If prepare is ticking (running).\n     * @type {boolean}\n     * @private\n     */\n    this.ticking = false;\n\n    /**\n     * 'bound' call for prepareItems().\n     * @type {Function}\n     * @private\n     */\n    this.delayedTick = function () {\n      // unlikely, but in case we were destroyed between tick() and delayedTick()\n      if (!_this.queue) {\n        return;\n      }\n      _this.prepareItems();\n    };\n\n    // hooks to find the correct texture\n    this.registerFindHook(findText);\n    this.registerFindHook(findTextStyle);\n    this.registerFindHook(findMultipleBaseTextures);\n    this.registerFindHook(findBaseTexture);\n    this.registerFindHook(findTexture);\n\n    // upload hooks\n    this.registerUploadHook(drawText);\n    this.registerUploadHook(calculateTextStyle);\n  }\n\n  /**\n   * Upload all the textures and graphics to the GPU.\n   *\n   * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -\n   *        Either the container or display object to search for items to upload, the items to upload themselves,\n   *        or the callback function, if items have been added using `prepare.add`.\n   * @param {Function} [done] - Optional callback when all queued uploads have completed\n   */\n\n  BasePrepare.prototype.upload = function upload(item, done) {\n    if (typeof item === 'function') {\n      done = item;\n      item = null;\n    }\n\n    // If a display object, search for items\n    // that we could upload\n    if (item) {\n      this.add(item);\n    }\n\n    // Get the items for upload from the display\n    if (this.queue.length) {\n      if (done) {\n        this.completes.push(done);\n      }\n      if (!this.ticking) {\n        this.ticking = true;\n        SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);\n      }\n    } else if (done) {\n      done();\n    }\n  };\n\n  /**\n   * Handle tick update\n   *\n   * @private\n   */\n\n  BasePrepare.prototype.tick = function tick() {\n    setTimeout(this.delayedTick, 0);\n  };\n\n  /**\n   * Actually prepare items. This is handled outside of the tick because it will take a while\n   * and we do NOT want to block the current animation frame from rendering.\n   *\n   * @private\n   */\n\n  BasePrepare.prototype.prepareItems = function prepareItems() {\n    this.limiter.beginFrame();\n    // Upload the graphics\n    while (this.queue.length && this.limiter.allowedToUpload()) {\n      var item = this.queue[0];\n      var uploaded = false;\n      if (item && !item._destroyed) {\n        for (var i = 0, len = this.uploadHooks.length; i < len; i++) {\n          if (this.uploadHooks[i](this.uploadHookHelper, item)) {\n            this.queue.shift();\n            uploaded = true;\n            break;\n          }\n        }\n      }\n      if (!uploaded) {\n        this.queue.shift();\n      }\n    }\n\n    // We're finished\n    if (!this.queue.length) {\n      this.ticking = false;\n      var completes = this.completes.slice(0);\n      this.completes.length = 0;\n      for (var _i = 0, _len = completes.length; _i < _len; _i++) {\n        completes[_i]();\n      }\n    } else {\n      // if we are not finished, on the next rAF do this again\n      SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);\n    }\n  };\n\n  /**\n   * Adds hooks for finding items.\n   *\n   * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n   *          function must return `true` if it was able to add item to the queue.\n   * @return {PIXI.BasePrepare} Instance of plugin for chaining.\n   */\n\n  BasePrepare.prototype.registerFindHook = function registerFindHook(addHook) {\n    if (addHook) {\n      this.addHooks.push(addHook);\n    }\n    return this;\n  };\n\n  /**\n   * Adds hooks for uploading items.\n   *\n   * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n   *          function must return `true` if it was able to handle upload of item.\n   * @return {PIXI.BasePrepare} Instance of plugin for chaining.\n   */\n\n  BasePrepare.prototype.registerUploadHook = function registerUploadHook(uploadHook) {\n    if (uploadHook) {\n      this.uploadHooks.push(uploadHook);\n    }\n    return this;\n  };\n\n  /**\n   * Manually add an item to the uploading queue.\n   *\n   * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n   *        add to the queue\n   * @return {PIXI.CanvasPrepare} Instance of plugin for chaining.\n   */\n\n  BasePrepare.prototype.add = function add(item) {\n    // Add additional hooks for finding elements on special\n    // types of objects that\n    for (var i = 0, len = this.addHooks.length; i < len; i++) {\n      if (this.addHooks[i](item, this.queue)) {\n        break;\n      }\n    }\n\n    // Get childen recursively\n    if (item instanceof core.Container) {\n      for (var _i2 = item.children.length - 1; _i2 >= 0; _i2--) {\n        this.add(item.children[_i2]);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Destroys the plugin, don't use after this.\n   *\n   */\n\n  BasePrepare.prototype.destroy = function destroy() {\n    if (this.ticking) {\n      SharedTicker.remove(this.tick, this);\n    }\n    this.ticking = false;\n    this.addHooks = null;\n    this.uploadHooks = null;\n    this.renderer = null;\n    this.completes = null;\n    this.queue = null;\n    this.limiter = null;\n    this.uploadHookHelper = null;\n  };\n  return BasePrepare;\n}();\n\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\n\nexports.default = BasePrepare;\nfunction findMultipleBaseTextures(item, queue) {\n  var result = false;\n\n  // Objects with mutliple textures\n  if (item && item._textures && item._textures.length) {\n    for (var i = 0; i < item._textures.length; i++) {\n      if (item._textures[i] instanceof core.Texture) {\n        var baseTexture = item._textures[i].baseTexture;\n        if (queue.indexOf(baseTexture) === -1) {\n          queue.push(baseTexture);\n          result = true;\n        }\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Built-in hook to find BaseTextures from Sprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findBaseTexture(item, queue) {\n  // Objects with textures, like Sprites/Text\n  if (item instanceof core.BaseTexture) {\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n    return true;\n  }\n  return false;\n}\n\n/**\n * Built-in hook to find textures from objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findTexture(item, queue) {\n  if (item._texture && item._texture instanceof core.Texture) {\n    var texture = item._texture.baseTexture;\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\n\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction drawText(helper, item) {\n  if (item instanceof core.Text) {\n    // updating text will return early if it is not dirty\n    item.updateText(true);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction calculateTextStyle(helper, item) {\n  if (item instanceof core.TextStyle) {\n    var font = item.toFontString();\n    core.TextMetrics.measureFont(font);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Text object was found.\n */\nfunction findText(item, queue) {\n  if (item instanceof core.Text) {\n    // push the text style to prepare it - this can be really expensive\n    if (queue.indexOf(item.style) === -1) {\n      queue.push(item.style);\n    }\n    // also push the text object so that we can render it (to canvas/texture) if needed\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n    // also push the Text's texture for upload to GPU\n    var texture = item._texture.baseTexture;\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\n\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param {PIXI.TextStyle} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item, queue) {\n  if (item instanceof core.TextStyle) {\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n    return true;\n  }\n  return false;\n}","map":{"version":3,"names":["_core","require","core","_CountLimiter","SharedTicker","ticker","shared","settings","UPLOADS_PER_FRAME","BasePrepare","renderer","_this","_classCallCheck","limiter","_CountLimiter2","default","uploadHookHelper","queue","addHooks","uploadHooks","completes","ticking","delayedTick","prepareItems","registerFindHook","findText","findTextStyle","findMultipleBaseTextures","findBaseTexture","findTexture","registerUploadHook","drawText","calculateTextStyle","upload","item","done","add","length","push","addOnce","tick","UPDATE_PRIORITY","UTILITY","setTimeout","beginFrame","allowedToUpload","uploaded","_destroyed","i","len","shift","slice","_i","_len","addHook","uploadHook","Container","_i2","children","destroy","remove","result","_textures","Texture","baseTexture","indexOf","BaseTexture","_texture","texture","helper","Text","updateText","TextStyle","font","toFontString","TextMetrics","measureFont","style"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/prepare/BasePrepare.js"],"sourcesContent":["import * as core from '../core';\nimport CountLimiter from './limiters/CountLimiter';\nconst SharedTicker = core.ticker.shared;\n\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\ncore.settings.UPLOADS_PER_FRAME = 4;\n\n/**\n * The prepare manager provides functionality to upload content to the GPU. BasePrepare handles\n * basic queuing functionality and is extended by {@link PIXI.prepare.WebGLPrepare} and {@link PIXI.prepare.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @example\n * // Create a sprite\n * const sprite = new PIXI.Sprite.fromImage('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n *\n * @abstract\n * @class\n * @memberof PIXI.prepare\n */\nexport default class BasePrepare\n{\n    /**\n     * @param {PIXI.SystemRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        /**\n         * The limiter to be used to control how quickly items are prepared.\n         * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}\n         */\n        this.limiter = new CountLimiter(core.settings.UPLOADS_PER_FRAME);\n\n        /**\n         * Reference to the renderer.\n         * @type {PIXI.SystemRenderer}\n         * @protected\n         */\n        this.renderer = renderer;\n\n        /**\n         * The only real difference between CanvasPrepare and WebGLPrepare is what they pass\n         * to upload hooks. That different parameter is stored here.\n         * @type {PIXI.prepare.CanvasPrepare|PIXI.WebGLRenderer}\n         * @protected\n         */\n        this.uploadHookHelper = null;\n\n        /**\n         * Collection of items to uploads at once.\n         * @type {Array<*>}\n         * @private\n         */\n        this.queue = [];\n\n        /**\n         * Collection of additional hooks for finding assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.addHooks = [];\n\n        /**\n         * Collection of additional hooks for processing assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.uploadHooks = [];\n\n        /**\n         * Callback to call after completed.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.completes = [];\n\n        /**\n         * If prepare is ticking (running).\n         * @type {boolean}\n         * @private\n         */\n        this.ticking = false;\n\n        /**\n         * 'bound' call for prepareItems().\n         * @type {Function}\n         * @private\n         */\n        this.delayedTick = () =>\n        {\n            // unlikely, but in case we were destroyed between tick() and delayedTick()\n            if (!this.queue)\n            {\n                return;\n            }\n            this.prepareItems();\n        };\n\n        // hooks to find the correct texture\n        this.registerFindHook(findText);\n        this.registerFindHook(findTextStyle);\n        this.registerFindHook(findMultipleBaseTextures);\n        this.registerFindHook(findBaseTexture);\n        this.registerFindHook(findTexture);\n\n        // upload hooks\n        this.registerUploadHook(drawText);\n        this.registerUploadHook(calculateTextStyle);\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU.\n     *\n     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -\n     *        Either the container or display object to search for items to upload, the items to upload themselves,\n     *        or the callback function, if items have been added using `prepare.add`.\n     * @param {Function} [done] - Optional callback when all queued uploads have completed\n     */\n    upload(item, done)\n    {\n        if (typeof item === 'function')\n        {\n            done = item;\n            item = null;\n        }\n\n        // If a display object, search for items\n        // that we could upload\n        if (item)\n        {\n            this.add(item);\n        }\n\n        // Get the items for upload from the display\n        if (this.queue.length)\n        {\n            if (done)\n            {\n                this.completes.push(done);\n            }\n\n            if (!this.ticking)\n            {\n                this.ticking = true;\n                SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);\n            }\n        }\n        else if (done)\n        {\n            done();\n        }\n    }\n\n    /**\n     * Handle tick update\n     *\n     * @private\n     */\n    tick()\n    {\n        setTimeout(this.delayedTick, 0);\n    }\n\n    /**\n     * Actually prepare items. This is handled outside of the tick because it will take a while\n     * and we do NOT want to block the current animation frame from rendering.\n     *\n     * @private\n     */\n    prepareItems()\n    {\n        this.limiter.beginFrame();\n        // Upload the graphics\n        while (this.queue.length && this.limiter.allowedToUpload())\n        {\n            const item = this.queue[0];\n            let uploaded = false;\n\n            if (item && !item._destroyed)\n            {\n                for (let i = 0, len = this.uploadHooks.length; i < len; i++)\n                {\n                    if (this.uploadHooks[i](this.uploadHookHelper, item))\n                    {\n                        this.queue.shift();\n                        uploaded = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!uploaded)\n            {\n                this.queue.shift();\n            }\n        }\n\n        // We're finished\n        if (!this.queue.length)\n        {\n            this.ticking = false;\n\n            const completes = this.completes.slice(0);\n\n            this.completes.length = 0;\n\n            for (let i = 0, len = completes.length; i < len; i++)\n            {\n                completes[i]();\n            }\n        }\n        else\n        {\n            // if we are not finished, on the next rAF do this again\n            SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);\n        }\n    }\n\n    /**\n     * Adds hooks for finding items.\n     *\n     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n     *          function must return `true` if it was able to add item to the queue.\n     * @return {PIXI.BasePrepare} Instance of plugin for chaining.\n     */\n    registerFindHook(addHook)\n    {\n        if (addHook)\n        {\n            this.addHooks.push(addHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds hooks for uploading items.\n     *\n     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n     *          function must return `true` if it was able to handle upload of item.\n     * @return {PIXI.BasePrepare} Instance of plugin for chaining.\n     */\n    registerUploadHook(uploadHook)\n    {\n        if (uploadHook)\n        {\n            this.uploadHooks.push(uploadHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Manually add an item to the uploading queue.\n     *\n     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n     *        add to the queue\n     * @return {PIXI.CanvasPrepare} Instance of plugin for chaining.\n     */\n    add(item)\n    {\n        // Add additional hooks for finding elements on special\n        // types of objects that\n        for (let i = 0, len = this.addHooks.length; i < len; i++)\n        {\n            if (this.addHooks[i](item, this.queue))\n            {\n                break;\n            }\n        }\n\n        // Get childen recursively\n        if (item instanceof core.Container)\n        {\n            for (let i = item.children.length - 1; i >= 0; i--)\n            {\n                this.add(item.children[i]);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Destroys the plugin, don't use after this.\n     *\n     */\n    destroy()\n    {\n        if (this.ticking)\n        {\n            SharedTicker.remove(this.tick, this);\n        }\n        this.ticking = false;\n        this.addHooks = null;\n        this.uploadHooks = null;\n        this.renderer = null;\n        this.completes = null;\n        this.queue = null;\n        this.limiter = null;\n        this.uploadHookHelper = null;\n    }\n\n}\n\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findMultipleBaseTextures(item, queue)\n{\n    let result = false;\n\n    // Objects with mutliple textures\n    if (item && item._textures && item._textures.length)\n    {\n        for (let i = 0; i < item._textures.length; i++)\n        {\n            if (item._textures[i] instanceof core.Texture)\n            {\n                const baseTexture = item._textures[i].baseTexture;\n\n                if (queue.indexOf(baseTexture) === -1)\n                {\n                    queue.push(baseTexture);\n                    result = true;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * Built-in hook to find BaseTextures from Sprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findBaseTexture(item, queue)\n{\n    // Objects with textures, like Sprites/Text\n    if (item instanceof core.BaseTexture)\n    {\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find textures from objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findTexture(item, queue)\n{\n    if (item._texture && item._texture instanceof core.Texture)\n    {\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction drawText(helper, item)\n{\n    if (item instanceof core.Text)\n    {\n        // updating text will return early if it is not dirty\n        item.updateText(true);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction calculateTextStyle(helper, item)\n{\n    if (item instanceof core.TextStyle)\n    {\n        const font = item.toFontString();\n\n        core.TextMetrics.measureFont(font);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Text object was found.\n */\nfunction findText(item, queue)\n{\n    if (item instanceof core.Text)\n    {\n        // push the text style to prepare it - this can be really expensive\n        if (queue.indexOf(item.style) === -1)\n        {\n            queue.push(item.style);\n        }\n        // also push the text object so that we can render it (to canvas/texture) if needed\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n        // also push the Text's texture for upload to GPU\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param {PIXI.TextStyle} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item, queue)\n{\n    if (item instanceof core.TextStyle)\n    {\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}