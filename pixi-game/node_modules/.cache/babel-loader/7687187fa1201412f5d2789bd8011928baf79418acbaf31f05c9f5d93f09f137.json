{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _Mesh2 = require('./Mesh');\nvar _Mesh3 = _interopRequireDefault(_Mesh2);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * The rope allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let rope = new PIXI.Rope(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.mesh.Mesh\n * @memberof PIXI.mesh\n *\n */\nvar Rope = function (_Mesh) {\n  _inherits(Rope, _Mesh);\n\n  /**\n   * @param {PIXI.Texture} texture - The texture to use on the rope.\n   * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.\n   */\n  function Rope(texture, points) {\n    _classCallCheck(this, Rope);\n\n    /**\n     * An array of points that determine the rope\n     *\n     * @member {PIXI.Point[]}\n     */\n    var _this = _possibleConstructorReturn(this, _Mesh.call(this, texture));\n    _this.points = points;\n\n    /**\n     * An array of vertices used to construct this rope.\n     *\n     * @member {Float32Array}\n     */\n    _this.vertices = new Float32Array(points.length * 4);\n\n    /**\n     * The WebGL Uvs of the rope.\n     *\n     * @member {Float32Array}\n     */\n    _this.uvs = new Float32Array(points.length * 4);\n\n    /**\n     * An array containing the color components\n     *\n     * @member {Float32Array}\n     */\n    _this.colors = new Float32Array(points.length * 2);\n\n    /**\n     * An array containing the indices of the vertices\n     *\n     * @member {Uint16Array}\n     */\n    _this.indices = new Uint16Array(points.length * 2);\n\n    /**\n     * refreshes vertices on every updateTransform\n     * @member {boolean}\n     * @default true\n     */\n    _this.autoUpdate = true;\n    _this.refresh();\n    return _this;\n  }\n\n  /**\n   * Refreshes\n   *\n   */\n\n  Rope.prototype._refresh = function _refresh() {\n    var points = this.points;\n\n    // if too little points, or texture hasn't got UVs set yet just move on.\n    if (points.length < 1 || !this._texture._uvs) {\n      return;\n    }\n\n    // if the number of points has changed we will need to recreate the arraybuffers\n    if (this.vertices.length / 4 !== points.length) {\n      this.vertices = new Float32Array(points.length * 4);\n      this.uvs = new Float32Array(points.length * 4);\n      this.colors = new Float32Array(points.length * 2);\n      this.indices = new Uint16Array(points.length * 2);\n    }\n    var uvs = this.uvs;\n    var indices = this.indices;\n    var colors = this.colors;\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n    colors[0] = 1;\n    colors[1] = 1;\n    indices[0] = 0;\n    indices[1] = 1;\n    var total = points.length;\n    for (var i = 1; i < total; i++) {\n      // time to do some smart drawing!\n      var index = i * 4;\n      var amount = i / (total - 1);\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n      index = i * 2;\n      colors[index] = 1;\n      colors[index + 1] = 1;\n      index = i * 2;\n      indices[index] = index;\n      indices[index + 1] = index + 1;\n    }\n\n    // ensure that the changes are uploaded\n    this.dirty++;\n    this.indexDirty++;\n    this.multiplyUvs();\n    this.refreshVertices();\n  };\n\n  /**\n   * refreshes vertices of Rope mesh\n   */\n\n  Rope.prototype.refreshVertices = function refreshVertices() {\n    var points = this.points;\n    if (points.length < 1) {\n      return;\n    }\n    var lastPoint = points[0];\n    var nextPoint = void 0;\n    var perpX = 0;\n    var perpY = 0;\n\n    // this.count -= 0.2;\n\n    var vertices = this.vertices;\n    var total = points.length;\n    for (var i = 0; i < total; i++) {\n      var point = points[i];\n      var index = i * 4;\n      if (i < points.length - 1) {\n        nextPoint = points[i + 1];\n      } else {\n        nextPoint = point;\n      }\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n      var ratio = (1 - i / (total - 1)) * 10;\n      if (ratio > 1) {\n        ratio = 1;\n      }\n      var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      var num = this._texture.height / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n\n      perpX /= perpLength;\n      perpY /= perpLength;\n      perpX *= num;\n      perpY *= num;\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n      lastPoint = point;\n    }\n  };\n\n  /**\n   * Updates the object transform for rendering\n   *\n   * @private\n   */\n\n  Rope.prototype.updateTransform = function updateTransform() {\n    if (this.autoUpdate) {\n      this.refreshVertices();\n    }\n    this.containerUpdateTransform();\n  };\n  return Rope;\n}(_Mesh3.default);\nexports.default = Rope;","map":{"version":3,"names":["_Mesh2","require","Rope","texture","points","_classCallCheck","_this","_possibleConstructorReturn","_Mesh","call","vertices","Float32Array","length","uvs","colors","indices","Uint16Array","autoUpdate","refresh","_refresh","_texture","_uvs","total","i","index","amount","dirty","indexDirty","multiplyUvs","refreshVertices","lastPoint","nextPoint","perpX","perpY","point","x","y","ratio","perpLength","Math","sqrt","num","height","updateTransform","containerUpdateTransform"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/mesh/Rope.js"],"sourcesContent":["import Mesh from './Mesh';\n\n/**\n * The rope allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let rope = new PIXI.Rope(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.mesh.Mesh\n * @memberof PIXI.mesh\n *\n */\nexport default class Rope extends Mesh\n{\n    /**\n     * @param {PIXI.Texture} texture - The texture to use on the rope.\n     * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.\n     */\n    constructor(texture, points)\n    {\n        super(texture);\n\n        /**\n         * An array of points that determine the rope\n         *\n         * @member {PIXI.Point[]}\n         */\n        this.points = points;\n\n        /**\n         * An array of vertices used to construct this rope.\n         *\n         * @member {Float32Array}\n         */\n        this.vertices = new Float32Array(points.length * 4);\n\n        /**\n         * The WebGL Uvs of the rope.\n         *\n         * @member {Float32Array}\n         */\n        this.uvs = new Float32Array(points.length * 4);\n\n        /**\n         * An array containing the color components\n         *\n         * @member {Float32Array}\n         */\n        this.colors = new Float32Array(points.length * 2);\n\n        /**\n         * An array containing the indices of the vertices\n         *\n         * @member {Uint16Array}\n         */\n        this.indices = new Uint16Array(points.length * 2);\n\n        /**\n         * refreshes vertices on every updateTransform\n         * @member {boolean}\n         * @default true\n         */\n        this.autoUpdate = true;\n\n        this.refresh();\n    }\n\n    /**\n     * Refreshes\n     *\n     */\n    _refresh()\n    {\n        const points = this.points;\n\n        // if too little points, or texture hasn't got UVs set yet just move on.\n        if (points.length < 1 || !this._texture._uvs)\n        {\n            return;\n        }\n\n        // if the number of points has changed we will need to recreate the arraybuffers\n        if (this.vertices.length / 4 !== points.length)\n        {\n            this.vertices = new Float32Array(points.length * 4);\n            this.uvs = new Float32Array(points.length * 4);\n            this.colors = new Float32Array(points.length * 2);\n            this.indices = new Uint16Array(points.length * 2);\n        }\n\n        const uvs = this.uvs;\n\n        const indices = this.indices;\n        const colors = this.colors;\n\n        uvs[0] = 0;\n        uvs[1] = 0;\n        uvs[2] = 0;\n        uvs[3] = 1;\n\n        colors[0] = 1;\n        colors[1] = 1;\n\n        indices[0] = 0;\n        indices[1] = 1;\n\n        const total = points.length;\n\n        for (let i = 1; i < total; i++)\n        {\n            // time to do some smart drawing!\n            let index = i * 4;\n            const amount = i / (total - 1);\n\n            uvs[index] = amount;\n            uvs[index + 1] = 0;\n\n            uvs[index + 2] = amount;\n            uvs[index + 3] = 1;\n\n            index = i * 2;\n            colors[index] = 1;\n            colors[index + 1] = 1;\n\n            index = i * 2;\n            indices[index] = index;\n            indices[index + 1] = index + 1;\n        }\n\n        // ensure that the changes are uploaded\n        this.dirty++;\n        this.indexDirty++;\n\n        this.multiplyUvs();\n        this.refreshVertices();\n    }\n\n    /**\n     * refreshes vertices of Rope mesh\n     */\n    refreshVertices()\n    {\n        const points = this.points;\n\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        let lastPoint = points[0];\n        let nextPoint;\n        let perpX = 0;\n        let perpY = 0;\n\n        // this.count -= 0.2;\n\n        const vertices = this.vertices;\n        const total = points.length;\n\n        for (let i = 0; i < total; i++)\n        {\n            const point = points[i];\n            const index = i * 4;\n\n            if (i < points.length - 1)\n            {\n                nextPoint = points[i + 1];\n            }\n            else\n            {\n                nextPoint = point;\n            }\n\n            perpY = -(nextPoint.x - lastPoint.x);\n            perpX = nextPoint.y - lastPoint.y;\n\n            let ratio = (1 - (i / (total - 1))) * 10;\n\n            if (ratio > 1)\n            {\n                ratio = 1;\n            }\n\n            const perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));\n            const num = this._texture.height / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n\n            perpX /= perpLength;\n            perpY /= perpLength;\n\n            perpX *= num;\n            perpY *= num;\n\n            vertices[index] = point.x + perpX;\n            vertices[index + 1] = point.y + perpY;\n            vertices[index + 2] = point.x - perpX;\n            vertices[index + 3] = point.y - perpY;\n\n            lastPoint = point;\n        }\n    }\n\n    /**\n     * Updates the object transform for rendering\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        if (this.autoUpdate)\n        {\n            this.refreshVertices();\n        }\n        this.containerUpdateTransform();\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}