{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _math = require('../math');\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * Generic class to deal with traditional 2D matrix transforms\n *\n * @class\n * @memberof PIXI\n */\nvar TransformBase = function () {\n  /**\n   *\n   */\n  function TransformBase() {\n    _classCallCheck(this, TransformBase);\n\n    /**\n     * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()\n     *\n     * @member {PIXI.Matrix}\n     */\n    this.worldTransform = new _math.Matrix();\n\n    /**\n     * The local matrix transform\n     *\n     * @member {PIXI.Matrix}\n     */\n    this.localTransform = new _math.Matrix();\n    this._worldID = 0;\n    this._parentID = 0;\n  }\n\n  /**\n   * TransformBase does not have decomposition, so this function wont do anything\n   */\n\n  TransformBase.prototype.updateLocalTransform = function updateLocalTransform() {}\n  // empty\n\n  /**\n   * Updates the values of the object and applies the parent's transform.\n   *\n   * @param {PIXI.TransformBase} parentTransform - The transform of the parent of this object\n   */;\n\n  TransformBase.prototype.updateTransform = function updateTransform(parentTransform) {\n    var pt = parentTransform.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n\n    // concat the parent matrix with the objects transform.\n    wt.a = lt.a * pt.a + lt.b * pt.c;\n    wt.b = lt.a * pt.b + lt.b * pt.d;\n    wt.c = lt.c * pt.a + lt.d * pt.c;\n    wt.d = lt.c * pt.b + lt.d * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this._worldID++;\n  };\n  return TransformBase;\n}();\n\n/**\n * Updates the values of the object and applies the parent's transform.\n * @param  parentTransform {PIXI.Transform} The transform of the parent of this object\n *\n */\n\nexports.default = TransformBase;\nTransformBase.prototype.updateWorldTransform = TransformBase.prototype.updateTransform;\nTransformBase.IDENTITY = new TransformBase();","map":{"version":3,"names":["_math","require","TransformBase","_classCallCheck","worldTransform","Matrix","localTransform","_worldID","_parentID","updateLocalTransform","updateTransform","parentTransform","pt","wt","lt","a","b","c","d","tx","ty","prototype","updateWorldTransform","IDENTITY"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/display/TransformBase.js"],"sourcesContent":["import { Matrix } from '../math';\n\n/**\n * Generic class to deal with traditional 2D matrix transforms\n *\n * @class\n * @memberof PIXI\n */\nexport default class TransformBase\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        /**\n         * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.worldTransform = new Matrix();\n\n        /**\n         * The local matrix transform\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.localTransform = new Matrix();\n\n        this._worldID = 0;\n        this._parentID = 0;\n    }\n\n    /**\n     * TransformBase does not have decomposition, so this function wont do anything\n     */\n    updateLocalTransform()\n    {\n        // empty\n    }\n\n    /**\n     * Updates the values of the object and applies the parent's transform.\n     *\n     * @param {PIXI.TransformBase} parentTransform - The transform of the parent of this object\n     */\n    updateTransform(parentTransform)\n    {\n        const pt = parentTransform.worldTransform;\n        const wt = this.worldTransform;\n        const lt = this.localTransform;\n\n        // concat the parent matrix with the objects transform.\n        wt.a = (lt.a * pt.a) + (lt.b * pt.c);\n        wt.b = (lt.a * pt.b) + (lt.b * pt.d);\n        wt.c = (lt.c * pt.a) + (lt.d * pt.c);\n        wt.d = (lt.c * pt.b) + (lt.d * pt.d);\n        wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;\n        wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;\n\n        this._worldID ++;\n    }\n\n}\n\n/**\n * Updates the values of the object and applies the parent's transform.\n * @param  parentTransform {PIXI.Transform} The transform of the parent of this object\n *\n */\nTransformBase.prototype.updateWorldTransform = TransformBase.prototype.updateTransform;\n\nTransformBase.IDENTITY = new TransformBase();\n"],"mappings":";;;AAAA,IAAAA,KAAA,GAAAC,OAAA;;;;;;;AAEA;;;;;;IAMqBC,a;EAEjB;;;EAGA,SAAAA,cAAA,EACA;IAAAC,eAAA,OAAAD,aAAA;;IACI;;;;;IAKA,KAAKE,cAAL,GAAsB,IAAAJ,KAAA,CAAAK,MAAA,EAAtB;;IAEA;;;;;IAKA,KAAKC,cAAL,GAAsB,IAAAN,KAAA,CAAAK,MAAA,EAAtB;IAEA,KAAKE,QAAL,GAAgB,CAAhB;IACA,KAAKC,SAAL,GAAiB,CAAjB;EACH;;EAED;;;;0BAGAC,oB,mCACA,CAEC;EADG;;EAGJ;;;;KAAA;;0BAKAC,e,4BAAgBC,e,EAChB;IACI,IAAMC,EAAA,GAAKD,eAAA,CAAgBP,cAA3B;IACA,IAAMS,EAAA,GAAK,KAAKT,cAAhB;IACA,IAAMU,EAAA,GAAK,KAAKR,cAAhB;;IAEA;IACAO,EAAA,CAAGE,CAAH,GAAQD,EAAA,CAAGC,CAAH,GAAOH,EAAA,CAAGG,CAAX,GAAiBD,EAAA,CAAGE,CAAH,GAAOJ,EAAA,CAAGK,CAAlC;IACAJ,EAAA,CAAGG,CAAH,GAAQF,EAAA,CAAGC,CAAH,GAAOH,EAAA,CAAGI,CAAX,GAAiBF,EAAA,CAAGE,CAAH,GAAOJ,EAAA,CAAGM,CAAlC;IACAL,EAAA,CAAGI,CAAH,GAAQH,EAAA,CAAGG,CAAH,GAAOL,EAAA,CAAGG,CAAX,GAAiBD,EAAA,CAAGI,CAAH,GAAON,EAAA,CAAGK,CAAlC;IACAJ,EAAA,CAAGK,CAAH,GAAQJ,EAAA,CAAGG,CAAH,GAAOL,EAAA,CAAGI,CAAX,GAAiBF,EAAA,CAAGI,CAAH,GAAON,EAAA,CAAGM,CAAlC;IACAL,EAAA,CAAGM,EAAH,GAASL,EAAA,CAAGK,EAAH,GAAQP,EAAA,CAAGG,CAAZ,GAAkBD,EAAA,CAAGM,EAAH,GAAQR,EAAA,CAAGK,CAA7B,GAAkCL,EAAA,CAAGO,EAA7C;IACAN,EAAA,CAAGO,EAAH,GAASN,EAAA,CAAGK,EAAH,GAAQP,EAAA,CAAGI,CAAZ,GAAkBF,EAAA,CAAGM,EAAH,GAAQR,EAAA,CAAGM,CAA7B,GAAkCN,EAAA,CAAGQ,EAA7C;IAEA,KAAKb,QAAL;EACH,C;;;;AAIL;;;;;;kBAzDqBL,a;AA8DrBA,aAAA,CAAcmB,SAAd,CAAwBC,oBAAxB,GAA+CpB,aAAA,CAAcmB,SAAd,CAAwBX,eAAvE;AAEAR,aAAA,CAAcqB,QAAd,GAAyB,IAAIrB,aAAJ,EAAzB"},"metadata":{},"sourceType":"script","externalDependencies":[]}