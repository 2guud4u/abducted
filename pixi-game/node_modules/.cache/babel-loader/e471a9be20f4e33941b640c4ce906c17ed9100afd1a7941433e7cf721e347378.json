{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _settings = require('../settings');\nvar _settings2 = _interopRequireDefault(_settings);\nvar _const = require('../const');\nvar _TickerListener = require('./TickerListener');\nvar _TickerListener2 = _interopRequireDefault(_TickerListener);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * This class is composed around listeners\n * meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary,\n * e.g. When the ticker is started and the emitter has listeners.\n *\n * @class\n * @memberof PIXI.ticker\n */\nvar Ticker = function () {\n  /**\n   *\n   */\n  function Ticker() {\n    var _this = this;\n    _classCallCheck(this, Ticker);\n\n    /**\n     * The first listener. All new listeners added are chained on this.\n     * @private\n     * @type {TickerListener}\n     */\n    this._head = new _TickerListener2.default(null, null, Infinity);\n\n    /**\n     * Internal current frame request ID\n     * @private\n     */\n    this._requestId = null;\n\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     * @private\n     */\n    this._maxElapsedMS = 100;\n\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link PIXI.ticker.Ticker#start} automatically\n     * when a listener is added.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoStart = false;\n\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}\n     * and is scaled with {@link PIXI.ticker.Ticker#speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.deltaTime = 1;\n\n    /**\n     * Time elapsed in milliseconds from last frame to this frame.\n     * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}\n     * is based, this value is neither capped nor scaled.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     * Defaults to target frame time\n     *\n     * @member {number}\n     * @default 16.66\n     */\n    this.elapsedMS = 1 / _settings2.default.TARGET_FPMS;\n\n    /**\n     * The last time {@link PIXI.ticker.Ticker#update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     *\n     * @member {number}\n     * @default -1\n     */\n    this.lastTime = -1;\n\n    /**\n     * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.speed = 1;\n\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link PIXI.ticker.Ticker#start} has been called.\n     * `false` if {@link PIXI.ticker.Ticker#stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link PIXI.ticker.Ticker#autoStart} being `true`\n     * and a listener is added.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.started = false;\n\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     *\n     * @private\n     * @param {number} time - Time since last tick.\n     */\n    this._tick = function (time) {\n      _this._requestId = null;\n      if (_this.started) {\n        // Invoke listeners now\n        _this.update(time);\n        // Listener side effects may have modified ticker state.\n        if (_this.started && _this._requestId === null && _this._head.next) {\n          _this._requestId = requestAnimationFrame(_this._tick);\n        }\n      }\n    };\n  }\n\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   *\n   * @private\n   */\n\n  Ticker.prototype._requestIfNeeded = function _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      // ensure callbacks get correct delta\n      this.lastTime = performance.now();\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  };\n\n  /**\n   * Conditionally cancels a pending animation frame.\n   *\n   * @private\n   */\n\n  Ticker.prototype._cancelIfNeeded = function _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  };\n\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   *\n   * @private\n   */\n\n  Ticker.prototype._startIfPossible = function _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  };\n\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   *\n   * @param {Function} fn - The listener function to be added for updates\n   * @param {Function} [context] - The listener context\n   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns {PIXI.ticker.Ticker} This instance of a ticker\n   */\n\n  Ticker.prototype.add = function add(fn, context) {\n    var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const.UPDATE_PRIORITY.NORMAL;\n    return this._addListener(new _TickerListener2.default(fn, context, priority));\n  };\n\n  /**\n   * Add a handler for the tick event which is only execute once.\n   *\n   * @param {Function} fn - The listener function to be added for one update\n   * @param {Function} [context] - The listener context\n   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns {PIXI.ticker.Ticker} This instance of a ticker\n   */\n\n  Ticker.prototype.addOnce = function addOnce(fn, context) {\n    var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const.UPDATE_PRIORITY.NORMAL;\n    return this._addListener(new _TickerListener2.default(fn, context, priority, true));\n  };\n\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   *\n   * @private\n   * @param {TickerListener} listener - Current listener being added.\n   * @returns {PIXI.ticker.Ticker} This instance of a ticker\n   */\n\n  Ticker.prototype._addListener = function _addListener(listener) {\n    // For attaching to head\n    var current = this._head.next;\n    var previous = this._head;\n\n    // Add the first item\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      // Go from highest to lowest priority\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n\n      // Not yet connected\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  };\n\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   *\n   * @param {Function} fn - The listener function to be removed\n   * @param {Function} [context] - The listener context to be removed\n   * @returns {PIXI.ticker.Ticker} This instance of a ticker\n   */\n\n  Ticker.prototype.remove = function remove(fn, context) {\n    var listener = this._head.next;\n    while (listener) {\n      // We found a match, lets remove it\n      // no break to delete all possible matches\n      // incase a listener was added 2+ times\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  };\n\n  /**\n   * Starts the ticker. If the ticker has listeners\n   * a new animation frame is requested at this point.\n   */\n\n  Ticker.prototype.start = function start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  };\n\n  /**\n   * Stops the ticker. If the ticker has requested\n   * an animation frame it is canceled at this point.\n   */\n\n  Ticker.prototype.stop = function stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  };\n\n  /**\n   * Destroy the ticker and don't use after this. Calling\n   * this method removes all references to internal events.\n   */\n\n  Ticker.prototype.destroy = function destroy() {\n    this.stop();\n    var listener = this._head.next;\n    while (listener) {\n      listener = listener.destroy(true);\n    }\n    this._head.destroy();\n    this._head = null;\n  };\n\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link PIXI.ticker.Ticker#elapsedMS},\n   * the current {@link PIXI.ticker.Ticker#deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link PIXI.ticker.Ticker#lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   *\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n\n  Ticker.prototype.update = function update() {\n    var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();\n    var elapsedMS = void 0;\n\n    // If the difference in time is zero or negative, we ignore most of the work done here.\n    // If there is no valid difference, then should be no reason to let anyone know about it.\n    // A zero delta, is exactly that, nothing should update.\n    //\n    // The difference in time can be negative, and no this does not mean time traveling.\n    // This can be the result of a race condition between when an animation frame is requested\n    // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n    // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n    // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n    // can receive a time argument that can be less than the lastTime value that was set within\n    // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n    //\n    // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n    // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n    if (currentTime > this.lastTime) {\n      // Save uncapped elapsedMS for measurement\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n      // cap the milliseconds elapsed used for deltaTime\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      this.deltaTime = elapsedMS * _settings2.default.TARGET_FPMS * this.speed;\n\n      // Cache a local reference, in-case ticker is destroyed\n      // during the emit, we can still check for head.next\n      var head = this._head;\n\n      // Invoke listeners added to internal emitter\n      var listener = head.next;\n      while (listener) {\n        listener = listener.emit(this.deltaTime);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  };\n\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link PIXI.ticker.Ticker#speed}, which is specific\n   * to scaling {@link PIXI.ticker.Ticker#deltaTime}.\n   *\n   * @member {number}\n   * @readonly\n   */\n\n  _createClass(Ticker, [{\n    key: 'FPS',\n    get: function get() {\n      return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link PIXI.ticker.Ticker#update}.\n     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},\n     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `PIXI.settings.TARGET_FPMS * 1000`.\n     *\n     * @member {number}\n     * @default 10\n     */\n  }, {\n    key: 'minFPS',\n    get: function get() {\n      return 1000 / this._maxElapsedMS;\n    },\n    set: function set(fps)\n    // eslint-disable-line require-jsdoc\n    {\n      // Clamp: 0 to TARGET_FPMS\n      var minFPMS = Math.min(Math.max(0, fps) / 1000, _settings2.default.TARGET_FPMS);\n      this._maxElapsedMS = 1 / minFPMS;\n    }\n  }]);\n  return Ticker;\n}();\nexports.default = Ticker;","map":{"version":3,"names":["_settings","require","_const","_TickerListener","Ticker","_this","_classCallCheck","_head","_TickerListener2","default","Infinity","_requestId","_maxElapsedMS","autoStart","deltaTime","elapsedMS","_settings2","TARGET_FPMS","lastTime","speed","started","_tick","time","update","next","requestAnimationFrame","_requestIfNeeded","performance","now","_cancelIfNeeded","cancelAnimationFrame","_startIfPossible","start","add","fn","context","priority","arguments","length","undefined","UPDATE_PRIORITY","NORMAL","_addListener","addOnce","listener","current","previous","connect","remove","match","destroy","stop","currentTime","head","emit","fps","minFPMS","Math","min","max"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/ticker/Ticker.js"],"sourcesContent":["import settings from '../settings';\nimport { UPDATE_PRIORITY } from '../const';\nimport TickerListener from './TickerListener';\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * This class is composed around listeners\n * meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary,\n * e.g. When the ticker is started and the emitter has listeners.\n *\n * @class\n * @memberof PIXI.ticker\n */\nexport default class Ticker\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        /**\n         * The first listener. All new listeners added are chained on this.\n         * @private\n         * @type {TickerListener}\n         */\n        this._head = new TickerListener(null, null, Infinity);\n\n        /**\n         * Internal current frame request ID\n         * @private\n         */\n        this._requestId = null;\n\n        /**\n         * Internal value managed by minFPS property setter and getter.\n         * This is the maximum allowed milliseconds between updates.\n         * @private\n         */\n        this._maxElapsedMS = 100;\n\n        /**\n         * Whether or not this ticker should invoke the method\n         * {@link PIXI.ticker.Ticker#start} automatically\n         * when a listener is added.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.autoStart = false;\n\n        /**\n         * Scalar time value from last frame to this frame.\n         * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}\n         * and is scaled with {@link PIXI.ticker.Ticker#speed}.\n         * **Note:** The cap may be exceeded by scaling.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.deltaTime = 1;\n\n        /**\n         * Time elapsed in milliseconds from last frame to this frame.\n         * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}\n         * is based, this value is neither capped nor scaled.\n         * If the platform supports DOMHighResTimeStamp,\n         * this value will have a precision of 1 µs.\n         * Defaults to target frame time\n         *\n         * @member {number}\n         * @default 16.66\n         */\n        this.elapsedMS = 1 / settings.TARGET_FPMS;\n\n        /**\n         * The last time {@link PIXI.ticker.Ticker#update} was invoked.\n         * This value is also reset internally outside of invoking\n         * update, but only when a new animation frame is requested.\n         * If the platform supports DOMHighResTimeStamp,\n         * this value will have a precision of 1 µs.\n         *\n         * @member {number}\n         * @default -1\n         */\n        this.lastTime = -1;\n\n        /**\n         * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.\n         * @example\n         * // Scales ticker.deltaTime to what would be\n         * // the equivalent of approximately 120 FPS\n         * ticker.speed = 2;\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.speed = 1;\n\n        /**\n         * Whether or not this ticker has been started.\n         * `true` if {@link PIXI.ticker.Ticker#start} has been called.\n         * `false` if {@link PIXI.ticker.Ticker#stop} has been called.\n         * While `false`, this value may change to `true` in the\n         * event of {@link PIXI.ticker.Ticker#autoStart} being `true`\n         * and a listener is added.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.started = false;\n\n        /**\n         * Internal tick method bound to ticker instance.\n         * This is because in early 2015, Function.bind\n         * is still 60% slower in high performance scenarios.\n         * Also separating frame requests from update method\n         * so listeners may be called at any time and with\n         * any animation API, just invoke ticker.update(time).\n         *\n         * @private\n         * @param {number} time - Time since last tick.\n         */\n        this._tick = (time) =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     *\n     * @private\n     */\n    _requestIfNeeded()\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /**\n     * Conditionally cancels a pending animation frame.\n     *\n     * @private\n     */\n    _cancelIfNeeded()\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     *\n     * @private\n     */\n    _startIfPossible()\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events. Calls continuously unless\n     * it is removed or the ticker is stopped.\n     *\n     * @param {Function} fn - The listener function to be added for updates\n     * @param {Function} [context] - The listener context\n     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns {PIXI.ticker.Ticker} This instance of a ticker\n     */\n    add(fn, context, priority = UPDATE_PRIORITY.NORMAL)\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only execute once.\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} [context] - The listener context\n     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns {PIXI.ticker.Ticker} This instance of a ticker\n     */\n    addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL)\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     *\n     * @private\n     * @param {TickerListener} listener - Current listener being added.\n     * @returns {PIXI.ticker.Ticker} This instance of a ticker\n     */\n    _addListener(listener)\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     *\n     * @param {Function} fn - The listener function to be removed\n     * @param {Function} [context] - The listener context to be removed\n     * @returns {PIXI.ticker.Ticker} This instance of a ticker\n     */\n    remove(fn, context)\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * Starts the ticker. If the ticker has listeners\n     * a new animation frame is requested at this point.\n     */\n    start()\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /**\n     * Stops the ticker. If the ticker has requested\n     * an animation frame it is canceled at this point.\n     */\n    stop()\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /**\n     * Destroy the ticker and don't use after this. Calling\n     * this method removes all references to internal events.\n     */\n    destroy()\n    {\n        this.stop();\n\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            listener = listener.destroy(true);\n        }\n\n        this._head.destroy();\n        this._head = null;\n    }\n\n    /**\n     * Triggers an update. An update entails setting the\n     * current {@link PIXI.ticker.Ticker#elapsedMS},\n     * the current {@link PIXI.ticker.Ticker#deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link PIXI.ticker.Ticker#lastTime}\n     * with the value of currentTime that was provided.\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     *\n     * @param {number} [currentTime=performance.now()] - the current time of execution\n     */\n    update(currentTime = performance.now())\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            this.deltaTime = elapsedMS * settings.TARGET_FPMS * this.speed;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this.deltaTime);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link PIXI.ticker.Ticker#speed}, which is specific\n     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.\n     *\n     * @member {number}\n     * @readonly\n     */\n    get FPS()\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link PIXI.ticker.Ticker#update}.\n     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},\n     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `PIXI.settings.TARGET_FPMS * 1000`.\n     *\n     * @member {number}\n     * @default 10\n     */\n    get minFPS()\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps) // eslint-disable-line require-jsdoc\n    {\n        // Clamp: 0 to TARGET_FPMS\n        const minFPMS = Math.min(Math.max(0, fps) / 1000, settings.TARGET_FPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}