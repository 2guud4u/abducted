{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _pixiGlCore = require('pixi-gl-core');\nvar _const = require('../../const');\nvar _RenderTarget = require('./utils/RenderTarget');\nvar _RenderTarget2 = _interopRequireDefault(_RenderTarget);\nvar _utils = require('../../utils');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * Helper class to create a webGL Texture\n *\n * @class\n * @memberof PIXI\n */\nvar TextureManager = function () {\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer\n   */\n  function TextureManager(renderer) {\n    _classCallCheck(this, TextureManager);\n\n    /**\n     * A reference to the current renderer\n     *\n     * @member {PIXI.WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The current WebGL rendering context\n     *\n     * @member {WebGLRenderingContext}\n     */\n    this.gl = renderer.gl;\n\n    /**\n     * Track textures in the renderer so we can no longer listen to them on destruction.\n     *\n     * @member {Array<*>}\n     * @private\n     */\n    this._managedTextures = [];\n  }\n\n  /**\n   * Binds a texture.\n   *\n   */\n\n  TextureManager.prototype.bindTexture = function bindTexture() {}\n  // empty\n\n  /**\n   * Gets a texture.\n   *\n   */;\n\n  TextureManager.prototype.getTexture = function getTexture() {}\n  // empty\n\n  /**\n   * Updates and/or Creates a WebGL texture for the renderer's context.\n   *\n   * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to update\n   * @param {number} location - the location the texture will be bound to.\n   * @return {GLTexture} The gl texture.\n   */;\n\n  TextureManager.prototype.updateTexture = function updateTexture(texture, location) {\n    // assume it good!\n    // texture = texture.baseTexture || texture;\n\n    var gl = this.gl;\n    var isRenderTexture = !!texture._glRenderTargets;\n    if (!texture.hasLoaded) {\n      return null;\n    }\n    var boundTextures = this.renderer.boundTextures;\n\n    // if the location is undefined then this may have been called by n event.\n    // this being the case the texture may already be bound to a slot. As a texture can only be bound once\n    // we need to find its current location if it exists.\n    if (location === undefined) {\n      location = 0;\n\n      // TODO maybe we can use texture bound ids later on...\n      // check if texture is already bound..\n      for (var i = 0; i < boundTextures.length; ++i) {\n        if (boundTextures[i] === texture) {\n          location = i;\n          break;\n        }\n      }\n    }\n    boundTextures[location] = texture;\n    gl.activeTexture(gl.TEXTURE0 + location);\n    var glTexture = texture._glTextures[this.renderer.CONTEXT_UID];\n    if (!glTexture) {\n      if (isRenderTexture) {\n        var renderTarget = new _RenderTarget2.default(this.gl, texture.width, texture.height, texture.scaleMode, texture.resolution);\n        renderTarget.resize(texture.width, texture.height);\n        texture._glRenderTargets[this.renderer.CONTEXT_UID] = renderTarget;\n        glTexture = renderTarget.texture;\n\n        // framebuffer constructor disactivates current framebuffer\n        if (!this.renderer._activeRenderTarget.root) {\n          this.renderer._activeRenderTarget.frameBuffer.bind();\n        }\n      } else {\n        glTexture = new _pixiGlCore.GLTexture(this.gl, null, null, null, null);\n        glTexture.bind(location);\n        glTexture.premultiplyAlpha = true;\n        glTexture.upload(texture.source);\n      }\n      texture._glTextures[this.renderer.CONTEXT_UID] = glTexture;\n      texture.on('update', this.updateTexture, this);\n      texture.on('dispose', this.destroyTexture, this);\n      this._managedTextures.push(texture);\n      if (texture.isPowerOfTwo) {\n        if (texture.mipmap) {\n          glTexture.enableMipmap();\n        }\n        if (texture.wrapMode === _const.WRAP_MODES.CLAMP) {\n          glTexture.enableWrapClamp();\n        } else if (texture.wrapMode === _const.WRAP_MODES.REPEAT) {\n          glTexture.enableWrapRepeat();\n        } else {\n          glTexture.enableWrapMirrorRepeat();\n        }\n      } else {\n        glTexture.enableWrapClamp();\n      }\n      if (texture.scaleMode === _const.SCALE_MODES.NEAREST) {\n        glTexture.enableNearestScaling();\n      } else {\n        glTexture.enableLinearScaling();\n      }\n    }\n    // the texture already exists so we only need to update it..\n    else if (isRenderTexture) {\n      texture._glRenderTargets[this.renderer.CONTEXT_UID].resize(texture.width, texture.height);\n    } else {\n      glTexture.upload(texture.source);\n    }\n    return glTexture;\n  };\n\n  /**\n   * Deletes the texture from WebGL\n   *\n   * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy\n   * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n   */\n\n  TextureManager.prototype.destroyTexture = function destroyTexture(texture, skipRemove) {\n    texture = texture.baseTexture || texture;\n    if (!texture.hasLoaded) {\n      return;\n    }\n    var renderer = this.renderer;\n    var uid = renderer.CONTEXT_UID;\n    var glTextures = texture._glTextures;\n    var glRenderTargets = texture._glRenderTargets;\n    if (glTextures[uid]) {\n      renderer.unbindTexture(texture);\n      glTextures[uid].destroy();\n      texture.off('update', this.updateTexture, this);\n      texture.off('dispose', this.destroyTexture, this);\n      delete glTextures[uid];\n      if (!skipRemove) {\n        var i = this._managedTextures.indexOf(texture);\n        if (i !== -1) {\n          (0, _utils.removeItems)(this._managedTextures, i, 1);\n        }\n      }\n    }\n    if (glRenderTargets && glRenderTargets[uid]) {\n      if (renderer._activeRenderTarget === glRenderTargets[uid]) {\n        renderer.bindRenderTarget(renderer.rootRenderTarget);\n      }\n      glRenderTargets[uid].destroy();\n      delete glRenderTargets[uid];\n    }\n  };\n\n  /**\n   * Deletes all the textures from WebGL\n   */\n\n  TextureManager.prototype.removeAll = function removeAll() {\n    // empty all the old gl textures as they are useless now\n    for (var i = 0; i < this._managedTextures.length; ++i) {\n      var texture = this._managedTextures[i];\n      if (texture._glTextures[this.renderer.CONTEXT_UID]) {\n        delete texture._glTextures[this.renderer.CONTEXT_UID];\n      }\n    }\n  };\n\n  /**\n   * Destroys this manager and removes all its textures\n   */\n\n  TextureManager.prototype.destroy = function destroy() {\n    // destroy managed textures\n    for (var i = 0; i < this._managedTextures.length; ++i) {\n      var texture = this._managedTextures[i];\n      this.destroyTexture(texture, true);\n      texture.off('update', this.updateTexture, this);\n      texture.off('dispose', this.destroyTexture, this);\n    }\n    this._managedTextures = null;\n  };\n  return TextureManager;\n}();\nexports.default = TextureManager;","map":{"version":3,"names":["_pixiGlCore","require","_const","_RenderTarget","_utils","TextureManager","renderer","_classCallCheck","gl","_managedTextures","bindTexture","getTexture","updateTexture","texture","location","isRenderTexture","_glRenderTargets","hasLoaded","boundTextures","undefined","i","length","activeTexture","TEXTURE0","glTexture","_glTextures","CONTEXT_UID","renderTarget","_RenderTarget2","default","width","height","scaleMode","resolution","resize","_activeRenderTarget","root","frameBuffer","bind","GLTexture","premultiplyAlpha","upload","source","on","destroyTexture","push","isPowerOfTwo","mipmap","enableMipmap","wrapMode","WRAP_MODES","CLAMP","enableWrapClamp","REPEAT","enableWrapRepeat","enableWrapMirrorRepeat","SCALE_MODES","NEAREST","enableNearestScaling","enableLinearScaling","skipRemove","baseTexture","uid","glTextures","glRenderTargets","unbindTexture","destroy","off","indexOf","removeItems","bindRenderTarget","rootRenderTarget","removeAll"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/renderers/webgl/TextureManager.js"],"sourcesContent":["import { GLTexture } from 'pixi-gl-core';\nimport { WRAP_MODES, SCALE_MODES } from '../../const';\nimport RenderTarget from './utils/RenderTarget';\nimport { removeItems } from '../../utils';\n\n/**\n * Helper class to create a webGL Texture\n *\n * @class\n * @memberof PIXI\n */\nexport default class TextureManager\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        /**\n         * A reference to the current renderer\n         *\n         * @member {PIXI.WebGLRenderer}\n         */\n        this.renderer = renderer;\n\n        /**\n         * The current WebGL rendering context\n         *\n         * @member {WebGLRenderingContext}\n         */\n        this.gl = renderer.gl;\n\n        /**\n         * Track textures in the renderer so we can no longer listen to them on destruction.\n         *\n         * @member {Array<*>}\n         * @private\n         */\n        this._managedTextures = [];\n    }\n\n    /**\n     * Binds a texture.\n     *\n     */\n    bindTexture()\n    {\n        // empty\n    }\n\n    /**\n     * Gets a texture.\n     *\n     */\n    getTexture()\n    {\n        // empty\n    }\n\n    /**\n     * Updates and/or Creates a WebGL texture for the renderer's context.\n     *\n     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to update\n     * @param {number} location - the location the texture will be bound to.\n     * @return {GLTexture} The gl texture.\n     */\n    updateTexture(texture, location)\n    {\n        // assume it good!\n        // texture = texture.baseTexture || texture;\n\n        const gl = this.gl;\n\n        const isRenderTexture = !!texture._glRenderTargets;\n\n        if (!texture.hasLoaded)\n        {\n            return null;\n        }\n\n        const boundTextures = this.renderer.boundTextures;\n\n        // if the location is undefined then this may have been called by n event.\n        // this being the case the texture may already be bound to a slot. As a texture can only be bound once\n        // we need to find its current location if it exists.\n        if (location === undefined)\n        {\n            location = 0;\n\n            // TODO maybe we can use texture bound ids later on...\n            // check if texture is already bound..\n            for (let i = 0; i < boundTextures.length; ++i)\n            {\n                if (boundTextures[i] === texture)\n                {\n                    location = i;\n                    break;\n                }\n            }\n        }\n\n        boundTextures[location] = texture;\n\n        gl.activeTexture(gl.TEXTURE0 + location);\n\n        let glTexture = texture._glTextures[this.renderer.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            if (isRenderTexture)\n            {\n                const renderTarget = new RenderTarget(\n                    this.gl,\n                    texture.width,\n                    texture.height,\n                    texture.scaleMode,\n                    texture.resolution\n                );\n\n                renderTarget.resize(texture.width, texture.height);\n                texture._glRenderTargets[this.renderer.CONTEXT_UID] = renderTarget;\n                glTexture = renderTarget.texture;\n\n                // framebuffer constructor disactivates current framebuffer\n                if (!this.renderer._activeRenderTarget.root)\n                {\n                    this.renderer._activeRenderTarget.frameBuffer.bind();\n                }\n            }\n            else\n            {\n                glTexture = new GLTexture(this.gl, null, null, null, null);\n                glTexture.bind(location);\n                glTexture.premultiplyAlpha = true;\n                glTexture.upload(texture.source);\n            }\n\n            texture._glTextures[this.renderer.CONTEXT_UID] = glTexture;\n\n            texture.on('update', this.updateTexture, this);\n            texture.on('dispose', this.destroyTexture, this);\n\n            this._managedTextures.push(texture);\n\n            if (texture.isPowerOfTwo)\n            {\n                if (texture.mipmap)\n                {\n                    glTexture.enableMipmap();\n                }\n\n                if (texture.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    glTexture.enableWrapClamp();\n                }\n                else if (texture.wrapMode === WRAP_MODES.REPEAT)\n                {\n                    glTexture.enableWrapRepeat();\n                }\n                else\n                {\n                    glTexture.enableWrapMirrorRepeat();\n                }\n            }\n            else\n            {\n                glTexture.enableWrapClamp();\n            }\n\n            if (texture.scaleMode === SCALE_MODES.NEAREST)\n            {\n                glTexture.enableNearestScaling();\n            }\n            else\n            {\n                glTexture.enableLinearScaling();\n            }\n        }\n        // the texture already exists so we only need to update it..\n        else if (isRenderTexture)\n        {\n            texture._glRenderTargets[this.renderer.CONTEXT_UID].resize(texture.width, texture.height);\n        }\n        else\n        {\n            glTexture.upload(texture.source);\n        }\n\n        return glTexture;\n    }\n\n    /**\n     * Deletes the texture from WebGL\n     *\n     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy\n     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n     */\n    destroyTexture(texture, skipRemove)\n    {\n        texture = texture.baseTexture || texture;\n\n        if (!texture.hasLoaded)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const uid = renderer.CONTEXT_UID;\n        const glTextures = texture._glTextures;\n        const glRenderTargets = texture._glRenderTargets;\n\n        if (glTextures[uid])\n        {\n            renderer.unbindTexture(texture);\n\n            glTextures[uid].destroy();\n            texture.off('update', this.updateTexture, this);\n            texture.off('dispose', this.destroyTexture, this);\n\n            delete glTextures[uid];\n\n            if (!skipRemove)\n            {\n                const i = this._managedTextures.indexOf(texture);\n\n                if (i !== -1)\n                {\n                    removeItems(this._managedTextures, i, 1);\n                }\n            }\n        }\n\n        if (glRenderTargets && glRenderTargets[uid])\n        {\n            if (renderer._activeRenderTarget === glRenderTargets[uid])\n            {\n                renderer.bindRenderTarget(renderer.rootRenderTarget);\n            }\n\n            glRenderTargets[uid].destroy();\n            delete glRenderTargets[uid];\n        }\n    }\n\n    /**\n     * Deletes all the textures from WebGL\n     */\n    removeAll()\n    {\n        // empty all the old gl textures as they are useless now\n        for (let i = 0; i < this._managedTextures.length; ++i)\n        {\n            const texture = this._managedTextures[i];\n\n            if (texture._glTextures[this.renderer.CONTEXT_UID])\n            {\n                delete texture._glTextures[this.renderer.CONTEXT_UID];\n            }\n        }\n    }\n\n    /**\n     * Destroys this manager and removes all its textures\n     */\n    destroy()\n    {\n        // destroy managed textures\n        for (let i = 0; i < this._managedTextures.length; ++i)\n        {\n            const texture = this._managedTextures[i];\n\n            this.destroyTexture(texture, true);\n\n            texture.off('update', this.updateTexture, this);\n            texture.off('dispose', this.destroyTexture, this);\n        }\n\n        this._managedTextures = null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}