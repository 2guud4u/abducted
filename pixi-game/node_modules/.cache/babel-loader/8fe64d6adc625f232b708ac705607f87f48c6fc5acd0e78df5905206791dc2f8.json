{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.default = buildRoundedRectangle;\nvar _earcut = require('earcut');\nvar _earcut2 = _interopRequireDefault(_earcut);\nvar _buildLine = require('./buildLine');\nvar _buildLine2 = _interopRequireDefault(_buildLine);\nvar _utils = require('../../../utils');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the webGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines\n */\nfunction buildRoundedRectangle(graphicsData, webGLData, webGLDataNativeLines) {\n  var rrectData = graphicsData.shape;\n  var x = rrectData.x;\n  var y = rrectData.y;\n  var width = rrectData.width;\n  var height = rrectData.height;\n  var radius = rrectData.radius;\n  var recPoints = [];\n  recPoints.push(x + radius, y);\n  quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, recPoints);\n  quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, recPoints);\n  quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, recPoints);\n  quadraticBezierCurve(x, y + radius, x, y, x + radius + 0.0000000001, y, recPoints);\n\n  // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n  // TODO - fix this properly, this is not very elegant.. but it works for now.\n\n  if (graphicsData.fill) {\n    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);\n    var alpha = graphicsData.fillAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n    var vecPos = verts.length / 6;\n    var triangles = (0, _earcut2.default)(recPoints, null, 2);\n    for (var i = 0, j = triangles.length; i < j; i += 3) {\n      indices.push(triangles[i] + vecPos);\n      indices.push(triangles[i] + vecPos);\n      indices.push(triangles[i + 1] + vecPos);\n      indices.push(triangles[i + 2] + vecPos);\n      indices.push(triangles[i + 2] + vecPos);\n    }\n    for (var _i = 0, _j = recPoints.length; _i < _j; _i++) {\n      verts.push(recPoints[_i], recPoints[++_i], r, g, b, alpha);\n    }\n  }\n  if (graphicsData.lineWidth) {\n    var tempPoints = graphicsData.points;\n    graphicsData.points = recPoints;\n    (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);\n    graphicsData.points = tempPoints;\n  }\n}\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\nfunction getPt(n1, n2, perc) {\n  var diff = n2 - n1;\n  return n1 + diff * perc;\n}\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY) {\n  var out = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n  var n = 20;\n  var points = out;\n  var xa = 0;\n  var ya = 0;\n  var xb = 0;\n  var yb = 0;\n  var x = 0;\n  var y = 0;\n  for (var i = 0, j = 0; i <= n; ++i) {\n    j = i / n;\n\n    // The Green Line\n    xa = getPt(fromX, cpX, j);\n    ya = getPt(fromY, cpY, j);\n    xb = getPt(cpX, toX, j);\n    yb = getPt(cpY, toY, j);\n\n    // The Black Dot\n    x = getPt(xa, xb, j);\n    y = getPt(ya, yb, j);\n    points.push(x, y);\n  }\n  return points;\n}","map":{"version":3,"names":["buildRoundedRectangle","_earcut","require","_buildLine","_utils","graphicsData","webGLData","webGLDataNativeLines","rrectData","shape","x","y","width","height","radius","recPoints","push","quadraticBezierCurve","fill","color","hex2rgb","fillColor","alpha","fillAlpha","r","g","b","verts","points","indices","vecPos","length","triangles","_earcut2","default","i","j","_i","_j","lineWidth","tempPoints","_buildLine2","getPt","n1","n2","perc","diff","fromX","fromY","cpX","cpY","toX","toY","out","arguments","undefined","n","xa","ya","xb","yb"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/graphics/webgl/utils/buildRoundedRectangle.js"],"sourcesContent":["import earcut from 'earcut';\nimport buildLine from './buildLine';\nimport { hex2rgb } from '../../../utils';\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the webGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines\n */\nexport default function buildRoundedRectangle(graphicsData, webGLData, webGLDataNativeLines)\n{\n    const rrectData = graphicsData.shape;\n    const x = rrectData.x;\n    const y = rrectData.y;\n    const width = rrectData.width;\n    const height = rrectData.height;\n\n    const radius = rrectData.radius;\n\n    const recPoints = [];\n\n    recPoints.push(x + radius, y);\n    quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, recPoints);\n    quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, recPoints);\n    quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, recPoints);\n    quadraticBezierCurve(x, y + radius, x, y, x + radius + 0.0000000001, y, recPoints);\n\n    // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n    // TODO - fix this properly, this is not very elegant.. but it works for now.\n\n    if (graphicsData.fill)\n    {\n        const color = hex2rgb(graphicsData.fillColor);\n        const alpha = graphicsData.fillAlpha;\n\n        const r = color[0] * alpha;\n        const g = color[1] * alpha;\n        const b = color[2] * alpha;\n\n        const verts = webGLData.points;\n        const indices = webGLData.indices;\n\n        const vecPos = verts.length / 6;\n\n        const triangles = earcut(recPoints, null, 2);\n\n        for (let i = 0, j = triangles.length; i < j; i += 3)\n        {\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i + 1] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n        }\n\n        for (let i = 0, j = recPoints.length; i < j; i++)\n        {\n            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);\n        }\n    }\n\n    if (graphicsData.lineWidth)\n    {\n        const tempPoints = graphicsData.points;\n\n        graphicsData.points = recPoints;\n\n        buildLine(graphicsData, webGLData, webGLDataNativeLines);\n\n        graphicsData.points = tempPoints;\n    }\n}\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\nfunction getPt(n1, n2, perc)\n{\n    const diff = n2 - n1;\n\n    return n1 + (diff * perc);\n}\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out = [])\n{\n    const n = 20;\n    const points = out;\n\n    let xa = 0;\n    let ya = 0;\n    let xb = 0;\n    let yb = 0;\n    let x = 0;\n    let y = 0;\n\n    for (let i = 0, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt(fromX, cpX, j);\n        ya = getPt(fromY, cpY, j);\n        xb = getPt(cpX, toX, j);\n        yb = getPt(cpY, toY, j);\n\n        // The Black Dot\n        x = getPt(xa, xb, j);\n        y = getPt(ya, yb, j);\n\n        points.push(x, y);\n    }\n\n    return points;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}