{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _ObjectRenderer2 = require('../../renderers/webgl/utils/ObjectRenderer');\nvar _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);\nvar _WebGLRenderer = require('../../renderers/webgl/WebGLRenderer');\nvar _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);\nvar _createIndicesForQuads = require('../../utils/createIndicesForQuads');\nvar _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);\nvar _generateMultiTextureShader = require('./generateMultiTextureShader');\nvar _generateMultiTextureShader2 = _interopRequireDefault(_generateMultiTextureShader);\nvar _checkMaxIfStatmentsInShader = require('../../renderers/webgl/utils/checkMaxIfStatmentsInShader');\nvar _checkMaxIfStatmentsInShader2 = _interopRequireDefault(_checkMaxIfStatmentsInShader);\nvar _BatchBuffer = require('./BatchBuffer');\nvar _BatchBuffer2 = _interopRequireDefault(_BatchBuffer);\nvar _settings = require('../../settings');\nvar _settings2 = _interopRequireDefault(_settings);\nvar _utils = require('../../utils');\nvar _pixiGlCore = require('pixi-gl-core');\nvar _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);\nvar _bitTwiddle = require('bit-twiddle');\nvar _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar TICK = 0;\nvar TEXTURE_TICK = 0;\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @private\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\n\nvar SpriteRenderer = function (_ObjectRenderer) {\n  _inherits(SpriteRenderer, _ObjectRenderer);\n\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n   */\n  function SpriteRenderer(renderer) {\n    _classCallCheck(this, SpriteRenderer);\n\n    /**\n     * Number of values sent in the vertex buffer.\n     * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5\n     *\n     * @member {number}\n     */\n    var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));\n    _this.vertSize = 5;\n\n    /**\n     * The size of the vertex information in bytes.\n     *\n     * @member {number}\n     */\n    _this.vertByteSize = _this.vertSize * 4;\n\n    /**\n     * The number of images in the SpriteRenderer before it flushes.\n     *\n     * @member {number}\n     */\n    _this.size = _settings2.default.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n\n    // the total number of bytes in our batch\n    // let numVerts = this.size * 4 * this.vertByteSize;\n\n    _this.buffers = [];\n    for (var i = 1; i <= _bitTwiddle2.default.nextPow2(_this.size); i *= 2) {\n      _this.buffers.push(new _BatchBuffer2.default(i * 4 * _this.vertByteSize));\n    }\n\n    /**\n     * Holds the indices of the geometry (quads) to draw\n     *\n     * @member {Uint16Array}\n     */\n    _this.indices = (0, _createIndicesForQuads2.default)(_this.size);\n\n    /**\n     * The default shaders that is used if a sprite doesn't have a more specific one.\n     * there is a shader for each number of textures that can be rendererd.\n     * These shaders will also be generated on the fly as required.\n     * @member {PIXI.Shader[]}\n     */\n    _this.shader = null;\n    _this.currentIndex = 0;\n    _this.groups = [];\n    for (var k = 0; k < _this.size; k++) {\n      _this.groups[k] = {\n        textures: [],\n        textureCount: 0,\n        ids: [],\n        size: 0,\n        start: 0,\n        blend: 0\n      };\n    }\n    _this.sprites = [];\n    _this.vertexBuffers = [];\n    _this.vaos = [];\n    _this.vaoMax = 2;\n    _this.vertexCount = 0;\n    _this.renderer.on('prerender', _this.onPrerender, _this);\n    return _this;\n  }\n\n  /**\n   * Sets up the renderer context and necessary buffers.\n   *\n   * @private\n   */\n\n  SpriteRenderer.prototype.onContextChange = function onContextChange() {\n    var gl = this.renderer.gl;\n    if (this.renderer.legacy) {\n      this.MAX_TEXTURES = 1;\n    } else {\n      // step 1: first check max textures the GPU can handle.\n      this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _settings2.default.SPRITE_MAX_TEXTURES);\n\n      // step 2: check the maximum number of if statements the shader can have too..\n      this.MAX_TEXTURES = (0, _checkMaxIfStatmentsInShader2.default)(this.MAX_TEXTURES, gl);\n    }\n    this.shader = (0, _generateMultiTextureShader2.default)(gl, this.MAX_TEXTURES);\n\n    // create a couple of buffers\n    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);\n\n    // we use the second shader as the first one depending on your browser may omit aTextureId\n    // as it is not used by the shader so is optimized out.\n\n    this.renderer.bindVao(null);\n    var attrs = this.shader.attributes;\n    for (var i = 0; i < this.vaoMax; i++) {\n      /* eslint-disable max-len */\n      var vertexBuffer = this.vertexBuffers[i] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n      /* eslint-enable max-len */\n\n      // build the vao object that will render..\n      var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n      if (attrs.aTextureId) {\n        vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n      }\n      this.vaos[i] = vao;\n    }\n    this.vao = this.vaos[0];\n    this.currentBlendMode = 99999;\n    this.boundTextures = new Array(this.MAX_TEXTURES);\n  };\n\n  /**\n   * Called before the renderer starts rendering.\n   *\n   */\n\n  SpriteRenderer.prototype.onPrerender = function onPrerender() {\n    this.vertexCount = 0;\n  };\n\n  /**\n   * Renders the sprite object.\n   *\n   * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n   */\n\n  SpriteRenderer.prototype.render = function render(sprite) {\n    // TODO set blend modes..\n    // check texture..\n    if (this.currentIndex >= this.size) {\n      this.flush();\n    }\n\n    // get the uvs for the texture\n\n    // if the uvs have not updated then no point rendering just yet!\n    if (!sprite._texture._uvs) {\n      return;\n    }\n\n    // push a texture.\n    // increment the batchsize\n    this.sprites[this.currentIndex++] = sprite;\n  };\n\n  /**\n   * Renders the content and empties the current batch.\n   *\n   */\n\n  SpriteRenderer.prototype.flush = function flush() {\n    if (this.currentIndex === 0) {\n      return;\n    }\n    var gl = this.renderer.gl;\n    var MAX_TEXTURES = this.MAX_TEXTURES;\n    var np2 = _bitTwiddle2.default.nextPow2(this.currentIndex);\n    var log2 = _bitTwiddle2.default.log2(np2);\n    var buffer = this.buffers[log2];\n    var sprites = this.sprites;\n    var groups = this.groups;\n    var float32View = buffer.float32View;\n    var uint32View = buffer.uint32View;\n    var boundTextures = this.boundTextures;\n    var rendererBoundTextures = this.renderer.boundTextures;\n    var touch = this.renderer.textureGC.count;\n    var index = 0;\n    var nextTexture = void 0;\n    var currentTexture = void 0;\n    var groupCount = 1;\n    var textureCount = 0;\n    var currentGroup = groups[0];\n    var vertexData = void 0;\n    var uvs = void 0;\n    var blendMode = _utils.premultiplyBlendMode[sprites[0]._texture.baseTexture.premultipliedAlpha ? 1 : 0][sprites[0].blendMode];\n    currentGroup.textureCount = 0;\n    currentGroup.start = 0;\n    currentGroup.blend = blendMode;\n    TICK++;\n    var i = void 0;\n\n    // copy textures..\n    for (i = 0; i < MAX_TEXTURES; ++i) {\n      var bt = rendererBoundTextures[i];\n      if (bt._enabled === TICK) {\n        boundTextures[i] = this.renderer.emptyTextures[i];\n        continue;\n      }\n      boundTextures[i] = bt;\n      bt._virtalBoundId = i;\n      bt._enabled = TICK;\n    }\n    TICK++;\n    for (i = 0; i < this.currentIndex; ++i) {\n      // upload the sprite elemetns...\n      // they have all ready been calculated so we just need to push them into the buffer.\n      var sprite = sprites[i];\n      sprites[i] = null;\n      nextTexture = sprite._texture.baseTexture;\n      var spriteBlendMode = _utils.premultiplyBlendMode[Number(nextTexture.premultipliedAlpha)][sprite.blendMode];\n      if (blendMode !== spriteBlendMode) {\n        // finish a group..\n        blendMode = spriteBlendMode;\n\n        // force the batch to break!\n        currentTexture = null;\n        textureCount = MAX_TEXTURES;\n        TICK++;\n      }\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n        if (nextTexture._enabled !== TICK) {\n          if (textureCount === MAX_TEXTURES) {\n            TICK++;\n            currentGroup.size = i - currentGroup.start;\n            textureCount = 0;\n            currentGroup = groups[groupCount++];\n            currentGroup.blend = blendMode;\n            currentGroup.textureCount = 0;\n            currentGroup.start = i;\n          }\n          nextTexture.touched = touch;\n          if (nextTexture._virtalBoundId === -1) {\n            for (var j = 0; j < MAX_TEXTURES; ++j) {\n              var tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES;\n              var t = boundTextures[tIndex];\n              if (t._enabled !== TICK) {\n                TEXTURE_TICK++;\n                t._virtalBoundId = -1;\n                nextTexture._virtalBoundId = tIndex;\n                boundTextures[tIndex] = nextTexture;\n                break;\n              }\n            }\n          }\n          nextTexture._enabled = TICK;\n          currentGroup.textureCount++;\n          currentGroup.ids[textureCount] = nextTexture._virtalBoundId;\n          currentGroup.textures[textureCount++] = nextTexture;\n        }\n      }\n      vertexData = sprite.vertexData;\n\n      // TODO this sum does not need to be set each frame..\n      uvs = sprite._texture._uvs.uvsUint32;\n      if (this.renderer.roundPixels) {\n        var resolution = this.renderer.resolution;\n\n        // xy\n        float32View[index] = (vertexData[0] * resolution | 0) / resolution;\n        float32View[index + 1] = (vertexData[1] * resolution | 0) / resolution;\n\n        // xy\n        float32View[index + 5] = (vertexData[2] * resolution | 0) / resolution;\n        float32View[index + 6] = (vertexData[3] * resolution | 0) / resolution;\n\n        // xy\n        float32View[index + 10] = (vertexData[4] * resolution | 0) / resolution;\n        float32View[index + 11] = (vertexData[5] * resolution | 0) / resolution;\n\n        // xy\n        float32View[index + 15] = (vertexData[6] * resolution | 0) / resolution;\n        float32View[index + 16] = (vertexData[7] * resolution | 0) / resolution;\n      } else {\n        // xy\n        float32View[index] = vertexData[0];\n        float32View[index + 1] = vertexData[1];\n\n        // xy\n        float32View[index + 5] = vertexData[2];\n        float32View[index + 6] = vertexData[3];\n\n        // xy\n        float32View[index + 10] = vertexData[4];\n        float32View[index + 11] = vertexData[5];\n\n        // xy\n        float32View[index + 15] = vertexData[6];\n        float32View[index + 16] = vertexData[7];\n      }\n      uint32View[index + 2] = uvs[0];\n      uint32View[index + 7] = uvs[1];\n      uint32View[index + 12] = uvs[2];\n      uint32View[index + 17] = uvs[3];\n      /* eslint-disable max-len */\n      var alpha = Math.min(sprite.worldAlpha, 1.0);\n      // we dont call extra function if alpha is 1.0, that's faster\n      var argb = alpha < 1.0 && nextTexture.premultipliedAlpha ? (0, _utils.premultiplyTint)(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);\n      uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = argb;\n      float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;\n      /* eslint-enable max-len */\n\n      index += 20;\n    }\n    currentGroup.size = i - currentGroup.start;\n    if (!_settings2.default.CAN_UPLOAD_SAME_BUFFER) {\n      // this is still needed for IOS performance..\n      // it really does not like uploading to the same buffer in a single frame!\n      if (this.vaoMax <= this.vertexCount) {\n        this.vaoMax++;\n        var attrs = this.shader.attributes;\n\n        /* eslint-disable max-len */\n        var vertexBuffer = this.vertexBuffers[this.vertexCount] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n        /* eslint-enable max-len */\n\n        // build the vao object that will render..\n        var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n        if (attrs.aTextureId) {\n          vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n        }\n        this.vaos[this.vertexCount] = vao;\n      }\n      this.renderer.bindVao(this.vaos[this.vertexCount]);\n      this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);\n      this.vertexCount++;\n    } else {\n      // lets use the faster option, always use buffer number 0\n      this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true);\n    }\n    for (i = 0; i < MAX_TEXTURES; ++i) {\n      rendererBoundTextures[i]._virtalBoundId = -1;\n    }\n\n    // render the groups..\n    for (i = 0; i < groupCount; ++i) {\n      var group = groups[i];\n      var groupTextureCount = group.textureCount;\n      for (var _j = 0; _j < groupTextureCount; _j++) {\n        currentTexture = group.textures[_j];\n\n        // reset virtual ids..\n        // lets do a quick check..\n        if (rendererBoundTextures[group.ids[_j]] !== currentTexture) {\n          this.renderer.bindTexture(currentTexture, group.ids[_j], true);\n        }\n\n        // reset the virtualId..\n        currentTexture._virtalBoundId = -1;\n      }\n\n      // set the blend mode..\n      this.renderer.state.setBlendMode(group.blend);\n      gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);\n    }\n\n    // reset elements for the next flush\n    this.currentIndex = 0;\n  };\n\n  /**\n   * Starts a new sprite batch.\n   */\n\n  SpriteRenderer.prototype.start = function start() {\n    this.renderer.bindShader(this.shader);\n    if (_settings2.default.CAN_UPLOAD_SAME_BUFFER) {\n      // bind buffer #0, we don't need others\n      this.renderer.bindVao(this.vaos[this.vertexCount]);\n      this.vertexBuffers[this.vertexCount].bind();\n    }\n  };\n\n  /**\n   * Stops and flushes the current batch.\n   *\n   */\n\n  SpriteRenderer.prototype.stop = function stop() {\n    this.flush();\n  };\n\n  /**\n   * Destroys the SpriteRenderer.\n   *\n   */\n\n  SpriteRenderer.prototype.destroy = function destroy() {\n    for (var i = 0; i < this.vaoMax; i++) {\n      if (this.vertexBuffers[i]) {\n        this.vertexBuffers[i].destroy();\n      }\n      if (this.vaos[i]) {\n        this.vaos[i].destroy();\n      }\n    }\n    if (this.indexBuffer) {\n      this.indexBuffer.destroy();\n    }\n    this.renderer.off('prerender', this.onPrerender, this);\n    _ObjectRenderer.prototype.destroy.call(this);\n    if (this.shader) {\n      this.shader.destroy();\n      this.shader = null;\n    }\n    this.vertexBuffers = null;\n    this.vaos = null;\n    this.indexBuffer = null;\n    this.indices = null;\n    this.sprites = null;\n    for (var _i = 0; _i < this.buffers.length; ++_i) {\n      this.buffers[_i].destroy();\n    }\n  };\n  return SpriteRenderer;\n}(_ObjectRenderer3.default);\nexports.default = SpriteRenderer;\n_WebGLRenderer2.default.registerPlugin('sprite', SpriteRenderer);","map":{"version":3,"names":["_ObjectRenderer2","require","_WebGLRenderer","_createIndicesForQuads","_generateMultiTextureShader","_checkMaxIfStatmentsInShader","_BatchBuffer","_settings","_utils","_pixiGlCore","_bitTwiddle","TICK","TEXTURE_TICK","SpriteRenderer","renderer","_classCallCheck","_this","_possibleConstructorReturn","_ObjectRenderer","call","vertSize","vertByteSize","size","_settings2","default","SPRITE_BATCH_SIZE","buffers","i","_bitTwiddle2","nextPow2","push","_BatchBuffer2","indices","_createIndicesForQuads2","shader","currentIndex","groups","k","textures","textureCount","ids","start","blend","sprites","vertexBuffers","vaos","vaoMax","vertexCount","on","onPrerender","onContextChange","gl","legacy","MAX_TEXTURES","Math","min","getParameter","MAX_TEXTURE_IMAGE_UNITS","SPRITE_MAX_TEXTURES","_checkMaxIfStatmentsInShader2","_generateMultiTextureShader2","indexBuffer","_pixiGlCore2","GLBuffer","createIndexBuffer","STATIC_DRAW","bindVao","attrs","attributes","vertexBuffer","createVertexBuffer","STREAM_DRAW","vao","createVao","addIndex","addAttribute","aVertexPosition","FLOAT","aTextureCoord","UNSIGNED_SHORT","aColor","UNSIGNED_BYTE","aTextureId","currentBlendMode","boundTextures","Array","render","sprite","flush","_texture","_uvs","np2","log2","buffer","float32View","uint32View","rendererBoundTextures","touch","textureGC","count","index","nextTexture","currentTexture","groupCount","currentGroup","vertexData","uvs","blendMode","premultiplyBlendMode","baseTexture","premultipliedAlpha","bt","_enabled","emptyTextures","_virtalBoundId","spriteBlendMode","Number","touched","j","tIndex","t","uvsUint32","roundPixels","resolution","alpha","worldAlpha","argb","premultiplyTint","_tintRGB","CAN_UPLOAD_SAME_BUFFER","upload","vertices","group","groupTextureCount","_j","bindTexture","state","setBlendMode","drawElements","TRIANGLES","bindShader","bind","stop","destroy","off","prototype","_i","length","_WebGLRenderer2","registerPlugin"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/sprites/webgl/SpriteRenderer.js"],"sourcesContent":["import ObjectRenderer from '../../renderers/webgl/utils/ObjectRenderer';\nimport WebGLRenderer from '../../renderers/webgl/WebGLRenderer';\nimport createIndicesForQuads from '../../utils/createIndicesForQuads';\nimport generateMultiTextureShader from './generateMultiTextureShader';\nimport checkMaxIfStatmentsInShader from '../../renderers/webgl/utils/checkMaxIfStatmentsInShader';\nimport Buffer from './BatchBuffer';\nimport settings from '../../settings';\nimport { premultiplyBlendMode, premultiplyTint } from '../../utils';\nimport glCore from 'pixi-gl-core';\nimport bitTwiddle from 'bit-twiddle';\n\nlet TICK = 0;\nlet TEXTURE_TICK = 0;\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @private\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport default class SpriteRenderer extends ObjectRenderer\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        /**\n         * Number of values sent in the vertex buffer.\n         * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5\n         *\n         * @member {number}\n         */\n        this.vertSize = 5;\n\n        /**\n         * The size of the vertex information in bytes.\n         *\n         * @member {number}\n         */\n        this.vertByteSize = this.vertSize * 4;\n\n        /**\n         * The number of images in the SpriteRenderer before it flushes.\n         *\n         * @member {number}\n         */\n        this.size = settings.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n\n        // the total number of bytes in our batch\n        // let numVerts = this.size * 4 * this.vertByteSize;\n\n        this.buffers = [];\n        for (let i = 1; i <= bitTwiddle.nextPow2(this.size); i *= 2)\n        {\n            this.buffers.push(new Buffer(i * 4 * this.vertByteSize));\n        }\n\n        /**\n         * Holds the indices of the geometry (quads) to draw\n         *\n         * @member {Uint16Array}\n         */\n        this.indices = createIndicesForQuads(this.size);\n\n        /**\n         * The default shaders that is used if a sprite doesn't have a more specific one.\n         * there is a shader for each number of textures that can be rendererd.\n         * These shaders will also be generated on the fly as required.\n         * @member {PIXI.Shader[]}\n         */\n        this.shader = null;\n\n        this.currentIndex = 0;\n        this.groups = [];\n\n        for (let k = 0; k < this.size; k++)\n        {\n            this.groups[k] = { textures: [], textureCount: 0, ids: [], size: 0, start: 0, blend: 0 };\n        }\n\n        this.sprites = [];\n\n        this.vertexBuffers = [];\n        this.vaos = [];\n\n        this.vaoMax = 2;\n        this.vertexCount = 0;\n\n        this.renderer.on('prerender', this.onPrerender, this);\n    }\n\n    /**\n     * Sets up the renderer context and necessary buffers.\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        if (this.renderer.legacy)\n        {\n            this.MAX_TEXTURES = 1;\n        }\n        else\n        {\n            // step 1: first check max textures the GPU can handle.\n            this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);\n\n            // step 2: check the maximum number of if statements the shader can have too..\n            this.MAX_TEXTURES = checkMaxIfStatmentsInShader(this.MAX_TEXTURES, gl);\n        }\n\n        this.shader = generateMultiTextureShader(gl, this.MAX_TEXTURES);\n\n        // create a couple of buffers\n        this.indexBuffer = glCore.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);\n\n        // we use the second shader as the first one depending on your browser may omit aTextureId\n        // as it is not used by the shader so is optimized out.\n\n        this.renderer.bindVao(null);\n\n        const attrs = this.shader.attributes;\n\n        for (let i = 0; i < this.vaoMax; i++)\n        {\n            /* eslint-disable max-len */\n            const vertexBuffer = this.vertexBuffers[i] = glCore.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n            /* eslint-enable max-len */\n\n            // build the vao object that will render..\n            const vao = this.renderer.createVao()\n                .addIndex(this.indexBuffer)\n                .addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0)\n                .addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4)\n                .addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n\n            if (attrs.aTextureId)\n            {\n                vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n            }\n\n            this.vaos[i] = vao;\n        }\n\n        this.vao = this.vaos[0];\n        this.currentBlendMode = 99999;\n\n        this.boundTextures = new Array(this.MAX_TEXTURES);\n    }\n\n    /**\n     * Called before the renderer starts rendering.\n     *\n     */\n    onPrerender()\n    {\n        this.vertexCount = 0;\n    }\n\n    /**\n     * Renders the sprite object.\n     *\n     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n     */\n    render(sprite)\n    {\n        // TODO set blend modes..\n        // check texture..\n        if (this.currentIndex >= this.size)\n        {\n            this.flush();\n        }\n\n        // get the uvs for the texture\n\n        // if the uvs have not updated then no point rendering just yet!\n        if (!sprite._texture._uvs)\n        {\n            return;\n        }\n\n        // push a texture.\n        // increment the batchsize\n        this.sprites[this.currentIndex++] = sprite;\n    }\n\n    /**\n     * Renders the content and empties the current batch.\n     *\n     */\n    flush()\n    {\n        if (this.currentIndex === 0)\n        {\n            return;\n        }\n\n        const gl = this.renderer.gl;\n        const MAX_TEXTURES = this.MAX_TEXTURES;\n\n        const np2 = bitTwiddle.nextPow2(this.currentIndex);\n        const log2 = bitTwiddle.log2(np2);\n        const buffer = this.buffers[log2];\n\n        const sprites = this.sprites;\n        const groups = this.groups;\n\n        const float32View = buffer.float32View;\n        const uint32View = buffer.uint32View;\n\n        const boundTextures = this.boundTextures;\n        const rendererBoundTextures = this.renderer.boundTextures;\n        const touch = this.renderer.textureGC.count;\n\n        let index = 0;\n        let nextTexture;\n        let currentTexture;\n        let groupCount = 1;\n        let textureCount = 0;\n        let currentGroup = groups[0];\n        let vertexData;\n        let uvs;\n        let blendMode = premultiplyBlendMode[\n            sprites[0]._texture.baseTexture.premultipliedAlpha ? 1 : 0][sprites[0].blendMode];\n\n        currentGroup.textureCount = 0;\n        currentGroup.start = 0;\n        currentGroup.blend = blendMode;\n\n        TICK++;\n\n        let i;\n\n        // copy textures..\n        for (i = 0; i < MAX_TEXTURES; ++i)\n        {\n            const bt = rendererBoundTextures[i];\n\n            if (bt._enabled === TICK)\n            {\n                boundTextures[i] = this.renderer.emptyTextures[i];\n                continue;\n            }\n\n            boundTextures[i] = bt;\n            bt._virtalBoundId = i;\n            bt._enabled = TICK;\n        }\n        TICK++;\n\n        for (i = 0; i < this.currentIndex; ++i)\n        {\n            // upload the sprite elemetns...\n            // they have all ready been calculated so we just need to push them into the buffer.\n            const sprite = sprites[i];\n\n            sprites[i] = null;\n\n            nextTexture = sprite._texture.baseTexture;\n\n            const spriteBlendMode = premultiplyBlendMode[Number(nextTexture.premultipliedAlpha)][sprite.blendMode];\n\n            if (blendMode !== spriteBlendMode)\n            {\n                // finish a group..\n                blendMode = spriteBlendMode;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._enabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        currentGroup.size = i - currentGroup.start;\n\n                        textureCount = 0;\n\n                        currentGroup = groups[groupCount++];\n                        currentGroup.blend = blendMode;\n                        currentGroup.textureCount = 0;\n                        currentGroup.start = i;\n                    }\n\n                    nextTexture.touched = touch;\n\n                    if (nextTexture._virtalBoundId === -1)\n                    {\n                        for (let j = 0; j < MAX_TEXTURES; ++j)\n                        {\n                            const tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES;\n\n                            const t = boundTextures[tIndex];\n\n                            if (t._enabled !== TICK)\n                            {\n                                TEXTURE_TICK++;\n\n                                t._virtalBoundId = -1;\n\n                                nextTexture._virtalBoundId = tIndex;\n\n                                boundTextures[tIndex] = nextTexture;\n                                break;\n                            }\n                        }\n                    }\n\n                    nextTexture._enabled = TICK;\n\n                    currentGroup.textureCount++;\n                    currentGroup.ids[textureCount] = nextTexture._virtalBoundId;\n                    currentGroup.textures[textureCount++] = nextTexture;\n                }\n            }\n\n            vertexData = sprite.vertexData;\n\n            // TODO this sum does not need to be set each frame..\n            uvs = sprite._texture._uvs.uvsUint32;\n\n            if (this.renderer.roundPixels)\n            {\n                const resolution = this.renderer.resolution;\n\n                // xy\n                float32View[index] = ((vertexData[0] * resolution) | 0) / resolution;\n                float32View[index + 1] = ((vertexData[1] * resolution) | 0) / resolution;\n\n                // xy\n                float32View[index + 5] = ((vertexData[2] * resolution) | 0) / resolution;\n                float32View[index + 6] = ((vertexData[3] * resolution) | 0) / resolution;\n\n                // xy\n                float32View[index + 10] = ((vertexData[4] * resolution) | 0) / resolution;\n                float32View[index + 11] = ((vertexData[5] * resolution) | 0) / resolution;\n\n                // xy\n                float32View[index + 15] = ((vertexData[6] * resolution) | 0) / resolution;\n                float32View[index + 16] = ((vertexData[7] * resolution) | 0) / resolution;\n            }\n            else\n            {\n                // xy\n                float32View[index] = vertexData[0];\n                float32View[index + 1] = vertexData[1];\n\n                // xy\n                float32View[index + 5] = vertexData[2];\n                float32View[index + 6] = vertexData[3];\n\n                // xy\n                float32View[index + 10] = vertexData[4];\n                float32View[index + 11] = vertexData[5];\n\n                // xy\n                float32View[index + 15] = vertexData[6];\n                float32View[index + 16] = vertexData[7];\n            }\n\n            uint32View[index + 2] = uvs[0];\n            uint32View[index + 7] = uvs[1];\n            uint32View[index + 12] = uvs[2];\n            uint32View[index + 17] = uvs[3];\n            /* eslint-disable max-len */\n            const alpha = Math.min(sprite.worldAlpha, 1.0);\n            // we dont call extra function if alpha is 1.0, that's faster\n            const argb = alpha < 1.0 && nextTexture.premultipliedAlpha ? premultiplyTint(sprite._tintRGB, alpha)\n                : sprite._tintRGB + (alpha * 255 << 24);\n\n            uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = argb;\n            float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;\n            /* eslint-enable max-len */\n\n            index += 20;\n        }\n\n        currentGroup.size = i - currentGroup.start;\n\n        if (!settings.CAN_UPLOAD_SAME_BUFFER)\n        {\n            // this is still needed for IOS performance..\n            // it really does not like uploading to the same buffer in a single frame!\n            if (this.vaoMax <= this.vertexCount)\n            {\n                this.vaoMax++;\n\n                const attrs = this.shader.attributes;\n\n                /* eslint-disable max-len */\n                const vertexBuffer = this.vertexBuffers[this.vertexCount] = glCore.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n                /* eslint-enable max-len */\n\n                // build the vao object that will render..\n                const vao = this.renderer.createVao()\n                    .addIndex(this.indexBuffer)\n                    .addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0)\n                    .addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4)\n                    .addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n\n                if (attrs.aTextureId)\n                {\n                    vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n                }\n\n                this.vaos[this.vertexCount] = vao;\n            }\n\n            this.renderer.bindVao(this.vaos[this.vertexCount]);\n\n            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);\n\n            this.vertexCount++;\n        }\n        else\n        {\n            // lets use the faster option, always use buffer number 0\n            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true);\n        }\n\n        for (i = 0; i < MAX_TEXTURES; ++i)\n        {\n            rendererBoundTextures[i]._virtalBoundId = -1;\n        }\n\n        // render the groups..\n        for (i = 0; i < groupCount; ++i)\n        {\n            const group = groups[i];\n            const groupTextureCount = group.textureCount;\n\n            for (let j = 0; j < groupTextureCount; j++)\n            {\n                currentTexture = group.textures[j];\n\n                // reset virtual ids..\n                // lets do a quick check..\n                if (rendererBoundTextures[group.ids[j]] !== currentTexture)\n                {\n                    this.renderer.bindTexture(currentTexture, group.ids[j], true);\n                }\n\n                // reset the virtualId..\n                currentTexture._virtalBoundId = -1;\n            }\n\n            // set the blend mode..\n            this.renderer.state.setBlendMode(group.blend);\n\n            gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);\n        }\n\n        // reset elements for the next flush\n        this.currentIndex = 0;\n    }\n\n    /**\n     * Starts a new sprite batch.\n     */\n    start()\n    {\n        this.renderer.bindShader(this.shader);\n\n        if (settings.CAN_UPLOAD_SAME_BUFFER)\n        {\n            // bind buffer #0, we don't need others\n            this.renderer.bindVao(this.vaos[this.vertexCount]);\n\n            this.vertexBuffers[this.vertexCount].bind();\n        }\n    }\n\n    /**\n     * Stops and flushes the current batch.\n     *\n     */\n    stop()\n    {\n        this.flush();\n    }\n\n    /**\n     * Destroys the SpriteRenderer.\n     *\n     */\n    destroy()\n    {\n        for (let i = 0; i < this.vaoMax; i++)\n        {\n            if (this.vertexBuffers[i])\n            {\n                this.vertexBuffers[i].destroy();\n            }\n            if (this.vaos[i])\n            {\n                this.vaos[i].destroy();\n            }\n        }\n\n        if (this.indexBuffer)\n        {\n            this.indexBuffer.destroy();\n        }\n\n        this.renderer.off('prerender', this.onPrerender, this);\n\n        super.destroy();\n\n        if (this.shader)\n        {\n            this.shader.destroy();\n            this.shader = null;\n        }\n\n        this.vertexBuffers = null;\n        this.vaos = null;\n        this.indexBuffer = null;\n        this.indices = null;\n\n        this.sprites = null;\n\n        for (let i = 0; i < this.buffers.length; ++i)\n        {\n            this.buffers[i].destroy();\n        }\n    }\n}\n\nWebGLRenderer.registerPlugin('sprite', SpriteRenderer);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}