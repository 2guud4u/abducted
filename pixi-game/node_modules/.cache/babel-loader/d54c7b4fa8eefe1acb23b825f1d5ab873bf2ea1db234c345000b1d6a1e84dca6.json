{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _core = require('../core');\nvar core = _interopRequireWildcard(_core);\nvar _Texture = require('../core/textures/Texture');\nvar _Texture2 = _interopRequireDefault(_Texture);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar tempPoint = new core.Point();\nvar tempPolygon = new core.Polygon();\n\n/**\n * Base mesh class\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.mesh\n */\n\nvar Mesh = function (_core$Container) {\n  _inherits(Mesh, _core$Container);\n\n  /**\n   * @param {PIXI.Texture} texture - The texture to use\n   * @param {Float32Array} [vertices] - if you want to specify the vertices\n   * @param {Float32Array} [uvs] - if you want to specify the uvs\n   * @param {Uint16Array} [indices] - if you want to specify the indices\n   * @param {number} [drawMode] - the drawMode, can be any of the Mesh.DRAW_MODES consts\n   */\n  function Mesh(texture, vertices, uvs, indices, drawMode) {\n    _classCallCheck(this, Mesh);\n\n    /**\n     * The texture of the Mesh\n     *\n     * @member {PIXI.Texture}\n     * @default PIXI.Texture.EMPTY\n     * @private\n     */\n    var _this = _possibleConstructorReturn(this, _core$Container.call(this));\n    _this._texture = texture || _Texture2.default.EMPTY;\n\n    /**\n     * The Uvs of the Mesh\n     *\n     * @member {Float32Array}\n     */\n    _this.uvs = uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n\n    /**\n     * An array of vertices\n     *\n     * @member {Float32Array}\n     */\n    _this.vertices = vertices || new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);\n\n    /**\n     * An array containing the indices of the vertices\n     *\n     * @member {Uint16Array}\n     */\n    //  TODO auto generate this based on draw mode!\n    _this.indices = indices || new Uint16Array([0, 1, 3, 2]);\n\n    /**\n     * Version of mesh uvs are dirty or not\n     *\n     * @member {number}\n     */\n    _this.dirty = 0;\n\n    /**\n     * Version of mesh indices\n     *\n     * @member {number}\n     */\n    _this.indexDirty = 0;\n\n    /**\n     * Version of mesh verticies array\n     *\n     * @member {number}\n     */\n    _this.vertexDirty = 0;\n\n    /**\n     * For backwards compatibility the default is to re-upload verticies each render call.\n     * Set this to `false` and increase `vertexDirty` to manually re-upload the buffer.\n     *\n     * @member {boolean}\n     */\n    _this.autoUpdate = true;\n\n    /**\n     * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove\n     * any blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL\n     * @see PIXI.BLEND_MODES\n     */\n    _this.blendMode = core.BLEND_MODES.NORMAL;\n\n    /**\n     * Triangles in canvas mode are automatically antialiased, use this value to force triangles\n     * to overlap a bit with each other.\n     *\n     * @member {number}\n     */\n    _this.canvasPadding = core.settings.MESH_CANVAS_PADDING;\n\n    /**\n     * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts\n     *\n     * @member {number}\n     * @see PIXI.mesh.Mesh.DRAW_MODES\n     */\n    _this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;\n\n    /**\n     * The default shader that is used if a mesh doesn't have a more specific one.\n     *\n     * @member {PIXI.Shader}\n     */\n    _this.shader = null;\n\n    /**\n     * The tint applied to the mesh. This is a [r,g,b] value. A value of [1,1,1] will remove any\n     * tint effect.\n     *\n     * @member {number}\n     */\n    _this.tintRgb = new Float32Array([1, 1, 1]);\n\n    /**\n     * A map of renderer IDs to webgl render data\n     *\n     * @private\n     * @member {object<number, object>}\n     */\n    _this._glDatas = {};\n\n    /**\n     * transform that is applied to UV to get the texture coords\n     * its updated independently from texture uvTransform\n     * updates of uvs are tied to that thing\n     *\n     * @member {PIXI.TextureMatrix}\n     * @private\n     */\n    _this._uvTransform = new core.TextureMatrix(_this._texture);\n\n    /**\n     * whether or not upload uvTransform to shader\n     * if its false, then uvs should be pre-multiplied\n     * if you change it for generated mesh, please call 'refresh(true)'\n     * @member {boolean}\n     * @default false\n     */\n    _this.uploadUvTransform = false;\n\n    /**\n     * Plugin that is responsible for rendering this element.\n     * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.\n     * @member {string}\n     * @default 'mesh'\n     */\n    _this.pluginName = 'mesh';\n    return _this;\n  }\n\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - a reference to the WebGL renderer\n   */\n\n  Mesh.prototype._renderWebGL = function _renderWebGL(renderer) {\n    this.refresh();\n    renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  };\n\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n   */\n\n  Mesh.prototype._renderCanvas = function _renderCanvas(renderer) {\n    this.refresh();\n    renderer.plugins[this.pluginName].render(this);\n  };\n\n  /**\n   * When the texture is updated, this event will fire to update the scale and frame\n   *\n   * @private\n   */\n\n  Mesh.prototype._onTextureUpdate = function _onTextureUpdate() {\n    this._uvTransform.texture = this._texture;\n    this.refresh();\n  };\n\n  /**\n   * multiplies uvs only if uploadUvTransform is false\n   * call it after you change uvs manually\n   * make sure that texture is valid\n   */\n\n  Mesh.prototype.multiplyUvs = function multiplyUvs() {\n    if (!this.uploadUvTransform) {\n      this._uvTransform.multiplyUvs(this.uvs);\n    }\n  };\n\n  /**\n   * Refreshes uvs for generated meshes (rope, plane)\n   * sometimes refreshes vertices too\n   *\n   * @param {boolean} [forceUpdate=false] if true, matrices will be updated any case\n   */\n\n  Mesh.prototype.refresh = function refresh(forceUpdate) {\n    if (this.autoUpdate) {\n      this.vertexDirty++;\n    }\n    if (this._uvTransform.update(forceUpdate)) {\n      this._refresh();\n    }\n  };\n\n  /**\n   * re-calculates mesh coords\n   * @protected\n   */\n\n  Mesh.prototype._refresh = function _refresh() {}\n  /* empty */\n\n  /**\n   * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n   *\n   */;\n\n  Mesh.prototype._calculateBounds = function _calculateBounds() {\n    // TODO - we can cache local bounds and use them if they are dirty (like graphics)\n    this._bounds.addVertices(this.transform, this.vertices, 0, this.vertices.length);\n  };\n\n  /**\n   * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH\n   *\n   * @param {PIXI.Point} point - the point to test\n   * @return {boolean} the result of the test\n   */\n\n  Mesh.prototype.containsPoint = function containsPoint(point) {\n    if (!this.getBounds().contains(point.x, point.y)) {\n      return false;\n    }\n    this.worldTransform.applyInverse(point, tempPoint);\n    var vertices = this.vertices;\n    var points = tempPolygon.points;\n    var indices = this.indices;\n    var len = this.indices.length;\n    var step = this.drawMode === Mesh.DRAW_MODES.TRIANGLES ? 3 : 1;\n    for (var i = 0; i + 2 < len; i += step) {\n      var ind0 = indices[i] * 2;\n      var ind1 = indices[i + 1] * 2;\n      var ind2 = indices[i + 2] * 2;\n      points[0] = vertices[ind0];\n      points[1] = vertices[ind0 + 1];\n      points[2] = vertices[ind1];\n      points[3] = vertices[ind1 + 1];\n      points[4] = vertices[ind2];\n      points[5] = vertices[ind2 + 1];\n      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * The texture that the mesh uses.\n   *\n   * @member {PIXI.Texture}\n   */\n\n  /**\n   * Destroys the Mesh object.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n  Mesh.prototype.destroy = function destroy(options) {\n    // for each webgl data entry, destroy the WebGLGraphicsData\n    for (var id in this._glDatas) {\n      var data = this._glDatas[id];\n      if (data.destroy) {\n        data.destroy();\n      } else {\n        if (data.vertexBuffer) {\n          data.vertexBuffer.destroy();\n          data.vertexBuffer = null;\n        }\n        if (data.indexBuffer) {\n          data.indexBuffer.destroy();\n          data.indexBuffer = null;\n        }\n        if (data.uvBuffer) {\n          data.uvBuffer.destroy();\n          data.uvBuffer = null;\n        }\n        if (data.vao) {\n          data.vao.destroy();\n          data.vao = null;\n        }\n      }\n    }\n    this._glDatas = null;\n    _core$Container.prototype.destroy.call(this, options);\n  };\n  _createClass(Mesh, [{\n    key: 'texture',\n    get: function get() {\n      return this._texture;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      if (this._texture === value) {\n        return;\n      }\n      this._texture = value;\n      if (value) {\n        // wait for the texture to load\n        if (value.baseTexture.hasLoaded) {\n          this._onTextureUpdate();\n        } else {\n          value.once('update', this._onTextureUpdate, this);\n        }\n      }\n    }\n\n    /**\n     * The tint applied to the mesh. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n  }, {\n    key: 'tint',\n    get: function get() {\n      return core.utils.rgb2hex(this.tintRgb);\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this.tintRgb = core.utils.hex2rgb(value, this.tintRgb);\n    }\n  }]);\n  return Mesh;\n}(core.Container);\n\n/**\n * Different drawing buffer modes supported\n *\n * @static\n * @constant\n * @type {object}\n * @property {number} TRIANGLE_MESH\n * @property {number} TRIANGLES\n */\n\nexports.default = Mesh;\nMesh.DRAW_MODES = {\n  TRIANGLE_MESH: 0,\n  TRIANGLES: 1\n};","map":{"version":3,"names":["_core","require","core","_Texture","tempPoint","Point","tempPolygon","Polygon","Mesh","texture","vertices","uvs","indices","drawMode","_classCallCheck","_this","_possibleConstructorReturn","_core$Container","call","_texture","_Texture2","default","EMPTY","Float32Array","Uint16Array","dirty","indexDirty","vertexDirty","autoUpdate","blendMode","BLEND_MODES","NORMAL","canvasPadding","settings","MESH_CANVAS_PADDING","DRAW_MODES","TRIANGLE_MESH","shader","tintRgb","_glDatas","_uvTransform","TextureMatrix","uploadUvTransform","pluginName","_renderWebGL","renderer","refresh","setObjectRenderer","plugins","render","_renderCanvas","_onTextureUpdate","multiplyUvs","forceUpdate","update","_refresh","_calculateBounds","_bounds","addVertices","transform","length","containsPoint","point","getBounds","contains","x","y","worldTransform","applyInverse","points","len","step","TRIANGLES","i","ind0","ind1","ind2","destroy","options","id","data","vertexBuffer","indexBuffer","uvBuffer","vao","prototype","value","baseTexture","hasLoaded","once","utils","rgb2hex","hex2rgb","Container"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/mesh/Mesh.js"],"sourcesContent":["import * as core from '../core';\nimport Texture from '../core/textures/Texture';\n\nconst tempPoint = new core.Point();\nconst tempPolygon = new core.Polygon();\n\n/**\n * Base mesh class\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.mesh\n */\nexport default class Mesh extends core.Container\n{\n    /**\n     * @param {PIXI.Texture} texture - The texture to use\n     * @param {Float32Array} [vertices] - if you want to specify the vertices\n     * @param {Float32Array} [uvs] - if you want to specify the uvs\n     * @param {Uint16Array} [indices] - if you want to specify the indices\n     * @param {number} [drawMode] - the drawMode, can be any of the Mesh.DRAW_MODES consts\n     */\n    constructor(texture, vertices, uvs, indices, drawMode)\n    {\n        super();\n\n        /**\n         * The texture of the Mesh\n         *\n         * @member {PIXI.Texture}\n         * @default PIXI.Texture.EMPTY\n         * @private\n         */\n        this._texture = texture || Texture.EMPTY;\n\n        /**\n         * The Uvs of the Mesh\n         *\n         * @member {Float32Array}\n         */\n        this.uvs = uvs || new Float32Array([\n            0, 0,\n            1, 0,\n            1, 1,\n            0, 1]);\n\n        /**\n         * An array of vertices\n         *\n         * @member {Float32Array}\n         */\n        this.vertices = vertices || new Float32Array([\n            0, 0,\n            100, 0,\n            100, 100,\n            0, 100]);\n\n        /**\n         * An array containing the indices of the vertices\n         *\n         * @member {Uint16Array}\n         */\n        //  TODO auto generate this based on draw mode!\n        this.indices = indices || new Uint16Array([0, 1, 3, 2]);\n\n        /**\n         * Version of mesh uvs are dirty or not\n         *\n         * @member {number}\n         */\n        this.dirty = 0;\n\n        /**\n         * Version of mesh indices\n         *\n         * @member {number}\n         */\n        this.indexDirty = 0;\n\n        /**\n         * Version of mesh verticies array\n         *\n         * @member {number}\n         */\n        this.vertexDirty = 0;\n\n        /**\n         * For backwards compatibility the default is to re-upload verticies each render call.\n         * Set this to `false` and increase `vertexDirty` to manually re-upload the buffer.\n         *\n         * @member {boolean}\n         */\n        this.autoUpdate = true;\n\n        /**\n         * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove\n         * any blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL\n         * @see PIXI.BLEND_MODES\n         */\n        this.blendMode = core.BLEND_MODES.NORMAL;\n\n        /**\n         * Triangles in canvas mode are automatically antialiased, use this value to force triangles\n         * to overlap a bit with each other.\n         *\n         * @member {number}\n         */\n        this.canvasPadding = core.settings.MESH_CANVAS_PADDING;\n\n        /**\n         * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts\n         *\n         * @member {number}\n         * @see PIXI.mesh.Mesh.DRAW_MODES\n         */\n        this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;\n\n        /**\n         * The default shader that is used if a mesh doesn't have a more specific one.\n         *\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        /**\n         * The tint applied to the mesh. This is a [r,g,b] value. A value of [1,1,1] will remove any\n         * tint effect.\n         *\n         * @member {number}\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n\n        /**\n         * A map of renderer IDs to webgl render data\n         *\n         * @private\n         * @member {object<number, object>}\n         */\n        this._glDatas = {};\n\n        /**\n         * transform that is applied to UV to get the texture coords\n         * its updated independently from texture uvTransform\n         * updates of uvs are tied to that thing\n         *\n         * @member {PIXI.TextureMatrix}\n         * @private\n         */\n        this._uvTransform = new core.TextureMatrix(this._texture);\n\n        /**\n         * whether or not upload uvTransform to shader\n         * if its false, then uvs should be pre-multiplied\n         * if you change it for generated mesh, please call 'refresh(true)'\n         * @member {boolean}\n         * @default false\n         */\n        this.uploadUvTransform = false;\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.\n         * @member {string}\n         * @default 'mesh'\n         */\n        this.pluginName = 'mesh';\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - a reference to the WebGL renderer\n     */\n    _renderWebGL(renderer)\n    {\n        this.refresh();\n        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n     */\n    _renderCanvas(renderer)\n    {\n        this.refresh();\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * When the texture is updated, this event will fire to update the scale and frame\n     *\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        this._uvTransform.texture = this._texture;\n        this.refresh();\n    }\n\n    /**\n     * multiplies uvs only if uploadUvTransform is false\n     * call it after you change uvs manually\n     * make sure that texture is valid\n     */\n    multiplyUvs()\n    {\n        if (!this.uploadUvTransform)\n        {\n            this._uvTransform.multiplyUvs(this.uvs);\n        }\n    }\n\n    /**\n     * Refreshes uvs for generated meshes (rope, plane)\n     * sometimes refreshes vertices too\n     *\n     * @param {boolean} [forceUpdate=false] if true, matrices will be updated any case\n     */\n    refresh(forceUpdate)\n    {\n        if (this.autoUpdate)\n        {\n            this.vertexDirty++;\n        }\n        if (this._uvTransform.update(forceUpdate))\n        {\n            this._refresh();\n        }\n    }\n\n    /**\n     * re-calculates mesh coords\n     * @protected\n     */\n    _refresh()\n    {\n        /* empty */\n    }\n\n    /**\n     * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     *\n     */\n    _calculateBounds()\n    {\n        // TODO - we can cache local bounds and use them if they are dirty (like graphics)\n        this._bounds.addVertices(this.transform, this.vertices, 0, this.vertices.length);\n    }\n\n    /**\n     * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        if (!this.getBounds().contains(point.x, point.y))\n        {\n            return false;\n        }\n\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const vertices = this.vertices;\n        const points = tempPolygon.points;\n        const indices = this.indices;\n        const len = this.indices.length;\n        const step = this.drawMode === Mesh.DRAW_MODES.TRIANGLES ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * The texture that the mesh uses.\n     *\n     * @member {PIXI.Texture}\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    set texture(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._texture === value)\n        {\n            return;\n        }\n\n        this._texture = value;\n\n        if (value)\n        {\n            // wait for the texture to load\n            if (value.baseTexture.hasLoaded)\n            {\n                this._onTextureUpdate();\n            }\n            else\n            {\n                value.once('update', this._onTextureUpdate, this);\n            }\n        }\n    }\n\n    /**\n     * The tint applied to the mesh. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    get tint()\n    {\n        return core.utils.rgb2hex(this.tintRgb);\n    }\n\n    set tint(value) // eslint-disable-line require-jsdoc\n    {\n        this.tintRgb = core.utils.hex2rgb(value, this.tintRgb);\n    }\n\n    /**\n     * Destroys the Mesh object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        // for each webgl data entry, destroy the WebGLGraphicsData\n        for (const id in this._glDatas)\n        {\n            const data = this._glDatas[id];\n\n            if (data.destroy)\n            {\n                data.destroy();\n            }\n            else\n            {\n                if (data.vertexBuffer)\n                {\n                    data.vertexBuffer.destroy();\n                    data.vertexBuffer = null;\n                }\n                if (data.indexBuffer)\n                {\n                    data.indexBuffer.destroy();\n                    data.indexBuffer = null;\n                }\n                if (data.uvBuffer)\n                {\n                    data.uvBuffer.destroy();\n                    data.uvBuffer = null;\n                }\n                if (data.vao)\n                {\n                    data.vao.destroy();\n                    data.vao = null;\n                }\n            }\n        }\n\n        this._glDatas = null;\n\n        super.destroy(options);\n    }\n}\n\n/**\n * Different drawing buffer modes supported\n *\n * @static\n * @constant\n * @type {object}\n * @property {number} TRIANGLE_MESH\n * @property {number} TRIANGLES\n */\nMesh.DRAW_MODES = {\n    TRIANGLE_MESH: 0,\n    TRIANGLES: 1,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}