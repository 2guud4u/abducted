{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar _const = require('../const.js');\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy, eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy, sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy, cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    }\n    verts.push(cx, cy, ex, ey);\n  } else {\n    verts.push(sx, sy, cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius, cx, cy);\n    }\n    verts.push(ex, ey, cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  const shape = graphicsData.shape;\n  let points = graphicsData.points || shape.points.slice();\n  const eps = graphicsGeometry.closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = graphicsData.lineStyle;\n  const firstPoint = new core.Point(points[0], points[1]);\n  const lastPoint = new core.Point(points[points.length - 2], points[points.length - 1]);\n  const closedShape = shape.type !== core.SHAPES.POLY || shape.closeStroke;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = graphicsGeometry.points;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpx = -(y0 - y1);\n  let perpy = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  const ratio = style.alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === _const.LINE_CAP.ROUND) {\n      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;\n    } else if (style.cap === _const.LINE_CAP.SQUARE) {\n      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      if (dot >= 0) {\n        if (style.join === _const.LINE_JOIN.ROUND) {\n          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);\n      }\n      continue;\n    }\n    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n    let join = style.join;\n    if (join === _const.LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared) {\n      join = _const.LINE_JOIN.BEVEL;\n    }\n    if (insideMiterOk) {\n      switch (join) {\n        case _const.LINE_JOIN.MITER:\n          {\n            verts.push(imx, imy, omx, omy);\n            break;\n          }\n        case _const.LINE_JOIN.BEVEL:\n          {\n            if (clockwise) {\n              verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight, imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n            } else {\n              verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);\n            }\n            indexCount += 2;\n            break;\n          }\n        case _const.LINE_JOIN.ROUND:\n          {\n            if (clockwise) {\n              verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n              indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n              verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n            } else {\n              verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy);\n              indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n              verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);\n            }\n            break;\n          }\n      }\n    } else {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      switch (join) {\n        case _const.LINE_JOIN.MITER:\n          {\n            if (clockwise) {\n              verts.push(omx, omy, omx, omy);\n            } else {\n              verts.push(imx, imy, imx, imy);\n            }\n            indexCount += 2;\n            break;\n          }\n        case _const.LINE_JOIN.ROUND:\n          {\n            if (clockwise) {\n              indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n            } else {\n              indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n            }\n            break;\n          }\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpx = -(y0 - y1);\n  perpy = x0 - x1;\n  dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n  if (!closedShape) {\n    if (style.cap === _const.LINE_CAP.ROUND) {\n      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;\n    } else if (style.cap === _const.LINE_CAP.SQUARE) {\n      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const indices = graphicsGeometry.indices;\n  const eps2 = _const.curves.epsilon * _const.curves.epsilon;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  let i = 0;\n  const shape = graphicsData.shape;\n  const points = graphicsData.points || shape.points;\n  const closedShape = shape.type !== core.SHAPES.POLY || shape.closeStroke;\n  if (points.length === 0) return;\n  const verts = graphicsGeometry.points;\n  const indices = graphicsGeometry.indices;\n  const length = points.length / 2;\n  const startIndex = verts.length / 2;\n  let currentIndex = startIndex;\n  verts.push(points[0], points[1]);\n  for (i = 1; i < length; i++) {\n    verts.push(points[i * 2], points[i * 2 + 1]);\n    indices.push(currentIndex, currentIndex + 1);\n    currentIndex++;\n  }\n  if (closedShape) {\n    indices.push(currentIndex, startIndex);\n  }\n}\nfunction buildLine(graphicsData, graphicsGeometry) {\n  if (graphicsData.lineStyle.native) {\n    buildNativeLine(graphicsData, graphicsGeometry);\n  } else {\n    buildNonNativeLine(graphicsData, graphicsGeometry);\n  }\n}\nexports.buildLine = buildLine;","map":{"version":3,"names":["square","x","y","nx","ny","innerWeight","outerWeight","clockwise","verts","ix","iy","ox","oy","exx","eyy","eix","eiy","eox","eoy","push","round","cx","cy","sx","sy","ex","ey","cx2p0x","cy2p0y","angle0","Math","atan2","angle1","PI","startAngle","angleDiff","absAngleDiff","abs","radius","sqrt","segCount","angleInc","i","angle","sin","cos","buildNonNativeLine","graphicsData","graphicsGeometry","shape","points","slice","eps","closePointEps","length","style","lineStyle","firstPoint","core","Point","lastPoint","closedShape","type","SHAPES","POLY","closeStroke","closedPath","pop","set","midPointX","midPointY","unshift","indexCount","indexStart","width","widthSquared","miterLimitSquared","miterLimit","x0","y0","x1","y1","x2","y2","perpx","perpy","perp1x","perp1y","dist","ratio","alignment","cap","_const","LINE_CAP","ROUND","SQUARE","dx0","dy0","dx1","dy1","dot","cross","join","LINE_JOIN","c1","c2","px","py","pdist","imx","imy","omx","omy","smallerInsideSegmentSq","min","insideWeight","smallerInsideDiagonalSq","insideMiterOk","MITER","BEVEL","indices","eps2","curves","epsilon","buildNativeLine","startIndex","currentIndex","buildLine","native"],"sources":["/Users/jiahuajiang/Desktop/code/projects/abducted/pixi-game/node_modules/@pixi/graphics/src/utils/buildLine.ts"],"sourcesContent":["import { Point, SHAPES } from '@pixi/core';\nimport { curves, LINE_CAP, LINE_JOIN } from '../const';\n\nimport type { Polygon } from '@pixi/core';\nimport type { GraphicsData } from '../GraphicsData';\nimport type { GraphicsGeometry } from '../GraphicsGeometry';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(\n        eix, eiy,\n        eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -curves.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(\n            cx, cy,\n            sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(\n                cx, cy,\n                cx + ((Math.sin(angle) * radius)), cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(\n            cx, cy,\n            ex, ey);\n    }\n    else\n    {\n        verts.push(\n            sx, sy,\n            cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(\n                cx + ((Math.sin(angle) * radius)), cy + ((Math.cos(angle) * radius)),\n                cx, cy);\n        }\n\n        verts.push(\n            ex, ey,\n            cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpx * innerWeight),\n                y0 - (perpy * innerWeight),\n                x0 + (perpx * outerWeight),\n                y0 + (perpy * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight), y0 - (perpy * innerWeight),\n        x0 + (perpx * outerWeight), y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === LINE_JOIN.ROUND)\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight), y1 - (perp1y * outerWeight),\n                    x1 + (perp1x * innerWeight), y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n\n        let join = style.join;\n\n        if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared)\n        {\n            join = LINE_JOIN.BEVEL;\n        }\n\n        if (insideMiterOk)\n        {\n            switch (join)\n            {\n                case LINE_JOIN.MITER:\n                {\n                    verts.push(\n                        imx, imy,\n                        omx, omy);\n                    break;\n                }\n                case LINE_JOIN.BEVEL:\n                {\n                    if (clockwise) /* rotating at inner angle */\n                    {\n                        verts.push(\n                            imx, imy, // inner miter point\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight), // first segment's outer vertex\n                            imx, imy, // inner miter point\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                    }\n                    else /* rotating at outer angle */\n                    {\n                        verts.push(\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight), // first segment's inner vertex\n                            omx, omy, // outer miter point\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight), // second segment's outer vertex\n                            omx, omy); // outer miter point\n                    }\n\n                    indexCount += 2;\n                    break;\n                }\n                case LINE_JOIN.ROUND:\n                {\n                    if (clockwise) /* arc is outside */\n                    {\n                        verts.push(\n                            imx, imy,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                        indexCount += round(\n                            x1, y1,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                            verts, true\n                        ) + 4;\n\n                        verts.push(\n                            imx, imy,\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                    }\n                    else /* arc is inside */\n                    {\n                        verts.push(\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            omx, omy);\n\n                        indexCount += round(\n                            x1, y1,\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            verts, false\n                        ) + 4;\n\n                        verts.push(\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            omx, omy);\n                    }\n                    break;\n                }\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(\n                x1 - (perpx * innerWeight), y1 - (perpy * innerWeight), // first segment's inner vertex\n                x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n            switch (join)\n            {\n                case LINE_JOIN.MITER:\n                {\n                    if (clockwise)\n                    {\n                        verts.push(\n                            omx, omy, // inner miter point\n                            omx, omy); // inner miter point\n                    }\n                    else\n                    {\n                        verts.push(\n                            imx, imy, // outer miter point\n                            imx, imy); // outer miter point\n                    }\n                    indexCount += 2;\n                    break;\n                }\n                case LINE_JOIN.ROUND:\n                {\n                    if (clockwise) /* arc is outside */\n                    {\n                        indexCount += round(\n                            x1, y1,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                            verts, true\n                        ) + 2;\n                    }\n                    else /* arc is inside */\n                    {\n                        indexCount += round(\n                            x1, y1,\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            verts, false\n                        ) + 2;\n                    }\n                    break;\n                }\n            }\n            verts.push(\n                x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight), // second segment's inner vertex\n                x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(\n        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = curves.epsilon * curves.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    let i = 0;\n\n    const shape = graphicsData.shape as Polygon;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}