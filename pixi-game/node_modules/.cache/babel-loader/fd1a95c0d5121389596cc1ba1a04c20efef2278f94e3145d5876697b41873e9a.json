{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _BaseTexture2 = require('./BaseTexture');\nvar _BaseTexture3 = _interopRequireDefault(_BaseTexture2);\nvar _utils = require('../utils');\nvar _ticker = require('../ticker');\nvar _const = require('../const');\nvar _determineCrossOrigin = require('../utils/determineCrossOrigin');\nvar _determineCrossOrigin2 = _interopRequireDefault(_determineCrossOrigin);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * A texture of a [playing] Video.\n *\n * Video base textures mimic PixiJS BaseTexture.from.... method in their creation process.\n *\n * This can be used in several ways, such as:\n *\n * ```js\n * let texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');\n *\n * let texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls([\n *     { src: '/video.webm', mime: 'video/webm' },\n *     { src: '/video.mp4', mime: 'video/mp4' }\n * ]);\n * ```\n *\n * See the [\"deus\" demo](http://www.goodboydigital.com/pixijs/examples/deus/).\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n */\nvar VideoBaseTexture = function (_BaseTexture) {\n  _inherits(VideoBaseTexture, _BaseTexture);\n\n  /**\n   * @param {HTMLVideoElement} source - Video source\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   */\n  function VideoBaseTexture(source, scaleMode) {\n    var autoPlay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    _classCallCheck(this, VideoBaseTexture);\n    if (!source) {\n      throw new Error('No video source element specified.');\n    }\n\n    // hook in here to check if video is already available.\n    // BaseTexture looks for a source.complete boolean, plus width & height.\n\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, source, scaleMode));\n    _this.width = source.videoWidth;\n    _this.height = source.videoHeight;\n    _this._autoUpdate = true;\n    _this._isAutoUpdating = false;\n\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    _this.autoPlay = autoPlay;\n    _this.update = _this.update.bind(_this);\n    _this._onCanPlay = _this._onCanPlay.bind(_this);\n    source.addEventListener('play', _this._onPlayStart.bind(_this));\n    source.addEventListener('pause', _this._onPlayStop.bind(_this));\n    _this.hasLoaded = false;\n    _this.__loaded = false;\n    if (!_this._isSourceReady()) {\n      source.addEventListener('canplay', _this._onCanPlay);\n      source.addEventListener('canplaythrough', _this._onCanPlay);\n    } else {\n      _this._onCanPlay();\n    }\n    return _this;\n  }\n\n  /**\n   * Returns true if the underlying source is playing.\n   *\n   * @private\n   * @return {boolean} True if playing.\n   */\n\n  VideoBaseTexture.prototype._isSourcePlaying = function _isSourcePlaying() {\n    var source = this.source;\n    return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;\n  };\n\n  /**\n   * Returns true if the underlying source is ready for playing.\n   *\n   * @private\n   * @return {boolean} True if ready.\n   */\n\n  VideoBaseTexture.prototype._isSourceReady = function _isSourceReady() {\n    return this.source.readyState === 3 || this.source.readyState === 4;\n  };\n\n  /**\n   * Runs the update loop when the video is ready to play\n   *\n   * @private\n   */\n\n  VideoBaseTexture.prototype._onPlayStart = function _onPlayStart() {\n    // Just in case the video has not received its can play even yet..\n    if (!this.hasLoaded) {\n      this._onCanPlay();\n    }\n    if (!this._isAutoUpdating && this.autoUpdate) {\n      _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);\n      this._isAutoUpdating = true;\n    }\n  };\n\n  /**\n   * Fired when a pause event is triggered, stops the update loop\n   *\n   * @private\n   */\n\n  VideoBaseTexture.prototype._onPlayStop = function _onPlayStop() {\n    if (this._isAutoUpdating) {\n      _ticker.shared.remove(this.update, this);\n      this._isAutoUpdating = false;\n    }\n  };\n\n  /**\n   * Fired when the video is loaded and ready to play\n   *\n   * @private\n   */\n\n  VideoBaseTexture.prototype._onCanPlay = function _onCanPlay() {\n    this.hasLoaded = true;\n    if (this.source) {\n      this.source.removeEventListener('canplay', this._onCanPlay);\n      this.source.removeEventListener('canplaythrough', this._onCanPlay);\n      this.width = this.source.videoWidth;\n      this.height = this.source.videoHeight;\n\n      // prevent multiple loaded dispatches..\n      if (!this.__loaded) {\n        this.__loaded = true;\n        this.emit('loaded', this);\n      }\n      if (this._isSourcePlaying()) {\n        this._onPlayStart();\n      } else if (this.autoPlay) {\n        this.source.play();\n      }\n    }\n  };\n\n  /**\n   * Destroys this texture\n   *\n   */\n\n  VideoBaseTexture.prototype.destroy = function destroy() {\n    if (this._isAutoUpdating) {\n      _ticker.shared.remove(this.update, this);\n    }\n    if (this.source && this.source._pixiId) {\n      _BaseTexture3.default.removeFromCache(this.source._pixiId);\n      delete this.source._pixiId;\n      this.source.pause();\n      this.source.src = '';\n      this.source.load();\n    }\n    _BaseTexture.prototype.destroy.call(this);\n  };\n\n  /**\n   * Mimic PixiJS BaseTexture.from.... method.\n   *\n   * @static\n   * @param {HTMLVideoElement} video - Video to create texture from\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n   */\n\n  VideoBaseTexture.fromVideo = function fromVideo(video, scaleMode, autoPlay) {\n    if (!video._pixiId) {\n      video._pixiId = 'video_' + (0, _utils.uid)();\n    }\n    var baseTexture = _utils.BaseTextureCache[video._pixiId];\n    if (!baseTexture) {\n      baseTexture = new VideoBaseTexture(video, scaleMode, autoPlay);\n      _BaseTexture3.default.addToCache(baseTexture, video._pixiId);\n    }\n    return baseTexture;\n  };\n\n  /**\n   * Helper function that creates a new BaseTexture based on the given video element.\n   * This BaseTexture can then be used to create a texture\n   *\n   * @static\n   * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.\n   * @param {string} [videoSrc.src] - One of the source urls for the video\n   * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified\n   *  the url's extension will be used as the second part of the mime type.\n   * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n   */\n\n  VideoBaseTexture.fromUrl = function fromUrl(videoSrc, scaleMode, crossorigin, autoPlay) {\n    var video = document.createElement('video');\n    video.setAttribute('webkit-playsinline', '');\n    video.setAttribute('playsinline', '');\n    var url = Array.isArray(videoSrc) ? videoSrc[0].src || videoSrc[0] : videoSrc.src || videoSrc;\n    if (crossorigin === undefined && url.indexOf('data:') !== 0) {\n      video.crossOrigin = (0, _determineCrossOrigin2.default)(url);\n    } else if (crossorigin) {\n      video.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n    }\n\n    // array of objects or strings\n    if (Array.isArray(videoSrc)) {\n      for (var i = 0; i < videoSrc.length; ++i) {\n        video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));\n      }\n    }\n    // single object or string\n    else {\n      video.appendChild(createSource(url, videoSrc.mime));\n    }\n    video.load();\n    return VideoBaseTexture.fromVideo(video, scaleMode, autoPlay);\n  };\n\n  /**\n   * Should the base texture automatically update itself, set to true by default\n   *\n   * @member {boolean}\n   */\n\n  _createClass(VideoBaseTexture, [{\n    key: 'autoUpdate',\n    get: function get() {\n      return this._autoUpdate;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      if (value !== this._autoUpdate) {\n        this._autoUpdate = value;\n        if (!this._autoUpdate && this._isAutoUpdating) {\n          _ticker.shared.remove(this.update, this);\n          this._isAutoUpdating = false;\n        } else if (this._autoUpdate && !this._isAutoUpdating) {\n          _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);\n          this._isAutoUpdating = true;\n        }\n      }\n    }\n  }]);\n  return VideoBaseTexture;\n}(_BaseTexture3.default);\nexports.default = VideoBaseTexture;\nVideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;\nfunction createSource(path, type) {\n  if (!type) {\n    var purePath = path.split('?').shift().toLowerCase();\n    type = 'video/' + purePath.substr(purePath.lastIndexOf('.') + 1);\n  }\n  var source = document.createElement('source');\n  source.src = path;\n  source.type = type;\n  return source;\n}","map":{"version":3,"names":["_BaseTexture2","require","_utils","_ticker","_const","_determineCrossOrigin","VideoBaseTexture","source","scaleMode","autoPlay","arguments","length","undefined","_classCallCheck","Error","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","width","height","complete","_this","_possibleConstructorReturn","_BaseTexture","call","videoWidth","videoHeight","_autoUpdate","_isAutoUpdating","update","bind","_onCanPlay","addEventListener","_onPlayStart","_onPlayStop","hasLoaded","__loaded","_isSourceReady","_isSourcePlaying","currentTime","paused","ended","autoUpdate","shared","add","UPDATE_PRIORITY","HIGH","remove","removeEventListener","emit","play","destroy","_pixiId","_BaseTexture3","default","removeFromCache","pause","src","load","prototype","fromVideo","video","uid","baseTexture","BaseTextureCache","addToCache","fromUrl","videoSrc","crossorigin","document","createElement","setAttribute","url","Array","isArray","indexOf","crossOrigin","_determineCrossOrigin2","i","appendChild","createSource","mime","value","fromUrls","path","type","purePath","split","shift","toLowerCase","substr","lastIndexOf"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/textures/VideoBaseTexture.js"],"sourcesContent":["import BaseTexture from './BaseTexture';\nimport { uid, BaseTextureCache } from '../utils';\nimport { shared } from '../ticker';\nimport { UPDATE_PRIORITY } from '../const';\nimport determineCrossOrigin from '../utils/determineCrossOrigin';\n\n/**\n * A texture of a [playing] Video.\n *\n * Video base textures mimic PixiJS BaseTexture.from.... method in their creation process.\n *\n * This can be used in several ways, such as:\n *\n * ```js\n * let texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');\n *\n * let texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls([\n *     { src: '/video.webm', mime: 'video/webm' },\n *     { src: '/video.mp4', mime: 'video/mp4' }\n * ]);\n * ```\n *\n * See the [\"deus\" demo](http://www.goodboydigital.com/pixijs/examples/deus/).\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n */\nexport default class VideoBaseTexture extends BaseTexture\n{\n    /**\n     * @param {HTMLVideoElement} source - Video source\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     */\n    constructor(source, scaleMode, autoPlay = true)\n    {\n        if (!source)\n        {\n            throw new Error('No video source element specified.');\n        }\n\n        // hook in here to check if video is already available.\n        // BaseTexture looks for a source.complete boolean, plus width & height.\n\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            source.complete = true;\n        }\n\n        super(source, scaleMode);\n\n        this.width = source.videoWidth;\n        this.height = source.videoHeight;\n\n        this._autoUpdate = true;\n        this._isAutoUpdating = false;\n\n        /**\n         * When set to true will automatically play videos used by this texture once\n         * they are loaded. If false, it will not modify the playing state.\n         *\n         * @member {boolean}\n         * @default true\n         */\n        this.autoPlay = autoPlay;\n\n        this.update = this.update.bind(this);\n        this._onCanPlay = this._onCanPlay.bind(this);\n\n        source.addEventListener('play', this._onPlayStart.bind(this));\n        source.addEventListener('pause', this._onPlayStop.bind(this));\n        this.hasLoaded = false;\n        this.__loaded = false;\n\n        if (!this._isSourceReady())\n        {\n            source.addEventListener('canplay', this._onCanPlay);\n            source.addEventListener('canplaythrough', this._onCanPlay);\n        }\n        else\n        {\n            this._onCanPlay();\n        }\n    }\n\n    /**\n     * Returns true if the underlying source is playing.\n     *\n     * @private\n     * @return {boolean} True if playing.\n     */\n    _isSourcePlaying()\n    {\n        const source = this.source;\n\n        return (source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2);\n    }\n\n    /**\n     * Returns true if the underlying source is ready for playing.\n     *\n     * @private\n     * @return {boolean} True if ready.\n     */\n    _isSourceReady()\n    {\n        return this.source.readyState === 3 || this.source.readyState === 4;\n    }\n\n    /**\n     * Runs the update loop when the video is ready to play\n     *\n     * @private\n     */\n    _onPlayStart()\n    {\n        // Just in case the video has not received its can play even yet..\n        if (!this.hasLoaded)\n        {\n            this._onCanPlay();\n        }\n\n        if (!this._isAutoUpdating && this.autoUpdate)\n        {\n            shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isAutoUpdating = true;\n        }\n    }\n\n    /**\n     * Fired when a pause event is triggered, stops the update loop\n     *\n     * @private\n     */\n    _onPlayStop()\n    {\n        if (this._isAutoUpdating)\n        {\n            shared.remove(this.update, this);\n            this._isAutoUpdating = false;\n        }\n    }\n\n    /**\n     * Fired when the video is loaded and ready to play\n     *\n     * @private\n     */\n    _onCanPlay()\n    {\n        this.hasLoaded = true;\n\n        if (this.source)\n        {\n            this.source.removeEventListener('canplay', this._onCanPlay);\n            this.source.removeEventListener('canplaythrough', this._onCanPlay);\n\n            this.width = this.source.videoWidth;\n            this.height = this.source.videoHeight;\n\n            // prevent multiple loaded dispatches..\n            if (!this.__loaded)\n            {\n                this.__loaded = true;\n                this.emit('loaded', this);\n            }\n\n            if (this._isSourcePlaying())\n            {\n                this._onPlayStart();\n            }\n            else if (this.autoPlay)\n            {\n                this.source.play();\n            }\n        }\n    }\n\n    /**\n     * Destroys this texture\n     *\n     */\n    destroy()\n    {\n        if (this._isAutoUpdating)\n        {\n            shared.remove(this.update, this);\n        }\n\n        if (this.source && this.source._pixiId)\n        {\n            BaseTexture.removeFromCache(this.source._pixiId);\n            delete this.source._pixiId;\n\n            this.source.pause();\n            this.source.src = '';\n            this.source.load();\n        }\n\n        super.destroy();\n    }\n\n    /**\n     * Mimic PixiJS BaseTexture.from.... method.\n     *\n     * @static\n     * @param {HTMLVideoElement} video - Video to create texture from\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n     */\n    static fromVideo(video, scaleMode, autoPlay)\n    {\n        if (!video._pixiId)\n        {\n            video._pixiId = `video_${uid()}`;\n        }\n\n        let baseTexture = BaseTextureCache[video._pixiId];\n\n        if (!baseTexture)\n        {\n            baseTexture = new VideoBaseTexture(video, scaleMode, autoPlay);\n            BaseTexture.addToCache(baseTexture, video._pixiId);\n        }\n\n        return baseTexture;\n    }\n\n    /**\n     * Helper function that creates a new BaseTexture based on the given video element.\n     * This BaseTexture can then be used to create a texture\n     *\n     * @static\n     * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.\n     * @param {string} [videoSrc.src] - One of the source urls for the video\n     * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified\n     *  the url's extension will be used as the second part of the mime type.\n     * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n     */\n    static fromUrl(videoSrc, scaleMode, crossorigin, autoPlay)\n    {\n        const video = document.createElement('video');\n\n        video.setAttribute('webkit-playsinline', '');\n        video.setAttribute('playsinline', '');\n\n        const url = Array.isArray(videoSrc) ? (videoSrc[0].src || videoSrc[0]) : (videoSrc.src || videoSrc);\n\n        if (crossorigin === undefined && url.indexOf('data:') !== 0)\n        {\n            video.crossOrigin = determineCrossOrigin(url);\n        }\n        else if (crossorigin)\n        {\n            video.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n        }\n\n        // array of objects or strings\n        if (Array.isArray(videoSrc))\n        {\n            for (let i = 0; i < videoSrc.length; ++i)\n            {\n                video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));\n            }\n        }\n        // single object or string\n        else\n        {\n            video.appendChild(createSource(url, videoSrc.mime));\n        }\n\n        video.load();\n\n        return VideoBaseTexture.fromVideo(video, scaleMode, autoPlay);\n    }\n\n    /**\n     * Should the base texture automatically update itself, set to true by default\n     *\n     * @member {boolean}\n     */\n    get autoUpdate()\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value) // eslint-disable-line require-jsdoc\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isAutoUpdating)\n            {\n                shared.remove(this.update, this);\n                this._isAutoUpdating = false;\n            }\n            else if (this._autoUpdate && !this._isAutoUpdating)\n            {\n                shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n                this._isAutoUpdating = true;\n            }\n        }\n    }\n}\n\nVideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;\n\nfunction createSource(path, type)\n{\n    if (!type)\n    {\n        const purePath = path.split('?').shift().toLowerCase();\n\n        type = `video/${purePath.substr(purePath.lastIndexOf('.') + 1)}`;\n    }\n\n    const source = document.createElement('source');\n\n    source.src = path;\n    source.type = type;\n\n    return source;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}