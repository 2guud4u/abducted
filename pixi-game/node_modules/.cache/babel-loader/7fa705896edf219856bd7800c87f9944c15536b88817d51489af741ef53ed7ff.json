{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _Matrix = require('../math/Matrix');\nvar _Matrix2 = _interopRequireDefault(_Matrix);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar tempMat = new _Matrix2.default();\n\n/**\n * Class controls uv transform and frame clamp for texture\n * Can be used in Texture \"transform\" field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * @see PIXI.Texture\n * @see PIXI.mesh.Mesh\n * @see PIXI.extras.TilingSprite\n * @class\n * @memberof PIXI\n */\n\nvar TextureMatrix = function () {\n  /**\n   *\n   * @param {PIXI.Texture} texture observed texture\n   * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   * @constructor\n   */\n  function TextureMatrix(texture, clampMargin) {\n    _classCallCheck(this, TextureMatrix);\n    this._texture = texture;\n    this.mapCoord = new _Matrix2.default();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._lastTextureID = -1;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n     *\n     * @default 0\n     * @member {number}\n     */\n    this.clampOffset = 0;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     *\n     * @default 0.5\n     * @member {number}\n     */\n    this.clampMargin = typeof clampMargin === 'undefined' ? 0.5 : clampMargin;\n  }\n\n  /**\n   * texture property\n   * @member {PIXI.Texture}\n   */\n\n  /**\n   * Multiplies uvs array to transform\n   * @param {Float32Array} uvs mesh uvs\n   * @param {Float32Array} [out=uvs] output\n   * @returns {Float32Array} output\n   */\n  TextureMatrix.prototype.multiplyUvs = function multiplyUvs(uvs, out) {\n    if (out === undefined) {\n      out = uvs;\n    }\n    var mat = this.mapCoord;\n    for (var i = 0; i < uvs.length; i += 2) {\n      var x = uvs[i];\n      var y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  };\n\n  /**\n   * updates matrices if texture was changed\n   * @param {boolean} forceUpdate if true, matrices will be updated any case\n   * @returns {boolean} whether or not it was updated\n   */\n\n  TextureMatrix.prototype.update = function update(forceUpdate) {\n    var tex = this._texture;\n    if (!tex || !tex.valid) {\n      return false;\n    }\n    if (!forceUpdate && this._lastTextureID === tex._updateID) {\n      return false;\n    }\n    this._lastTextureID = tex._updateID;\n    var uvs = tex._uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    var orig = tex.orig;\n    var trim = tex.trim;\n    if (trim) {\n      tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);\n      this.mapCoord.append(tempMat);\n    }\n    var texBase = tex.baseTexture;\n    var frame = this.uClampFrame;\n    var margin = this.clampMargin / texBase.resolution;\n    var offset = this.clampOffset;\n    frame[0] = (tex._frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex._frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = offset / texBase.realWidth;\n    this.uClampOffset[1] = offset / texBase.realHeight;\n    return true;\n  };\n  _createClass(TextureMatrix, [{\n    key: 'texture',\n    get: function get() {\n      return this._texture;\n    },\n    set: function set(value)\n    // eslint-disable-line require-jsdoc\n    {\n      this._texture = value;\n      this._lastTextureID = -1;\n    }\n  }]);\n  return TextureMatrix;\n}();\nexports.default = TextureMatrix;","map":{"version":3,"names":["_Matrix","require","tempMat","_Matrix2","default","TextureMatrix","texture","clampMargin","_classCallCheck","_texture","mapCoord","uClampFrame","Float32Array","uClampOffset","_lastTextureID","clampOffset","multiplyUvs","uvs","out","undefined","mat","i","length","x","y","a","c","tx","b","d","ty","update","forceUpdate","tex","valid","_updateID","_uvs","set","x1","x0","y1","y0","x3","y3","orig","trim","width","height","append","texBase","baseTexture","frame","margin","resolution","offset","_frame","realWidth","realHeight","value"],"sources":["/Users/jiahuajiang/node_modules/pixi.js/src/core/textures/TextureMatrix.js"],"sourcesContent":["import { default as Matrix } from '../math/Matrix';\n\nconst tempMat = new Matrix();\n\n/**\n * Class controls uv transform and frame clamp for texture\n * Can be used in Texture \"transform\" field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * @see PIXI.Texture\n * @see PIXI.mesh.Mesh\n * @see PIXI.extras.TilingSprite\n * @class\n * @memberof PIXI\n */\nexport default class TextureMatrix\n{\n    /**\n     *\n     * @param {PIXI.Texture} texture observed texture\n     * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     * @constructor\n     */\n    constructor(texture, clampMargin)\n    {\n        this._texture = texture;\n\n        this.mapCoord = new Matrix();\n\n        this.uClampFrame = new Float32Array(4);\n\n        this.uClampOffset = new Float32Array(2);\n\n        this._lastTextureID = -1;\n\n        /**\n         * Changes frame clamping\n         * Works with TilingSprite and Mesh\n         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n         *\n         * @default 0\n         * @member {number}\n         */\n        this.clampOffset = 0;\n\n        /**\n         * Changes frame clamping\n         * Works with TilingSprite and Mesh\n         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n         *\n         * @default 0.5\n         * @member {number}\n         */\n        this.clampMargin = (typeof clampMargin === 'undefined') ? 0.5 : clampMargin;\n    }\n\n    /**\n     * texture property\n     * @member {PIXI.Texture}\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    set texture(value) // eslint-disable-line require-jsdoc\n    {\n        this._texture = value;\n        this._lastTextureID = -1;\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param {Float32Array} uvs mesh uvs\n     * @param {Float32Array} [out=uvs] output\n     * @returns {Float32Array} output\n     */\n    multiplyUvs(uvs, out)\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * updates matrices if texture was changed\n     * @param {boolean} forceUpdate if true, matrices will be updated any case\n     * @returns {boolean} whether or not it was updated\n     */\n    update(forceUpdate)\n    {\n        const tex = this._texture;\n\n        if (!tex || !tex.valid)\n        {\n            return false;\n        }\n\n        if (!forceUpdate\n            && this._lastTextureID === tex._updateID)\n        {\n            return false;\n        }\n\n        this._lastTextureID = tex._updateID;\n\n        const uvs = tex._uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height,\n                -trim.x / trim.width, -trim.y / trim.height);\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.baseTexture;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase.resolution;\n        const offset = this.clampOffset;\n\n        frame[0] = (tex._frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex._frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;\n        this.uClampOffset[0] = offset / texBase.realWidth;\n        this.uClampOffset[1] = offset / texBase.realHeight;\n\n        return true;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}